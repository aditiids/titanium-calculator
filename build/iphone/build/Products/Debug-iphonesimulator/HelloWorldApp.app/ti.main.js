'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$i =
// eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) ||
check(typeof window == 'object' && window) ||
// eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) ||
check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
// eslint-disable-next-line no-new-func -- fallback
function () {return this;}() || Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$k = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$j = fails$k;

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails$j(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () {return 7;} })[1] != 7;
});

var fails$i = fails$k;

var functionBindNative = !fails$i(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = function () {/* empty */}.bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$3 = functionBindNative;

var call$d = Function.prototype.call;

var functionCall = NATIVE_BIND$3 ? call$d.bind(call$d) : function () {
  return call$d.apply(call$d, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

var createPropertyDescriptor$5 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var NATIVE_BIND$2 = functionBindNative;

var FunctionPrototype$2 = Function.prototype;
var call$c = FunctionPrototype$2.call;
var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$2.bind.bind(call$c, call$c);

var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function (fn) {
  return function () {
    return call$c.apply(fn, arguments);
  };
};

var uncurryThis$l = functionUncurryThis;

var toString$6 = uncurryThis$l({}.toString);
var stringSlice$5 = uncurryThis$l(''.slice);

var classofRaw$2 = function (it) {
  return stringSlice$5(toString$6(it), 8, -1);
};

var uncurryThis$k = functionUncurryThis;
var fails$h = fails$k;
var classof$b = classofRaw$2;

var $Object$4 = Object;
var split = uncurryThis$k(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$h(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object$4('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$b(it) == 'String' ? split(it, '') : $Object$4(it);
} : $Object$4;

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
var isNullOrUndefined$6 = function (it) {
  return it === null || it === undefined;
};

var isNullOrUndefined$5 = isNullOrUndefined$6;

var $TypeError$d = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$5 = function (it) {
  if (isNullOrUndefined$5(it)) throw $TypeError$d("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject$1 = indexedObject;
var requireObjectCoercible$4 = requireObjectCoercible$5;

var toIndexedObject$4 = function (it) {
  return IndexedObject$1(requireObjectCoercible$4(it));
};

var documentAll$2 = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;

var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA: IS_HTMLDDA
};

var $documentAll$1 = documentAll_1;

var documentAll$1 = $documentAll$1.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
var isCallable$k = $documentAll$1.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll$1;
} : function (argument) {
  return typeof argument == 'function';
};

var isCallable$j = isCallable$k;
var $documentAll = documentAll_1;

var documentAll = $documentAll.all;

var isObject$e = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable$j(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable$j(it);
};

var global$h = global$i;
var isCallable$i = isCallable$k;

var aFunction = function (argument) {
  return isCallable$i(argument) ? argument : undefined;
};

var getBuiltIn$6 = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global$h[namespace]) : global$h[namespace] && global$h[namespace][method];
};

var uncurryThis$j = functionUncurryThis;

var objectIsPrototypeOf = uncurryThis$j({}.isPrototypeOf);

var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

var global$g = global$i;
var userAgent = engineUserAgent;

var process$2 = global$g.process;
var Deno = global$g.Deno;
var versions = process$2 && process$2.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

var engineV8Version = version;

/* eslint-disable es/no-symbol -- required for testing */

var V8_VERSION = engineV8Version;
var fails$g = fails$k;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$g(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

/* eslint-disable es/no-symbol -- required for testing */

var NATIVE_SYMBOL$1 = symbolConstructorDetection;

var useSymbolAsUid = NATIVE_SYMBOL$1 &&
!Symbol.sham &&
typeof Symbol.iterator == 'symbol';

var getBuiltIn$5 = getBuiltIn$6;
var isCallable$h = isCallable$k;
var isPrototypeOf$4 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

var $Object$3 = Object;

var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$5('Symbol');
  return isCallable$h($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));
};

var $String$4 = String;

var tryToString$4 = function (argument) {
  try {
    return $String$4(argument);
  } catch (error) {
    return 'Object';
  }
};

var isCallable$g = isCallable$k;
var tryToString$3 = tryToString$4;

var $TypeError$c = TypeError;

// `Assert: IsCallable(argument) is true`
var aCallable$4 = function (argument) {
  if (isCallable$g(argument)) return argument;
  throw $TypeError$c(tryToString$3(argument) + ' is not a function');
};

var aCallable$3 = aCallable$4;
var isNullOrUndefined$4 = isNullOrUndefined$6;

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
var getMethod$4 = function (V, P) {
  var func = V[P];
  return isNullOrUndefined$4(func) ? undefined : aCallable$3(func);
};

var call$b = functionCall;
var isCallable$f = isCallable$k;
var isObject$d = isObject$e;

var $TypeError$b = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$f(fn = input.toString) && !isObject$d(val = call$b(fn, input))) return val;
  if (isCallable$f(fn = input.valueOf) && !isObject$d(val = call$b(fn, input))) return val;
  if (pref !== 'string' && isCallable$f(fn = input.toString) && !isObject$d(val = call$b(fn, input))) return val;
  throw $TypeError$b("Can't convert object to primitive value");
};

var shared$4 = { exports: {} };

var isPure = false;

var global$f = global$i;

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty$4 = Object.defineProperty;

var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$4(global$f, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global$f[key] = value;
  }return value;
};

var global$e = global$i;
var defineGlobalProperty$2 = defineGlobalProperty$3;

var SHARED = '__core-js_shared__';
var store$3 = global$e[SHARED] || defineGlobalProperty$2(SHARED, {});

var sharedStore = store$3;

var store$2 = sharedStore;

(shared$4.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.27.2',
  mode: 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var requireObjectCoercible$3 = requireObjectCoercible$5;

var $Object$2 = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject$6 = function (argument) {
  return $Object$2(requireObjectCoercible$3(argument));
};

var uncurryThis$i = functionUncurryThis;
var toObject$5 = toObject$6;

var hasOwnProperty$1 = uncurryThis$i({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty$1(toObject$5(it), key);
};

var uncurryThis$h = functionUncurryThis;

var id = 0;
var postfix = Math.random();
var toString$5 = uncurryThis$h(1.0.toString);

var uid$3 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$5(++id + postfix, 36);
};

var global$d = global$i;
var shared$3 = shared$4.exports;
var hasOwn$b = hasOwnProperty_1;
var uid$2 = uid$3;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;

var Symbol$1 = global$d.Symbol;
var WellKnownSymbolsStore = shared$3('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1['for'] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;

var wellKnownSymbol$g = function (name) {
  if (!hasOwn$b(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$b(Symbol$1, name) ?
    Symbol$1[name] :
    createWellKnownSymbol('Symbol.' + name);
  }return WellKnownSymbolsStore[name];
};

var call$a = functionCall;
var isObject$c = isObject$e;
var isSymbol$2 = isSymbol$3;
var getMethod$3 = getMethod$4;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$f = wellKnownSymbol$g;

var $TypeError$a = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$f('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
var toPrimitive$2 = function (input, pref) {
  if (!isObject$c(input) || isSymbol$2(input)) return input;
  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$a(exoticToPrim, input, pref);
    if (!isObject$c(result) || isSymbol$2(result)) return result;
    throw $TypeError$a("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive$1 = toPrimitive$2;
var isSymbol$1 = isSymbol$3;

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
var toPropertyKey$4 = function (argument) {
  var key = toPrimitive$1(argument, 'string');
  return isSymbol$1(key) ? key : key + '';
};

var global$c = global$i;
var isObject$b = isObject$e;

var document$1 = global$c.document;
// typeof document.createElement is 'object' in old IE
var EXISTS$1 = isObject$b(document$1) && isObject$b(document$1.createElement);

var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};

var DESCRIPTORS$b = descriptors;
var fails$f = fails$k;
var createElement = documentCreateElement$1;

// Thanks to IE8 for its funny defineProperty
var ie8DomDefine = !DESCRIPTORS$b && !fails$f(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () {return 7;}
  }).a != 7;
});

var DESCRIPTORS$a = descriptors;
var call$9 = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$3 = toIndexedObject$4;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$a = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$a ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$3(O);
  P = toPropertyKey$3(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error) {/* empty */}
  if (hasOwn$a(O, P)) return createPropertyDescriptor$4(!call$9(propertyIsEnumerableModule.f, O, P), O[P]);
};

var objectDefineProperty = {};

var DESCRIPTORS$9 = descriptors;
var fails$e = fails$k;

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
var v8PrototypeDefineBug = DESCRIPTORS$9 && fails$e(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {/* empty */}, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var isObject$a = isObject$e;

var $String$3 = String;
var $TypeError$9 = TypeError;

// `Assert: Type(argument) is Object`
var anObject$c = function (argument) {
  if (isObject$a(argument)) return argument;
  throw $TypeError$9($String$3(argument) + ' is not an object');
};

var DESCRIPTORS$8 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$b = anObject$c;
var toPropertyKey$2 = toPropertyKey$4;

var $TypeError$8 = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$8 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$b(O);
  P = toPropertyKey$2(P);
  anObject$b(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject$b(O);
  P = toPropertyKey$2(P);
  anObject$b(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$8('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$7 = descriptors;
var definePropertyModule$6 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;

var createNonEnumerableProperty$6 = DESCRIPTORS$7 ? function (object, key, value) {
  return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var makeBuiltIn$2 = { exports: {} };

var DESCRIPTORS$6 = descriptors;
var hasOwn$9 = hasOwnProperty_1;

var FunctionPrototype$1 = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS$6 && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn$9(FunctionPrototype$1, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && function something() {/* empty */}.name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$6 || DESCRIPTORS$6 && getDescriptor(FunctionPrototype$1, 'name').configurable);

var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var uncurryThis$g = functionUncurryThis;
var isCallable$e = isCallable$k;
var store$1 = sharedStore;

var functionToString = uncurryThis$g(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable$e(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$2 = store$1.inspectSource;

var global$b = global$i;
var isCallable$d = isCallable$k;

var WeakMap$1 = global$b.WeakMap;

var weakMapBasicDetection = isCallable$d(WeakMap$1) && /native code/.test(String(WeakMap$1));

var shared$2 = shared$4.exports;
var uid$1 = uid$3;

var keys$1 = shared$2('keys');

var sharedKey$3 = function (key) {
  return keys$1[key] || (keys$1[key] = uid$1(key));
};

var hiddenKeys$4 = {};

var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$a = global$i;
var isObject$9 = isObject$e;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$8 = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$3 = hiddenKeys$4;

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$2 = global$a.TypeError;
var WeakMap = global$a.WeakMap;
var set$1, get$1, has;

var enforce = function (it) {
  return has(it) ? get$1(it) : set$1(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$9(it) || (state = get$1(it)).type !== TYPE) {
      throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');
    }return state;
  };
};

if (NATIVE_WEAK_MAP || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set$1 = function (it, metadata) {
    if (store.has(it)) throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get$1 = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey$2('state');
  hiddenKeys$3[STATE] = true;
  set$1 = function (it, metadata) {
    if (hasOwn$8(it, STATE)) throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$5(it, STATE, metadata);
    return metadata;
  };
  get$1 = function (it) {
    return hasOwn$8(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$8(it, STATE);
  };
}

var internalState = {
  set: set$1,
  get: get$1,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var uncurryThis$f = functionUncurryThis;
var fails$d = fails$k;
var isCallable$c = isCallable$k;
var hasOwn$7 = hasOwnProperty_1;
var DESCRIPTORS$5 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$1 = inspectSource$2;
var InternalStateModule$4 = internalState;

var enforceInternalState$2 = InternalStateModule$4.enforce;
var getInternalState$5 = InternalStateModule$4.get;
var $String$2 = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty$3 = Object.defineProperty;
var stringSlice$4 = uncurryThis$f(''.slice);
var replace$2 = uncurryThis$f(''.replace);
var join$2 = uncurryThis$f([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS$5 && !fails$d(function () {
  return defineProperty$3(function () {/* empty */}, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {
  if (stringSlice$4($String$2(name), 0, 7) === 'Symbol(') {
    name = '[' + replace$2($String$2(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn$7(value, 'name') || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    if (DESCRIPTORS$5) defineProperty$3(value, 'name', { value: name, configurable: true });else
    value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, 'arity') && value.length !== options.arity) {
    defineProperty$3(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn$7(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS$5) defineProperty$3(value, 'prototype', { writable: false });
      // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) {/* empty */}
  var state = enforceInternalState$2(value);
  if (!hasOwn$7(state, 'source')) {
    state.source = join$2(TEMPLATE, typeof name == 'string' ? name : '');
  }return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn$1(function toString() {
  return isCallable$c(this) && getInternalState$5(this).source || inspectSource$1(this);
}, 'toString');

var isCallable$b = isCallable$k;
var definePropertyModule$5 = objectDefineProperty;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;

var defineBuiltIn$7 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable$b(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;else
    defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];else
      if (O[key]) simple = true;
    } catch (error) {/* empty */}
    if (simple) O[key] = value;else
    definePropertyModule$5.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  }return O;
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor$3 = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor$3 : ceil)(n);
};

var trunc = mathTrunc;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
var toIntegerOrInfinity$7 = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

var toIntegerOrInfinity$6 = toIntegerOrInfinity$7;

var max$2 = Math.max;
var min$2 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$3 = function (index, length) {
  var integer = toIntegerOrInfinity$6(index);
  return integer < 0 ? max$2(integer + length, 0) : min$2(integer, length);
};

var toIntegerOrInfinity$5 = toIntegerOrInfinity$7;

var min$1 = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength$6 = function (argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$5(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength$5 = toLength$6;

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
var lengthOfArrayLike$5 = function (obj) {
  return toLength$5(obj.length);
};

var toIndexedObject$2 = toIndexedObject$4;
var toAbsoluteIndex$2 = toAbsoluteIndex$3;
var lengthOfArrayLike$4 = lengthOfArrayLike$5;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$2 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$2($this);
    var length = lengthOfArrayLike$4(O);
    var index = toAbsoluteIndex$2(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$2(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$2(false)
};

var uncurryThis$e = functionUncurryThis;
var hasOwn$6 = hasOwnProperty_1;
var toIndexedObject$1 = toIndexedObject$4;
var indexOf$2 = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;

var push$2 = uncurryThis$e([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$1(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O, key) && push$2(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {
    ~indexOf$2(result, key) || push$2(result, key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys$3 = [
'constructor',
'hasOwnProperty',
'isPrototypeOf',
'propertyIsEnumerable',
'toLocaleString',
'toString',
'valueOf'];


var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;

var hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$1);
};

var objectGetOwnPropertySymbols = {};

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$4 = getBuiltIn$6;
var uncurryThis$d = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$a = anObject$c;

var concat$1 = uncurryThis$d([].concat);

// all object keys, includes non-enumerable and symbols
var ownKeys$1 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject$a(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
};

var hasOwn$5 = hasOwnProperty_1;
var ownKeys = ownKeys$1;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var definePropertyModule$4 = objectDefineProperty;

var copyConstructorProperties$1 = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule$4.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

var fails$c = fails$k;
var isCallable$a = isCallable$k;

var replacement = /#|\.prototype\./;

var isForced$1 = function (feature, detection) {
  var value = data[normalize$1(feature)];
  return value == POLYFILL ? true :
  value == NATIVE ? false :
  isCallable$a(detection) ? fails$c(detection) :
  !!detection;
};

var normalize$1 = isForced$1.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = 'N';
var POLYFILL = isForced$1.POLYFILL = 'P';

var isForced_1 = isForced$1;

var global$9 = global$i;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var defineBuiltIn$6 = defineBuiltIn$7;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$9;
  } else if (STATIC) {
    target = global$9[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$9[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$4(sourceProperty, 'sham', true);
    }
    defineBuiltIn$6(target, key, sourceProperty, options);
  }
};

var global$8 = global$i;

var promiseNativeConstructor = global$8.Promise;

var wellKnownSymbol$e = wellKnownSymbol$g;

var TO_STRING_TAG$3 = wellKnownSymbol$e('toStringTag');
var test = {};

test[TO_STRING_TAG$3] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$9 = isCallable$k;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$d = wellKnownSymbol$g;

var TO_STRING_TAG$2 = wellKnownSymbol$d('toStringTag');
var $Object$1 = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw$1(function () {return arguments;}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {/* empty */}
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$a = TO_STRING_TAG_SUPPORT ? classofRaw$1 : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag
  // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw$1(O)
  // ES3 arguments fallback
  : (result = classofRaw$1(O)) == 'Object' && isCallable$9(O.callee) ? 'Arguments' : result;
};

var uncurryThis$c = functionUncurryThis;
var fails$b = fails$k;
var isCallable$8 = isCallable$k;
var classof$9 = classof$a;
var getBuiltIn$3 = getBuiltIn$6;
var inspectSource = inspectSource$2;

var noop$2 = function () {/* empty */};
var empty = [];
var construct = getBuiltIn$3('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$1 = uncurryThis$c(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$2);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$8(argument)) return false;
  try {
    construct(noop$2, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$8(argument)) return false;
  switch (classof$9(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction':return false;}

  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
var isConstructor$2 = !construct || fails$b(function () {
  var called;
  return isConstructorModern(isConstructorModern.call) ||
  !isConstructorModern(Object) ||
  !isConstructorModern(function () {called = true;}) ||
  called;
}) ? isConstructorLegacy : isConstructorModern;

var isConstructor$1 = isConstructor$2;
var tryToString$2 = tryToString$4;

var $TypeError$7 = TypeError;

// `Assert: IsConstructor(argument) is true`
var aConstructor$2 = function (argument) {
  if (isConstructor$1(argument)) return argument;
  throw $TypeError$7(tryToString$2(argument) + ' is not a constructor');
};

var anObject$9 = anObject$c;
var aConstructor$1 = aConstructor$2;
var isNullOrUndefined$3 = isNullOrUndefined$6;
var wellKnownSymbol$c = wellKnownSymbol$g;

var SPECIES$3 = wellKnownSymbol$c('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
var speciesConstructor$2 = function (O, defaultConstructor) {
  var C = anObject$9(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined$3(S = anObject$9(C)[SPECIES$3]) ? defaultConstructor : aConstructor$1(S);
};

var newPromiseCapability$1 = {};

var aCallable$2 = aCallable$4;

var $TypeError$6 = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw $TypeError$6('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable$2(resolve);
  this.reject = aCallable$2(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
newPromiseCapability$1.f = function (C) {
  return new PromiseCapability(C);
};

var anObject$8 = anObject$c;
var isObject$8 = isObject$e;
var newPromiseCapability = newPromiseCapability$1;

var promiseResolve$1 = function (C, x) {
  anObject$8(C);
  if (isObject$8(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var $$3 = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails$a = fails$k;
var getBuiltIn$2 = getBuiltIn$6;
var isCallable$7 = isCallable$k;
var speciesConstructor$1 = speciesConstructor$2;
var promiseResolve = promiseResolve$1;
var defineBuiltIn$5 = defineBuiltIn$7;

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromiseConstructor && fails$a(function () {
  // eslint-disable-next-line unicorn/no-thenable -- required for testing
  NativePromisePrototype['finally'].call({ then: function () {/* empty */} }, function () {/* empty */});
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$$3({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor$1(this, getBuiltIn$2('Promise'));
    var isFunction = isCallable$7(onFinally);
    return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {return x;});
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {throw e;});
    } : onFinally);

  }
});

// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (isCallable$7(NativePromiseConstructor)) {
  var method = getBuiltIn$2('Promise').prototype['finally'];
  if (NativePromisePrototype['finally'] !== method) {
    defineBuiltIn$5(NativePromisePrototype, 'finally', method, { unsafe: true });
  }
}

var classofRaw = classofRaw$2;
var uncurryThis$b = functionUncurryThis;

var functionUncurryThisClause = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis$b(fn);
};

var objectDefineProperties = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
var objectKeys$1 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};

var DESCRIPTORS$4 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$7 = anObject$c;
var toIndexedObject = toIndexedObject$4;
var objectKeys = objectKeys$1;

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
objectDefineProperties.f = DESCRIPTORS$4 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$7(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule$3.f(O, key = keys[index++], props[key]);
  return O;
};

var getBuiltIn$1 = getBuiltIn$6;

var html$1 = getBuiltIn$1('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */

var anObject$6 = anObject$c;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html = html$1;
var documentCreateElement = documentCreateElement$1;
var sharedKey$1 = sharedKey$3;

var GT = '>';
var LT = '<';
var PROTOTYPE$1 = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$1('IE_PROTO');

var EmptyConstructor = function () {/* empty */};

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) {/* ignore */}
  NullProtoObject = typeof document != 'undefined' ?
  document.domain && activeXDocument ?
  NullProtoObjectViaActiveX(activeXDocument) // old IE
  : NullProtoObjectViaIFrame() :
  NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$6(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

var fails$9 = fails$k;

var correctPrototypeGetter = !fails$9(function () {
  function F() {/* empty */}
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var hasOwn$4 = hasOwnProperty_1;
var isCallable$6 = isCallable$k;
var toObject$4 = toObject$6;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype$2 = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject$4(O);
  if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$6(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }return object instanceof $Object ? ObjectPrototype$2 : null;
};

var fails$8 = fails$k;
var isCallable$5 = isCallable$k;
var isObject$7 = isObject$e;
var getPrototypeOf$2 = objectGetPrototypeOf;
var defineBuiltIn$4 = defineBuiltIn$7;
var wellKnownSymbol$b = wellKnownSymbol$g;

var ITERATOR$3 = wellKnownSymbol$b('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else
  {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$2(getPrototypeOf$2(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject$7(IteratorPrototype$1) || fails$8(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype$1[ITERATOR$3].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable$5(IteratorPrototype$1[ITERATOR$3])) {
  defineBuiltIn$4(IteratorPrototype$1, ITERATOR$3, function () {
    return this;
  });
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

var defineProperty$2 = objectDefineProperty.f;
var hasOwn$3 = hasOwnProperty_1;
var wellKnownSymbol$a = wellKnownSymbol$g;

var TO_STRING_TAG$1 = wellKnownSymbol$a('toStringTag');

var setToStringTag$2 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$3(target, TO_STRING_TAG$1)) {
    defineProperty$2(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
  }
};

var iterators = {};

var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;
var setToStringTag$1 = setToStringTag$2;
var Iterators$2 = iterators;

var returnThis = function () {return this;};

var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$2(IteratorPrototype, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });
  setToStringTag$1(IteratorConstructor, TO_STRING_TAG, false);
  Iterators$2[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
var createIterResultObject$1 = function (value, done) {
  return { value: value, done: done };
};

var classof$8 = classof$a;

var $String$1 = String;

var toString$4 = function (argument) {
  if (classof$8(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String$1(argument);
};

var isObject$6 = isObject$e;
var classof$7 = classofRaw$2;
var wellKnownSymbol$9 = wellKnownSymbol$g;

var MATCH = wellKnownSymbol$9('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
var isRegexp = function (it) {
  var isRegExp;
  return isObject$6(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof$7(it) == 'RegExp');
};

var anObject$5 = anObject$c;

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags$1 = function () {
  var that = anObject$5(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};

var call$8 = functionCall;
var hasOwn$2 = hasOwnProperty_1;
var isPrototypeOf$3 = objectIsPrototypeOf;
var regExpFlags = regexpFlags$1;

var RegExpPrototype$3 = RegExp.prototype;

var regexpGetFlags = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype$3) && !hasOwn$2(R, 'flags') && isPrototypeOf$3(RegExpPrototype$3, R) ?
  call$8(regExpFlags, R) : flags;
};

var uncurryThis$a = functionUncurryThis;
var toIntegerOrInfinity$4 = toIntegerOrInfinity$7;
var toString$3 = toString$4;
var requireObjectCoercible$2 = requireObjectCoercible$5;

var charAt$3 = uncurryThis$a(''.charAt);
var charCodeAt = uncurryThis$a(''.charCodeAt);
var stringSlice$3 = uncurryThis$a(''.slice);

var createMethod$1 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$3(requireObjectCoercible$2($this));
    var position = toIntegerOrInfinity$4(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size ||
    (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ?
    CONVERT_TO_STRING ?
    charAt$3(S, position) :
    first :
    CONVERT_TO_STRING ?
    stringSlice$3(S, position, position + 2) :
    (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$1(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$1(true)
};

var charAt$2 = stringMultibyte.charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
var advanceStringIndex$2 = function (S, index, unicode) {
  return index + (unicode ? charAt$2(S, index).length : 1);
};

var fails$7 = fails$k;
var global$7 = global$i;

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp$2 = global$7.RegExp;

var UNSUPPORTED_Y$1 = fails$7(function () {
  var re = $RegExp$2('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y$1 || fails$7(function () {
  return !$RegExp$2('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y$1 || fails$7(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp$2('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

var regexpStickyHelpers = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$1
};

var fails$6 = fails$k;
var global$6 = global$i;

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp$1 = global$6.RegExp;

var regexpUnsupportedDotAll = fails$6(function () {
  var re = $RegExp$1('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});

var fails$5 = fails$k;
var global$5 = global$i;

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global$5.RegExp;

var regexpUnsupportedNcg = fails$5(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
  'b'.replace(re, '$<a>c') !== 'bc';
});

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call$7 = functionCall;
var uncurryThis$9 = functionUncurryThis;
var toString$2 = toString$4;
var regexpFlags = regexpFlags$1;
var stickyHelpers = regexpStickyHelpers;
var shared = shared$4.exports;
var create$1 = objectCreate;
var getInternalState$4 = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$1 = uncurryThis$9(''.charAt);
var indexOf$1 = uncurryThis$9(''.indexOf);
var replace$1 = uncurryThis$9(''.replace);
var stringSlice$2 = uncurryThis$9(''.slice);

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call$7(nativeExec, re1, 'a');
  call$7(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState$4(re);
    var str = toString$2(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call$7(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call$7(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace$1(flags, 'y', '');
      if (indexOf$1(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice$2(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$1(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call$7(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice$2(match.input, charsAdded);
        match[0] = stringSlice$2(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call$7(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create$1(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

var regexpExec$2 = patchedExec;

var call$6 = functionCall;
var anObject$4 = anObject$c;
var isCallable$4 = isCallable$k;
var classof$6 = classofRaw$2;
var regexpExec$1 = regexpExec$2;

var $TypeError$5 = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
var regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (isCallable$4(exec)) {
    var result = call$6(exec, R, S);
    if (result !== null) anObject$4(result);
    return result;
  }
  if (classof$6(R) === 'RegExp') return call$6(regexpExec$1, R, S);
  throw $TypeError$5('RegExp#exec called on incompatible receiver');
};

/* eslint-disable es/no-string-prototype-matchall -- safe */
var $$2 = _export;
var call$5 = functionCall;
var uncurryThis$8 = functionUncurryThisClause;
var createIteratorConstructor = iteratorCreateConstructor;
var createIterResultObject = createIterResultObject$1;
var requireObjectCoercible$1 = requireObjectCoercible$5;
var toLength$4 = toLength$6;
var toString$1 = toString$4;
var anObject$3 = anObject$c;
var isNullOrUndefined$2 = isNullOrUndefined$6;
var classof$5 = classofRaw$2;
var isRegExp$1 = isRegexp;
var getRegExpFlags = regexpGetFlags;
var getMethod$2 = getMethod$4;
var defineBuiltIn$3 = defineBuiltIn$7;
var fails$4 = fails$k;
var wellKnownSymbol$8 = wellKnownSymbol$g;
var speciesConstructor = speciesConstructor$2;
var advanceStringIndex$1 = advanceStringIndex$2;
var regExpExec$1 = regexpExecAbstract;
var InternalStateModule$3 = internalState;
var IS_PURE = isPure;

var MATCH_ALL = wellKnownSymbol$8('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState$2 = InternalStateModule$3.set;
var getInternalState$3 = InternalStateModule$3.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype$2 = RegExp.prototype;
var $TypeError$4 = TypeError;
var stringIndexOf$1 = uncurryThis$8(''.indexOf);
var nativeMatchAll = uncurryThis$8(''.matchAll);

var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails$4(function () {
  nativeMatchAll('a', /./);
});

var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
  setInternalState$2(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp: regexp,
    string: string,
    global: $global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next() {
  var state = getInternalState$3(this);
  if (state.done) return createIterResultObject(undefined, true);
  var R = state.regexp;
  var S = state.string;
  var match = regExpExec$1(R, S);
  if (match === null) {
    state.done = true;
    return createIterResultObject(undefined, true);
  }
  if (state.global) {
    if (toString$1(match[0]) === '') R.lastIndex = advanceStringIndex$1(S, toLength$4(R.lastIndex), state.unicode);
    return createIterResultObject(match, false);
  }
  state.done = true;
  return createIterResultObject(match, false);
});

var $matchAll = function (string) {
  var R = anObject$3(this);
  var S = toString$1(string);
  var C = speciesConstructor(R, RegExp);
  var flags = toString$1(getRegExpFlags(R));
  var matcher, $global, fullUnicode;
  matcher = new C(C === RegExp ? R.source : R, flags);
  $global = !!~stringIndexOf$1(flags, 'g');
  fullUnicode = !!~stringIndexOf$1(flags, 'u');
  matcher.lastIndex = toLength$4(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
};

// `String.prototype.matchAll` method
// https://tc39.es/ecma262/#sec-string.prototype.matchall
$$2({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible$1(this);
    var flags, S, matcher, rx;
    if (!isNullOrUndefined$2(regexp)) {
      if (isRegExp$1(regexp)) {
        flags = toString$1(requireObjectCoercible$1(getRegExpFlags(regexp)));
        if (!~stringIndexOf$1(flags, 'g')) throw $TypeError$4('`.matchAll` does not allow non-global regexes');
      }
      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
      matcher = getMethod$2(regexp, MATCH_ALL);
      if (matcher === undefined && IS_PURE && classof$5(regexp) == 'RegExp') matcher = $matchAll;
      if (matcher) return call$5(matcher, regexp, O);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
    S = toString$1(O);
    rx = new RegExp(regexp, 'g');
    return rx[MATCH_ALL](S);
  }
});

MATCH_ALL in RegExpPrototype$2 || defineBuiltIn$3(RegExpPrototype$2, MATCH_ALL, $matchAll);

var NATIVE_BIND$1 = functionBindNative;

var FunctionPrototype = Function.prototype;
var apply$1 = FunctionPrototype.apply;
var call$4 = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$4.bind(apply$1) : function () {
  return call$4.apply(apply$1, arguments);
});

var $$1 = _export;
var exec = regexpExec$2;

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$$1({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});

// TODO: Remove from `core-js@4` since it's moved to entry points

var uncurryThis$7 = functionUncurryThisClause;
var defineBuiltIn$2 = defineBuiltIn$7;
var regexpExec = regexpExec$2;
var fails$3 = fails$k;
var wellKnownSymbol$7 = wellKnownSymbol$g;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

var SPECIES$2 = wellKnownSymbol$7('species');
var RegExpPrototype$1 = RegExp.prototype;

var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol$7(KEY);

  var DELEGATES_TO_SYMBOL = !fails$3(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () {return 7;};
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$3(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES$2] = function () {return re;};
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {execCalled = true;return null;};

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
  !DELEGATES_TO_SYMBOL ||
  !DELEGATES_TO_EXEC ||
  FORCED)
  {
    var uncurriedNativeRegExpMethod = uncurryThis$7(/./[SYMBOL]);
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$7(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype$1.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn$2(String.prototype, KEY, methods[0]);
    defineBuiltIn$2(RegExpPrototype$1, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty$3(RegExpPrototype$1[SYMBOL], 'sham', true);
};

var uncurryThis$6 = functionUncurryThis;
var toObject$3 = toObject$6;

var floor$2 = Math.floor;
var charAt = uncurryThis$6(''.charAt);
var replace = uncurryThis$6(''.replace);
var stringSlice$1 = uncurryThis$6(''.slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
var getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject$3(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$':return '$';
      case '&':return matched;
      case '`':return stringSlice$1(str, 0, position);
      case "'":return stringSlice$1(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice$1(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor$2(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];}

    return capture === undefined ? '' : capture;
  });
};

var apply = functionApply;
var call$3 = functionCall;
var uncurryThis$5 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var fails$2 = fails$k;
var anObject$2 = anObject$c;
var isCallable$3 = isCallable$k;
var isNullOrUndefined$1 = isNullOrUndefined$6;
var toIntegerOrInfinity$3 = toIntegerOrInfinity$7;
var toLength$3 = toLength$6;
var toString = toString$4;
var requireObjectCoercible = requireObjectCoercible$5;
var advanceStringIndex = advanceStringIndex$2;
var getMethod$1 = getMethod$4;
var getSubstitution = getSubstitution$1;
var regExpExec = regexpExecAbstract;
var wellKnownSymbol$6 = wellKnownSymbol$g;

var REPLACE = wellKnownSymbol$6('replace');
var max$1 = Math.max;
var min = Math.min;
var concat = uncurryThis$5([].concat);
var push$1 = uncurryThis$5([].push);
var stringIndexOf = uncurryThis$5(''.indexOf);
var stringSlice = uncurryThis$5(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
}();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
}();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$2(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
  // `String.prototype.replace` method
  // https://tc39.es/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = isNullOrUndefined$1(searchValue) ? undefined : getMethod$1(searchValue, REPLACE);
    return replacer ?
    call$3(replacer, searchValue, O, replaceValue) :
    call$3(nativeReplace, toString(O), searchValue, replaceValue);
  },
  // `RegExp.prototype[@@replace]` method
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  function (string, replaceValue) {
    var rx = anObject$2(this);
    var S = toString(string);

    if (
    typeof replaceValue == 'string' &&
    stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
    stringIndexOf(replaceValue, '$<') === -1)
    {
      var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
      if (res.done) return res.value;
    }

    var functionalReplace = isCallable$3(replaceValue);
    if (!functionalReplace) replaceValue = toString(replaceValue);

    var global = rx.global;
    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }
    var results = [];
    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;

      push$1(results, result);
      if (!global) break;

      var matchStr = toString(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength$3(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;
    for (var i = 0; i < results.length; i++) {
      result = results[i];

      var matched = toString(result[0]);
      var position = max$1(min(toIntegerOrInfinity$3(result.index), S.length), 0);
      var captures = [];
      // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
      for (var j = 1; j < result.length; j++) push$1(captures, maybeToString(result[j]));
      var namedCaptures = result.groups;
      if (functionalReplace) {
        var replacerArgs = concat([matched], captures, position, S);
        if (namedCaptures !== undefined) push$1(replacerArgs, namedCaptures);
        var replacement = toString(apply(replaceValue, undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }
      if (position >= nextSourcePosition) {
        accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }
    return accumulatedResult + stringSlice(S, nextSourcePosition);
  }];

}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

var typedArrayConstructor = { exports: {} };

var wellKnownSymbol$5 = wellKnownSymbol$g;

var ITERATOR$2 = wellKnownSymbol$5('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () {throw 2;});
} catch (error) {/* empty */}

var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) {/* empty */}
  return ITERATION_SUPPORT;
};

// eslint-disable-next-line es/no-typed-arrays -- safe
var arrayBufferBasicDetection = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

var isCallable$2 = isCallable$k;

var $String = String;
var $TypeError$3 = TypeError;

var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$2(argument)) return argument;
  throw $TypeError$3("Can't set " + $String(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */

var uncurryThis$4 = functionUncurryThis;
var anObject$1 = anObject$c;
var aPossiblePrototype = aPossiblePrototype$1;

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis$4(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {/* empty */}
  return function setPrototypeOf(O, proto) {
    anObject$1(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);else
    O.__proto__ = proto;
    return O;
  };
}() : undefined);

var NATIVE_ARRAY_BUFFER$1 = arrayBufferBasicDetection;
var DESCRIPTORS$3 = descriptors;
var global$4 = global$i;
var isCallable$1 = isCallable$k;
var isObject$5 = isObject$e;
var hasOwn$1 = hasOwnProperty_1;
var classof$4 = classof$a;
var tryToString$1 = tryToString$4;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var defineBuiltIn$1 = defineBuiltIn$7;
var defineProperty$1 = objectDefineProperty.f;
var isPrototypeOf$2 = objectIsPrototypeOf;
var getPrototypeOf$1 = objectGetPrototypeOf;
var setPrototypeOf$3 = objectSetPrototypeOf;
var wellKnownSymbol$4 = wellKnownSymbol$g;
var uid = uid$3;
var InternalStateModule$2 = internalState;

var enforceInternalState$1 = InternalStateModule$2.enforce;
var getInternalState$2 = InternalStateModule$2.get;
var Int8Array$2 = global$4.Int8Array;
var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
var Uint8ClampedArray$1 = global$4.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
var TypedArray$1 = Int8Array$2 && getPrototypeOf$1(Int8Array$2);
var TypedArrayPrototype$3 = Int8ArrayPrototype && getPrototypeOf$1(Int8ArrayPrototype);
var ObjectPrototype$1 = Object.prototype;
var TypeError$1 = global$4.TypeError;

var TO_STRING_TAG = wellKnownSymbol$4('toStringTag');
var TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$4(global$4.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject$5(it)) return false;
  var klass = classof$4(it);
  return klass === 'DataView' ||
  hasOwn$1(TypedArrayConstructorsList, klass) ||
  hasOwn$1(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf$1(it);
  if (!isObject$5(proto)) return;
  var state = getInternalState$2(proto);
  return state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray$2 = function (it) {
  if (!isObject$5(it)) return false;
  var klass = classof$4(it);
  return hasOwn$1(TypedArrayConstructorsList, klass) ||
  hasOwn$1(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray$2(it)) return it;
  throw TypeError$1('Target is not a typed array');
};

var aTypedArrayConstructor$3 = function (C) {
  if (isCallable$1(C) && (!setPrototypeOf$3 || isPrototypeOf$2(TypedArray$1, C))) return C;
  throw TypeError$1(tryToString$1(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS$3) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global$4[ARRAY];
    if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) {/* empty */}
    }
  }
  if (!TypedArrayPrototype$3[KEY] || forced) {
    defineBuiltIn$1(TypedArrayPrototype$3, KEY, forced ? property :
    NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod$2 = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS$3) return;
  if (setPrototypeOf$3) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global$4[ARRAY];
      if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) {/* empty */}
    }
    if (!TypedArray$1[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn$1(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);
      } catch (error) {/* empty */}
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global$4[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn$1(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global$4[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;else
  NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global$4[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$1(TypedArray$1) || TypedArray$1 === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray$1 = function TypedArray() {
    throw TypeError$1('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
    if (global$4[NAME]) setPrototypeOf$3(global$4[NAME], TypedArray$1);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$3 || TypedArrayPrototype$3 === ObjectPrototype$1) {
  TypedArrayPrototype$3 = TypedArray$1.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
    if (global$4[NAME]) setPrototypeOf$3(global$4[NAME].prototype, TypedArrayPrototype$3);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$3) {
  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$3);
}

if (DESCRIPTORS$3 && !hasOwn$1(TypedArrayPrototype$3, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineProperty$1(TypedArrayPrototype$3, TO_STRING_TAG, { get: function () {
      return isObject$5(this) ? this[TYPED_ARRAY_TAG$1] : undefined;
    } });
  for (NAME in TypedArrayConstructorsList) if (global$4[NAME]) {
    createNonEnumerableProperty$2(global$4[NAME], TYPED_ARRAY_TAG$1, NAME);
  }
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor$3,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$2,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray$2,
  TypedArray: TypedArray$1,
  TypedArrayPrototype: TypedArrayPrototype$3
};

/* eslint-disable no-new -- required for testing */

var global$3 = global$i;
var fails$1 = fails$k;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer$2 = global$3.ArrayBuffer;
var Int8Array$1 = global$3.Int8Array;

var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$1(function () {
  Int8Array$1(1);
}) || !fails$1(function () {
  new Int8Array$1(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array$1();
  new Int8Array$1(null);
  new Int8Array$1(1.5);
  new Int8Array$1(iterable);
}, true) || fails$1(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array$1(new ArrayBuffer$2(2), 1, undefined).length !== 1;
});

var defineBuiltIn = defineBuiltIn$7;

var defineBuiltIns$1 = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};

var isPrototypeOf$1 = objectIsPrototypeOf;

var $TypeError$2 = TypeError;

var anInstance$2 = function (it, Prototype) {
  if (isPrototypeOf$1(Prototype, it)) return it;
  throw $TypeError$2('Incorrect invocation');
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$7;
var toLength$2 = toLength$6;

var $RangeError$2 = RangeError;

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
var toIndex$2 = function (it) {
  if (it === undefined) return 0;
  var number = toIntegerOrInfinity$2(it);
  var length = toLength$2(number);
  if (number !== length) throw $RangeError$2('Wrong length or index');
  return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
var $Array$2 = Array;
var abs = Math.abs;
var pow = Math.pow;
var floor$1 = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = $Array$2(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$1(log(number) / LN2);
    c = pow(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
  pack: pack,
  unpack: unpack
};

var toObject$2 = toObject$6;
var toAbsoluteIndex$1 = toAbsoluteIndex$3;
var lengthOfArrayLike$3 = lengthOfArrayLike$5;

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
var arrayFill$1 = function fill(value /* , start = 0, end = @length */) {
  var O = toObject$2(this);
  var length = lengthOfArrayLike$3(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex$1(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex$1(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;

var createProperty$1 = function (object, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object) definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$1(0, value));else
  object[propertyKey] = value;
};

var toAbsoluteIndex = toAbsoluteIndex$3;
var lengthOfArrayLike$2 = lengthOfArrayLike$5;
var createProperty = createProperty$1;

var $Array$1 = Array;
var max = Math.max;

var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$2(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array$1(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};

var global$2 = global$i;
var uncurryThis$3 = functionUncurryThis;
var DESCRIPTORS$2 = descriptors;
var NATIVE_ARRAY_BUFFER = arrayBufferBasicDetection;
var FunctionName = functionName;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var defineBuiltIns = defineBuiltIns$1;
var fails = fails$k;
var anInstance$1 = anInstance$2;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$7;
var toLength$1 = toLength$6;
var toIndex$1 = toIndex$2;
var IEEE754 = ieee754;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf$2 = objectSetPrototypeOf;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var defineProperty = objectDefineProperty.f;
var arrayFill = arrayFill$1;
var arraySlice = arraySliceSimple;
var setToStringTag = setToStringTag$2;
var InternalStateModule$1 = internalState;

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var getInternalState$1 = InternalStateModule$1.get;
var setInternalState$1 = InternalStateModule$1.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH$1 = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global$2[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
var $DataView = global$2[DATA_VIEW];
var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var Array$1 = global$2.Array;
var RangeError$2 = global$2.RangeError;
var fill = uncurryThis$3(arrayFill);
var reverse = uncurryThis$3([].reverse);

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter$1 = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () {return getInternalState$1(this)[key];} });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex$1(index);
  var store = getInternalState$1(view);
  if (intIndex + count > store.byteLength) throw RangeError$2(WRONG_INDEX);
  var bytes = getInternalState$1(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = arraySlice(bytes, start, start + count);
  return isLittleEndian ? pack : reverse(pack);
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex$1(index);
  var store = getInternalState$1(view);
  if (intIndex + count > store.byteLength) throw RangeError$2(WRONG_INDEX);
  var bytes = getInternalState$1(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance$1(this, ArrayBufferPrototype$1);
    var byteLength = toIndex$1(length);
    setInternalState$1(this, {
      bytes: fill(Array$1(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS$2) this.byteLength = byteLength;
  };

  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance$1(this, DataViewPrototype);
    anInstance$1(buffer, ArrayBufferPrototype$1);
    var bufferLength = getInternalState$1(buffer).byteLength;
    var offset = toIntegerOrInfinity$1(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$2('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength$1(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$2(WRONG_LENGTH$1);
    setInternalState$1(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS$2) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  DataViewPrototype = $DataView[PROTOTYPE];

  if (DESCRIPTORS$2) {
    addGetter$1($ArrayBuffer, 'byteLength');
    addGetter$1($DataView, 'buffer');
    addGetter$1($DataView, 'byteLength');
    addGetter$1($DataView, 'byteOffset');
  }

  defineBuiltIns(DataViewPrototype, {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.length != 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
  })) {
    /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance$1(this, ArrayBufferPrototype$1);
      return new NativeArrayBuffer(toIndex$1(length));
    };

    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;

    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty$1($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }

    ArrayBufferPrototype$1.constructor = $ArrayBuffer;
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
    createNonEnumerableProperty$1(NativeArrayBuffer, 'name', ARRAY_BUFFER);
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf$2(DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = uncurryThis$3(DataViewPrototype.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

var isObject$4 = isObject$e;

var floor = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
var isIntegralNumber$1 = Number.isInteger || function isInteger(it) {
  return !isObject$4(it) && isFinite(it) && floor(it) === it;
};

var toIntegerOrInfinity = toIntegerOrInfinity$7;

var $RangeError$1 = RangeError;

var toPositiveInteger$1 = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw $RangeError$1("The argument can't be less than 0");
  return result;
};

var toPositiveInteger = toPositiveInteger$1;

var $RangeError = RangeError;

var toOffset$1 = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError('Wrong offset');
  return offset;
};

var uncurryThis$2 = functionUncurryThisClause;
var aCallable$1 = aCallable$4;
var NATIVE_BIND = functionBindNative;

var bind$2 = uncurryThis$2(uncurryThis$2.bind);

// optional / simple context binding
var functionBindContext = function (fn, that) {
  aCallable$1(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind$2(fn, that) : function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var classof$3 = classof$a;
var getMethod = getMethod$4;
var isNullOrUndefined = isNullOrUndefined$6;
var Iterators$1 = iterators;
var wellKnownSymbol$3 = wellKnownSymbol$g;

var ITERATOR$1 = wellKnownSymbol$3('iterator');

var getIteratorMethod$2 = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR$1) ||
  getMethod(it, '@@iterator') ||
  Iterators$1[classof$3(it)];
};

var call$2 = functionCall;
var aCallable = aCallable$4;
var anObject = anObject$c;
var tryToString = tryToString$4;
var getIteratorMethod$1 = getIteratorMethod$2;

var $TypeError$1 = TypeError;

var getIterator$1 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call$2(iteratorMethod, argument));
  throw $TypeError$1(tryToString(argument) + ' is not iterable');
};

var wellKnownSymbol$2 = wellKnownSymbol$g;
var Iterators = iterators;

var ITERATOR = wellKnownSymbol$2('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$1 = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

var classof$2 = classof$a;

var isBigIntArray$1 = function (it) {
  var klass = classof$2(it);
  return klass == 'BigInt64Array' || klass == 'BigUint64Array';
};

var toPrimitive = toPrimitive$2;

var $TypeError = TypeError;

// `ToBigInt` abstract operation
// https://tc39.es/ecma262/#sec-tobigint
var toBigInt$1 = function (argument) {
  var prim = toPrimitive(argument, 'number');
  if (typeof prim == 'number') throw $TypeError("Can't convert number to bigint");
  // eslint-disable-next-line es/no-bigint -- safe
  return BigInt(prim);
};

var bind$1 = functionBindContext;
var call$1 = functionCall;
var aConstructor = aConstructor$2;
var toObject$1 = toObject$6;
var lengthOfArrayLike$1 = lengthOfArrayLike$5;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$2;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var isBigIntArray = isBigIntArray$1;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var toBigInt = toBigInt$1;

var typedArrayFrom$2 = function from(source /* , mapfn, thisArg */) {
  var C = aConstructor(this);
  var O = toObject$1(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, thisIsBigIntArray, value, step, iterator, next;
  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    O = [];
    while (!(step = call$1(next, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind$1(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike$1(O);
  result = new (aTypedArrayConstructor$2(C))(length);
  thisIsBigIntArray = isBigIntArray(result);
  for (i = 0; length > i; i++) {
    value = mapping ? mapfn(O[i], i) : O[i];
    // FF30- typed arrays doesn't properly convert objects to typed array values
    result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
  }
  return result;
};

var classof$1 = classofRaw$2;

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray$1 = Array.isArray || function isArray(argument) {
  return classof$1(argument) == 'Array';
};

var isArray = isArray$1;
var isConstructor = isConstructor$2;
var isObject$3 = isObject$e;
var wellKnownSymbol$1 = wellKnownSymbol$g;

var SPECIES$1 = wellKnownSymbol$1('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesConstructor$1 = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;else
    if (isObject$3(C)) {
      C = C[SPECIES$1];
      if (C === null) C = undefined;
    }
  }return C === undefined ? $Array : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1;

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate$1 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind = functionBindContext;
var uncurryThis$1 = functionUncurryThis;
var IndexedObject = indexedObject;
var toObject = toObject$6;
var lengthOfArrayLike = lengthOfArrayLike$5;
var arraySpeciesCreate = arraySpeciesCreate$1;

var push = uncurryThis$1([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
            case 3:return true; // some
            case 5:return value; // find
            case 6:return index; // findIndex
            case 2:push(target, value); // filter
          } else switch (TYPE) {
            case 4:return false; // every
            case 7:push(target, value); // filterReject
          }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};

var getBuiltIn = getBuiltIn$6;
var definePropertyModule$1 = objectDefineProperty;
var wellKnownSymbol = wellKnownSymbol$g;
var DESCRIPTORS$1 = descriptors;

var SPECIES = wellKnownSymbol('species');

var setSpecies$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule$1.f;

  if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () {return this;}
    });
  }
};

var isCallable = isCallable$k;
var isObject$2 = isObject$e;
var setPrototypeOf$1 = objectSetPrototypeOf;

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired$1 = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
  // it can work only with native `setPrototypeOf`
  setPrototypeOf$1 &&
  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  isCallable(NewTarget = dummy.constructor) &&
  NewTarget !== Wrapper &&
  isObject$2(NewTargetPrototype = NewTarget.prototype) &&
  NewTargetPrototype !== Wrapper.prototype)
  setPrototypeOf$1($this, NewTargetPrototype);
  return $this;
};

var $ = _export;
var global$1 = global$i;
var call = functionCall;
var DESCRIPTORS = descriptors;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2 = typedArrayConstructorsRequireWrappers;
var ArrayBufferViewCore$1 = arrayBufferViewCore;
var ArrayBufferModule = arrayBuffer;
var anInstance = anInstance$2;
var createPropertyDescriptor = createPropertyDescriptor$5;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var isIntegralNumber = isIntegralNumber$1;
var toLength = toLength$6;
var toIndex = toIndex$2;
var toOffset = toOffset$1;
var toPropertyKey = toPropertyKey$4;
var hasOwn = hasOwnProperty_1;
var classof = classof$a;
var isObject$1 = isObject$e;
var isSymbol = isSymbol$3;
var create = objectCreate;
var isPrototypeOf = objectIsPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var typedArrayFrom$1 = typedArrayFrom$2;
var forEach = arrayIteration.forEach;
var setSpecies = setSpecies$1;
var definePropertyModule = objectDefineProperty;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var InternalStateModule = internalState;
var inheritIfRequired = inheritIfRequired$1;

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var enforceInternalState = InternalStateModule.enforce;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError$1 = global$1.RangeError;
var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer$1.prototype;
var DataView$1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$1.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore$1.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore$1.TypedArray;
var TypedArrayPrototype$2 = ArrayBufferViewCore$1.TypedArrayPrototype;
var aTypedArrayConstructor$1 = ArrayBufferViewCore$1.aTypedArrayConstructor;
var isTypedArray$1 = ArrayBufferViewCore$1.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  aTypedArrayConstructor$1(C);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
      return getInternalState(this)[key];
    } });
};

var isArrayBuffer$1 = function (it) {
  var klass;
  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray$1(target) &&
  !isSymbol(key) &&
  key in target &&
  isIntegralNumber(+key) &&
  key >= 0;
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  key = toPropertyKey(key);
  return isTypedArrayIndex(target, key) ?
  createPropertyDescriptor(2, target[key]) :
  nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  key = toPropertyKey(key);
  if (isTypedArrayIndex(target, key) &&
  isObject$1(descriptor) &&
  hasOwn(descriptor, 'value') &&
  !hasOwn(descriptor, 'get') &&
  !hasOwn(descriptor, 'set')
  // TODO: add validation descriptor w/o calling accessors
  && !descriptor.configurable && (
  !hasOwn(descriptor, 'writable') || descriptor.writable) && (
  !hasOwn(descriptor, 'enumerable') || descriptor.enumerable))
  {
    target[key] = descriptor.value;
    return target;
  }return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype$2, 'buffer');
    addGetter(TypedArrayPrototype$2, 'byteOffset');
    addGetter(TypedArrayPrototype$2, 'byteLength');
    addGetter(TypedArrayPrototype$2, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global$1[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject$1(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer$1(byteLength);
        } else if (isArrayBuffer$1(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError$1(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError$1(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError$1(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray$1(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return call(typedArrayFrom$1, TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView$1(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype$2);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired(function () {
          if (!isObject$1(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer$1(data)) return $length !== undefined ?
          new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) :
          typedArrayOffset !== undefined ?
          new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) :
          new NativeTypedArrayConstructor(data);
          if (isTypedArray$1(data)) return fromList(TypedArrayConstructor, data);
          return call(typedArrayFrom$1, TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else typedArrayConstructor.exports = function () {/* empty */};

var createTypedArrayConstructor$8 = typedArrayConstructor.exports;

// `Float32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$8('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$7 = typedArrayConstructor.exports;

// `Float64Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$7('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$6 = typedArrayConstructor.exports;

// `Int8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$6('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$5 = typedArrayConstructor.exports;

// `Int16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$5('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$4 = typedArrayConstructor.exports;

// `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$4('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$3 = typedArrayConstructor.exports;

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$3('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$2 = typedArrayConstructor.exports;

// `Uint8ClampedArray` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$2('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

var createTypedArrayConstructor$1 = typedArrayConstructor.exports;

// `Uint16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$1('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor = typedArrayConstructor.exports;

// `Uint32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;
var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;
var typedArrayFrom = typedArrayFrom$2;

// `%TypedArray%.from` method
// https://tc39.es/ecma262/#sec-%typedarray%.from
exportTypedArrayStaticMethod$1('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);

var ArrayBufferViewCore = arrayBufferViewCore;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;

var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;

// `%TypedArray%.of` method
// https://tc39.es/ecma262/#sec-%typedarray%.of
exportTypedArrayStaticMethod('of', function of() /* ...items */{
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* eslint-disable quote-props */
/* globals OS_ANDROID, OS_IOS */

// Add global constants.
Object.defineProperties(commonjsGlobal, {
  'OS_ANDROID': {
    value: false,
    writable: false
  },
  'OS_IOS': {
    value: true,
    writable: false
  },
  OS_VERSION_MAJOR: {
    value: Ti.Platform.versionMajor,
    writable: false
  },
  OS_VERSION_MINOR: {
    value: Ti.Platform.versionMinor,
    writable: false
  },
  OS_VERSION_PATCH: {
    value: Ti.Platform.versionPatch,
    writable: false
  }
});

// Copyright Node.js contributors. All rights reserved.
const kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
const isBuffer = Symbol.for('titanium.buffer.isBuffer');
const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

function removeColors(str) {
  return str.replace(colorRegExp, '');
}
function isError(e) {
  // An error could be an instance of Error while not being a native error
  // or could be from a different realm and not be instance of Error but still
  // be a native error.
  return isNativeError(e) || e instanceof Error;
}
let getStructuredStack;
class StackTraceError extends Error {}
StackTraceError.prepareStackTrace = (err, trace) => trace;
StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = () => new StackTraceError().stack;
  }
  let stack = getStructuredStack();

  // stack is only an array on v8, try to convert manually if string
  if (typeof stack === 'string') {
    const stackFrames = [];
    const lines = stack.split(/\n/);
    for (const line of lines) {
      const lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);
      if (lineInfo) {
        const filename = lineInfo[2].replace('file://', '');
        stackFrames.push({
          getFileName: () => filename
        });
      }
    }
    stack = stackFrames;
  }

  // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:
  if (Array.isArray(stack)) {
    for (const frame of stack) {
      const filename = frame.getFileName();
      // If a filename does not start with / or contain \,
      // it's likely from Node.js core.
      if (!/^\/|\\/.test(filename)) {
        continue;
      }
      return kNodeModulesRE.test(filename);
    }
  }
  return false;
}
function join$1(output, separator) {
  let str = '';
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      // It is faster not to use a template string here
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function uncurryThis(f) {
  return function () {
    return f.call.apply(f, arguments);
  };
}
const ALL_PROPERTIES$2 = 0;
const ONLY_ENUMERABLE$2 = 2;
const propertyFilter = {
  ALL_PROPERTIES: ALL_PROPERTIES$2,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2
};
function getOwnNonIndexProperties(obj, filter) {
  const props = [];
  const keys = filter === ONLY_ENUMERABLE$2 ? Object.keys(obj) : Object.getOwnPropertyNames(obj);
  for (var i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!isAllDigits(key)) {
      props.push(key);
    }
  }
  return props;
}
function isAllDigits(s) {
  if (s.length === 0) {
    return false;
  }
  for (var i = 0; i < s.length; ++i) {
    const code = s.charCodeAt(i);
    if (code < 48 || code > 57) {
      return false;
    }
  }
  return true;
}

// Copyright Node.js contributors. All rights reserved.
const TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, Symbol.toStringTag).get);
function isObject(value) {
  return typeof value === 'object';
}
function isFunction(value) {
  return typeof value === 'function';
}
function checkPrototype(value, name) {
  return Object.prototype.toString.call(value) === `[object ${name}]`;
}
function isAnyArrayBuffer(value) {
  if (isArrayBuffer(value)) {
    return true;
  }
  return isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
  return isObject(value) && checkPrototype(value, 'Arguments');
}
function isArrayBuffer(value) {
  return isObject(value) && checkPrototype(value, 'ArrayBuffer');
}

// Cached to make sure no userland code can tamper with it.
const isArrayBufferView = ArrayBuffer.isView;
function isAsyncFunction(value) {
  return isFunction(value) && checkPrototype(value, 'AsyncFunction');
}
function isBigInt64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
}
function isBooleanObject(value) {
  return isObject(value) && checkPrototype(value, 'Boolean');
}
function isBoxedPrimitive(value) {
  if (!isObject(value)) {
    return false;
  }
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value)
  // || isBigIntObject(value)
  || isSymbolObject(value);
}
function isDataView(value) {
  return isObject(value) && checkPrototype(value, 'DataView');
}
function isDate(value) {
  return isObject(value) && checkPrototype(value, 'Date');
}

// @todo isExternal

function isFloat32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float32Array';
}
function isFloat64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float64Array';
}
function isGeneratorFunction(value) {
  return isFunction(value) && checkPrototype(value, 'GeneratorFunction');
}
function isGeneratorObject(value) {
  return isObject(value) && checkPrototype(value, 'Generator');
}
function isInt8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int8Array';
}
function isInt16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int16Array';
}
function isInt32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int32Array';
}
function isMap(value) {
  return isObject(value) && checkPrototype(value, 'Map');
}
function isMapIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';
}

// @todo isModuleNamespaceObject

function isNativeError(value) {
  // if not an instance of an Error, definitely not a native error
  if (!(value instanceof Error)) {
    return false;
  }
  if (!value || !value.constructor) {
    return false;
  }
  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
}
function isNumberObject(value) {
  return isObject(value) && checkPrototype(value, 'Number');
}
function isPromise(value) {
  return isObject(value) && checkPrototype(value, 'Promise');
}

// @todo isProxy

function isRegExp(value) {
  return isObject(value) && checkPrototype(value, 'RegExp');
}
function isSet(value) {
  return isObject(value) && checkPrototype(value, 'Set');
}
function isSetIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';
}
function isSharedArrayBuffer(value) {
  if (!global.SharedArrayBuffer) {
    return false;
  }
  return isObject(value) && checkPrototype(value, 'SharedArrayBuffer');
}
function isStringObject(value) {
  return isObject(value) && checkPrototype(value, 'String');
}
function isSymbolObject(value) {
  return isObject(value) && checkPrototype(value, 'Symbol');
}
function isTypedArray(value) {
  const isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;
  if (isBuiltInTypedArray) {
    return true;
  }
  return value[isBuffer] === true;
}
function isUint8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
}
function isUint16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint16Array';
}
function isUint32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint32Array';
}
function isWeakMap(value) {
  return isObject(value) && checkPrototype(value, 'WeakMap');
}
function isWeakSet(value) {
  return isObject(value) && checkPrototype(value, 'WeakSet');
}

// @todo isWebAssemblyCompiledModule

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAnyArrayBuffer: isAnyArrayBuffer,
  isArgumentsObject: isArgumentsObject,
  isArrayBuffer: isArrayBuffer,
  isArrayBufferView: isArrayBufferView,
  isAsyncFunction: isAsyncFunction,
  isBigInt64Array: isBigInt64Array,
  isBigUint64Array: isBigUint64Array,
  isBooleanObject: isBooleanObject,
  isBoxedPrimitive: isBoxedPrimitive,
  isDataView: isDataView,
  isDate: isDate,
  isFloat32Array: isFloat32Array,
  isFloat64Array: isFloat64Array,
  isGeneratorFunction: isGeneratorFunction,
  isGeneratorObject: isGeneratorObject,
  isInt8Array: isInt8Array,
  isInt16Array: isInt16Array,
  isInt32Array: isInt32Array,
  isMap: isMap,
  isMapIterator: isMapIterator,
  isNativeError: isNativeError,
  isNumberObject: isNumberObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isSet: isSet,
  isSetIterator: isSetIterator,
  isSharedArrayBuffer: isSharedArrayBuffer,
  isStringObject: isStringObject,
  isSymbolObject: isSymbolObject,
  isTypedArray: isTypedArray,
  isUint8Array: isUint8Array,
  isUint8ClampedArray: isUint8ClampedArray,
  isUint16Array: isUint16Array,
  isUint32Array: isUint32Array,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet
});

// Copyright Node.js contributors. All rights reserved.
let error;
function lazyError() {
  if (!error) {
    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;
    error = codes.ERR_INTERNAL_ASSERTION;
  }
  return error;
}
function assert$1(value, message) {
  if (!value) {
    const ERR_INTERNAL_ASSERTION = lazyError();
    throw new ERR_INTERNAL_ASSERTION(message);
  }
}
function fail(message) {
  const ERR_INTERNAL_ASSERTION = lazyError();
  throw new ERR_INTERNAL_ASSERTION(message);
}
assert$1.fail = fail;

// Copyright Node.js contributors. All rights reserved.
const messages = new Map();
const codes = {};

// @todo implement this once needed
class SystemError extends Error {}

// Utility function for registering the error codes.
function E(sym, val, def) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, val);
  if (def === SystemError) {
    throw new Error('Node compatible SystemError not yet implemented.');
  } else {
    def = makeNodeErrorWithCode(def, sym);
  }
  for (var _len = arguments.length, otherClasses = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    otherClasses[_key - 3] = arguments[_key];
  }
  if (otherClasses.length !== 0) {
    otherClasses.forEach((clazz) => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }
  codes[sym] = def;
}
function makeNodeErrorWithCode(Base, key) {
  return class NodeError extends Base {
    constructor() {
      super();
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const message = getMessage(key, args, this);
      Object.defineProperty(this, 'message', {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      });
      addCodeToName(this, super.name, key);
    }
    get code() {
      return key;
    }
    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    }
    toString() {
      return `${this.name} [${key}]: ${this.message}`;
    }
  };
}
function getMessage(key, args, self) {
  const msg = messages.get(key);

  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (assert === undefined) {
  	assert = require('./internal/assert');
  }
  */

  if (typeof msg === 'function') {
    assert$1(msg.length <= args.length,
    // Default options do not count.
    `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${msg.length}).`);
    return msg.apply(self, args);
  }
  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  assert$1(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);
  if (args.length === 0) {
    return msg;
  }
  args.unshift(msg);
  return format$1.apply(null, args);
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  // return lazyInternalUtilInspect().format.apply(null, args);
}

function addCodeToName(err, name, code) {
  // Add the error code to the name to include it in the stack trace.
  err.name = `${name} [${code}]`;
  // Access the stack to generate the error message including the error code
  // from the name.
  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.
  // should we try to make errors behave the same across platforms?
  // eslint-disable-next-line no-unused-expressions
  err.stack;
  // Reset the name to the actual name.
  if (name === 'SystemError') {
    Object.defineProperty(err, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true
    });
  } else {
    delete err.name;
  }
}
E('ERR_BUFFER_OUT_OF_BOUNDS',
// Using a default argument here is important so the argument is not counted
// towards `Function#length`.
function () {
  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  if (name) {
    return `"${name}" is outside of buffer bounds`;
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INTERNAL_ASSERTION', (message) => {
  const suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\n' + 'Please open an issue with this stack trace at ' + 'https://github.com/tidev/titanium-sdk/issues\n';
  return message === undefined ? suffix : `${message}\n${suffix}`;
}, Error);
E('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert$1(typeof name === 'string', '\'name\' must be a string');

  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && expected.startsWith('not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  let msg;
  if (name.endsWith(' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = name.includes('.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
let maxStack_ErrorName;
let maxStack_ErrorMessage;
/**
 * Returns true if `err.name` and `err.message` are equal to engine-specific
 * values indicating max call stack size has been exceeded.
 * "Maximum call stack size exceeded" in V8.
 *
 * @param {Error} err The error to check
 * @returns {boolean}
 */
function isStackOverflowError(err) {
  if (maxStack_ErrorMessage === undefined) {
    try {
      function overflowStack() {
        overflowStack();
      }
      overflowStack();
    } catch (e) {
      maxStack_ErrorMessage = e.message;
      maxStack_ErrorName = e.name;
    }
  }
  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}
function oneOf(expected, thing) {
  assert$1(typeof thing === 'string', '`thing` has to be of type string');
  if (Array.isArray(expected)) {
    const len = expected.length;
    assert$1(len > 0, 'At least one expected value needs to be specified');
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class FastBuffer extends Uint8Array {}

/**
 * loop over input, every 2 characters, parse as an int
 * basically each two characters are a "byte" or an 8-bit uint
 * we append them all together to form a single buffer holding all the values
 * @param {string} value string we're encoding in hex
 * @returns {integer[]} array of encoded bytes
 */
function stringToHexBytes(value) {
  const length = value.length / 2;
  const byteArray = [];
  for (let i = 0; i < length; i++) {
    const numericValue = parseInt(value.substr(i * 2, 2), 16);
    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }
  return byteArray;
}

// Use a Proxy to hack array style index accessors
const arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);
      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    } else if (propKey === isBuffer) {
      return true;
    }
    return Reflect.get(target, propKey, receiver);
  },
  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);
      if (Number.isSafeInteger(num)) {
        setAdjustedIndex(target, num, value);
        return true;
      }
    }
    return Reflect.set(target, propKey, value, receiver);
  },
  has(target, key) {
    if (typeof key === 'string') {
      const num = Number(key);
      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }
    return key in target;
  }
};

// This is a special Buffer that wraps Ti.Buffer
// as a result it is *much* slower to read/write values
// because we need to go across the JS/Native boundary per-byte!
// We also need to use a Proxy to handle intercepting set/get of indices to redirect to the underlying Ti.Buffer
class SlowBuffer {
  /**
   * Constructs a new buffer.
   *
   * Primarily used internally in this module together with `newBuffer` to
   * create a new Buffer instance wrapping a Ti.Buffer.
   *
   * Also supports the deprecated Buffer() constructors which are safe
   * to use outside of this module.
   *
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   */
  constructor(tiBuffer) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : tiBuffer.length - start;
    Object.defineProperties(this, {
      byteOffset: {
        value: start
      },
      length: {
        value: length
      },
      _tiBuffer: {
        value: tiBuffer
      }
    });
  }

  /**
   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   * @returns {Buffer} wrapped inside a Proxy
   */
  static fromTiBuffer(tiBuffer, start, length) {
    return new Proxy(new SlowBuffer(tiBuffer, start, length), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
  }

  static fromString(value, encoding) {
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
    encoding = encoding.toLowerCase();
    if (encoding === 'base64') {
      const blob = Ti.Utils.base64decode(value);
      const blobStream = Ti.Stream.createStream({
        source: blob,
        mode: Ti.Stream.MODE_READ
      });
      const buffer = Ti.Stream.readAll(blobStream);
      blobStream.close();
      return SlowBuffer.fromTiBuffer(buffer);
    }
    if (encoding === 'hex') {
      const bytes = stringToHexBytes(value);
      const length = bytes.length;
      const tiBuffer = Ti.createBuffer({
        length
      });
      for (let i = 0; i < length; i++) {
        tiBuffer[i] = bytes[i] & 0xFF; // mask to one byte
      }

      return SlowBuffer.fromTiBuffer(tiBuffer);
    }
    const tiBuffer = Ti.createBuffer({
      value: value,
      type: getTiCodecCharset(encoding)
    });
    return SlowBuffer.fromTiBuffer(tiBuffer);
  }

  // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer
  get buffer() {
    // Get the slice of the array from byteOffset to length
    return Uint8Array.from(this).buffer;
  }
  _slice(offset, length) {
    return SlowBuffer.fromTiBuffer(this._tiBuffer, offset, length);
  }
  _fill(value, offset, end, encoding) {
    const valueType = typeof value;
    if (valueType === 'string') {
      const bufToFillWith = SlowBuffer.fromString(value, encoding);
      const fillBufLength = bufToFillWith.length;
      if (fillBufLength === 0) {
        throw new Error('no valid fill data');
      }
      // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);
      if (fillBufLength === 1) {
        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);
        return this;
      }

      // multiple byte fill!
      const length = end - offset;
      for (let i = 0; i < length; i++) {
        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
        const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
        this._tiBuffer[i + offset] = fillChar;
      }
      return this;
    }

    // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();
    this._tiBuffer.fill(value, offset, end);
  }
  getAdjustedIndex(index) {
    return getAdjustedIndex(this, index);
  }
  setAdjustedIndex(index, value) {
    return setAdjustedIndex(this, index, value);
  }

  // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer
  set(src) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const numBytes = src.length;
    // check src.length + offset doesn't go beyond our length!
    // FIXME: Re-enable
    // checkOffset(this, offset, numBytes);
    // copy src values into this buffer starting at offset
    for (let i = 0; i < numBytes; i++) {
      setAdjustedIndex(this, i + offset, src[i]);
    }
  }

  /**
   * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
   * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
   */
  toTiBuffer() {
    if (this.length === this._tiBuffer.length && this.byteOffset === 0) {
      return this._tiBuffer;
    }
    return this._tiBuffer.clone(this.byteOffset, this.length);
  }
}
function getAdjustedIndex(buf, index) {
  if (index < 0) {
    return undefined;
  }
  // Wrapping Ti.Buffer?
  if (buf._tiBuffer) {
    if (index >= buf._tiBuffer.length) {
      return undefined;
    }
    return buf._tiBuffer[index + buf.byteOffset];
  }
  // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?
  return buf[index];
}
function setAdjustedIndex(buf, index, value) {
  if (index < 0) {
    return;
  }
  // Wrapping Ti.Buffer?
  if (buf._tiBuffer) {
    if (index < buf._tiBuffer.length) {
      buf._tiBuffer[index + buf.byteOffset] = value;
    }
    return;
  }
  // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?
  buf[index] = value;
}

// https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings
const TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII);
/**
 * @param {string} encoding desired encoding name
 * @returns {integer} Ti.Codec constant that maps to the encoding
 */
function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

/**
 * This implementation of Buffer uses a Ti.Buffer internally to back it.
 * This is likley an order of magnitude slower than using a variant that extends Uint8Array!
 * I think if we're not already wrapping a Ti.Buffer, it may be better to have two implementations
 * and, like browserify, just extend Uint8Array for any Buffers we need to read/write a lot
 * and then add a simple conversion method to turn it into a Ti.Buffer when needed.
 *
 * The Ti.Buffer impl has to go through the binding layer for reading/writing every byte.
 * If we anticipate the Buffer staying on the JS side, I'm willing to bet that the Uint8Array
 * the JS engine provides would be *way* faster.
 *
 * Also note that both Ti.Buffer and Node's Buffer were created before the JS engines had typed arrays
 * (and Uint8Array in particular) as a means of encapsulating a byte array. We should consider accepting
 * a Uint8Array in any of our APIs that take a Ti.Buffer and eventually deprecating/removing Ti.Buffer.
 */
const {
  ALL_PROPERTIES: ALL_PROPERTIES$1,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1
} = propertyFilter;
const VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le'];

// Used to cheat for read/writes of doubles
const doubleArray = new Float64Array(1);
const uint8DoubleArray = new Uint8Array(doubleArray.buffer);

// Used to cheat to read/write floats
const floatArray = new Float32Array(1);
const uint8FloatArray = new Uint8Array(floatArray.buffer);

// Node.js does some very weird stuff here
FastBuffer.prototype.constructor = Buffer$1; // new FastBuffer() calls Buffer function?
Buffer$1.prototype = FastBuffer.prototype; // Then it hijacks Buffer's prototype to point at FastBuffer's?!
// Does this effectively mean Buffer extends Uint8Array, because FastBuffer did? This fails for me
// How the hell can we make it happy? We really want to extend Uint8Array if we can
// addBufferPrototypeMethods(Buffer.prototype); // Here's where it hangs some of the methods

Buffer$1.poolSize = 8192;

/**
 * Constructs a new buffer.
 *
 * Primarily used internally in this module together with `newBuffer` to
 * create a new Buffer instance wrapping a Ti.Buffer.
 *
 * Also supports the deprecated Buffer() constructors which are safe
 * to use outside of this module.
 *
 * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg the underlying data/bytes
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */
function Buffer$1(arg, encodingOrOffset, length) {
  if (arg === undefined) {
    return;
  }
  if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
    showFlaggedDeprecation();
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(`The "string" argument must be of type "string". Received type ${typeof arg}`);
      }
      return Buffer$1.alloc(arg);
    }
    return Buffer$1.from(arg, encodingOrOffset, length);
  }

  // The slow case - we're wrapping a Ti.Buffer
  return SlowBuffer.fromTiBuffer(arg, encodingOrOffset, length);
}

/**
 * @param {integer[]|Buffer|string} value value we're wrapping
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */
Buffer$1.from = function (value, encodingOrOffset, length) {
  const valueType = typeof value;
  if (valueType === 'string') {
    return fromString(value, encodingOrOffset);
  } else if (valueType === 'object') {
    if (isAnyArrayBuffer(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (Array.isArray(value) || value instanceof Uint8Array) {
      return fromArray(value);
    }
    if (Buffer$1.isBuffer(value)) {
      return fromBuffer(value);
    }
    // We want to limit the use of SlowBuffers to only when we're wrapping a Ti.Buffer, hopefully!
    if (value.apiName && value.apiName === 'Ti.Buffer') {
      return SlowBuffer.fromTiBuffer(value);
    }
  }
  throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
};

/**
 * @param {ArrayBuffer} obj ArrayBuffer to wrap
 * @param {number} [byteOffset=0] byte offste to begin
 * @param {number} [length] length to wrap
 * @returns {Buffer}
 */
function fromArrayBuffer(obj, byteOffset, length) {
  // Convert byteOffset to integer
  if (byteOffset === undefined) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('offset');
  }
  if (length === undefined) {
    length = maxLength;
  } else {
    // Convert length to non-negative integer.
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('length');
      }
    } else {
      length = 0;
    }
  }
  return new FastBuffer(obj, byteOffset, length);
}

/**
 * @param {string} value value to wrap
 * @param {string} [encoding='utf8'] character encoding
 * @returns {Buffer}
 */
function fromString(value) {
  let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError(`Unknown encoding: ${encoding}`);
  }
  encoding = encoding.toLowerCase();
  if (encoding === 'base64') {
    const blob = Ti.Utils.base64decode(value);
    return new FastBuffer(blob.toArrayBuffer());
  }
  if (encoding === 'hex') {
    return fromArray(stringToHexBytes(value));
  }
  // Convert the SlowBuffer to a fast buffer by just copying bytes recursively here
  return fromBuffer(SlowBuffer.fromString(value, encoding));
}

/**
 * @param {integer[]|Uint8Array|array} value values to wrap
 * @returns {Buffer}
 */
function fromArray(value) {
  const length = value.length;
  if (length === 0) {
    return new FastBuffer();
  }
  return new FastBuffer(value);
}

/**
 * Ideally this should only be used when we're copying a SlowBuffer into a new FastBuffer
 * @param {Buffer} value buffer to copy
 * @returns {Buffer}
 */
function fromBuffer(value) {
  const length = value.length;
  if (length === 0) {
    return new FastBuffer();
  }
  const buffer = Buffer$1.allocUnsafe(length);
  value.copy(buffer, 0, 0, length);
  return buffer;
}
Object.setPrototypeOf(Buffer$1, Uint8Array); // What is this doing?! Making Buffer.prototype point at Uint8Array now

/**
 * 0 is returned if target is the same as buf
 * 1 is returned if target should come before buf when sorted.
 * -1 is returned if target should come after buf when sorted.
 * @param {Buffer} target Buffer to compare against
 * @param {integer} [targetStart=0] index to start in target
 * @param {integer} [targetEnd=target.length] index to end in target
 * @param {integer} [sourceStart=0] index to start in this Buffer
 * @param {integer} [sourceEnd=this.length] index to end in this Buffer
 * @returns {integer}
 */
Buffer$1.prototype.compare = function (target, targetStart, targetEnd, sourceStart, sourceEnd) {
  if (!Buffer$1.isBuffer(target)) {
    throw new TypeError(`The "target" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }
  if (targetStart === undefined) {
    targetStart = 0;
  }
  if (sourceStart === undefined) {
    sourceStart = 0;
  }
  if (targetEnd === undefined) {
    targetEnd = target.length;
  }
  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }

  // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength
  if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
    throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
  }

  // Use slices to make the loop easier
  const source = this.slice(sourceStart, sourceEnd);
  const sourceLength = source.length;
  const dest = target.slice(targetStart, targetEnd);
  const destLength = dest.length;
  const length = Math.min(sourceLength, destLength);
  for (let i = 0; i < length; i++) {
    const targetValue = dest.getAdjustedIndex(i);
    const sourceValue = source.getAdjustedIndex(i);
    if (targetValue !== sourceValue) {
      // No match! Return 1 or -1 based on what is greater!
      if (sourceValue < targetValue) {
        return -1;
      }
      return 1;
    }
  }

  // sort based on length!
  if (sourceLength < destLength) {
    return -1;
  }
  if (sourceLength > destLength) {
    return 1;
  }
  return 0;
};

/**
 * Copies from this to target
 * @param {Buffer} target destination we're copying into
 * @param {integer} [targetStart=0] start index to copy into in destination Buffer
 * @param {integer} [sourceStart=0] start index to copy from within `this`
 * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
 * @returns {integer} number of bytes copied
 */
Buffer$1.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {
  if (targetStart === undefined) {
    targetStart = 0;
  }
  if (sourceStart === undefined) {
    sourceStart = 0;
  }
  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }
  if (sourceStart === sourceEnd) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  // TODO: check for out of bounds?
  let length = sourceEnd - sourceStart;
  // Cap length to remaining bytes in target!
  const remaining = target.length - targetStart;
  if (length > remaining) {
    sourceEnd = sourceStart + remaining;
    length = remaining;
  }
  // Determine actual number of bytes we'll copy, constrain by source buffer length as well as target (above)
  let numBytes = length;
  const sourceLen = this.length - sourceStart;
  if (numBytes > sourceLen) {
    numBytes = sourceLen;
  }

  // TODO: handle overlap when target === this!
  // TODO: Do we need to take target byteOffset into account here?
  let source = this;
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(this.buffer, this.byteOffset + sourceStart, numBytes);
  }
  target.set(source, targetStart);
  return numBytes;
};

/**
 * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
 * @returns {Iterator}
 */
// TODO: Is this only necessary for SlowBuffer?
Buffer$1.prototype.entries = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const entryIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: [nextIndex, buffer.getAdjustedIndex(nextIndex)],
          done: false
        };
        nextIndex++;
        return result;
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
  return entryIterator;
};
Buffer$1.prototype.equals = function (otherBuffer) {
  if (!Buffer$1.isBuffer(otherBuffer)) {
    throw new TypeError('argument must be a Buffer');
  }
  if (otherBuffer === this) {
    return true;
  }
  return this.compare(otherBuffer) === 0;
};

/**
 * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
 * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
 * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
 * @returns {this}
 */
Buffer$1.prototype.fill = function (value, offset, end, encoding) {
  const offsetType = typeof offset;
  if (offsetType === 'undefined') {
    // value supplied
    offset = 0;
    end = this.length;
    encoding = 'utf8';
  } else if (offsetType === 'string') {
    // value, encoding supplied
    encoding = offset;
    offset = 0;
    end = this.length;
  } else if (typeof end === 'string') {
    // value, offset, encoding supplied
    encoding = end;
    end = this.length;
  }
  this._fill(value, offset, end, encoding);
  return this;
};
const TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_byteLength = Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteLength').get;
const TypedArrayFill = TypedArrayPrototype.fill;
Buffer$1.prototype._fill = function (value, offset, end, encoding) {
  if (typeof value === 'number') {
    // OOB check
    const byteLen = TypedArrayProto_byteLength.call(this);
    const fillLength = end - offset;
    if (offset > end || fillLength + offset > byteLen) {
      throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    TypedArrayFill.call(this, value, offset, end);
  } else {
    const bufToFillWith = SlowBuffer.fromString(value, encoding);
    const fillBufLength = bufToFillWith.length;
    if (fillBufLength === 0) {
      throw new Error('no valid fill data');
    }
    if (fillBufLength === 1) {
      TypedArrayFill.call(this, bufToFillWith._tiBuffer[0], offset, end);
      return this;
    }

    // multiple byte fill!
    const length = end - offset;
    for (let i = 0; i < length; i++) {
      // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
      const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
      this.setAdjustedIndex(i + offset, fillChar);
    }
  }
};
Buffer$1.prototype.includes = function (value, byteOffset, encoding) {
  return this.indexOf(value, byteOffset, encoding) !== -1;
};

/**
 * @param {string|Buffer|integer} value What to search for
 * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
 * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
 * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
 */
Buffer$1.prototype.indexOf = function (value, byteOffset, encoding) {
  if (this.length === 0) {
    // empty buffer? can't find anything!
    return -1;
  }

  // if byteOffset is undefined, make it 0
  if (typeof byteOffset === 'undefined') {
    byteOffset = 0;
  } else if (typeof byteOffset === 'string') {
    // if it's a string, that's actually encoding
    encoding = byteOffset;
    byteOffset = 0;
  }

  // if we don't have an encoding yet, use utf8
  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }
  if (byteOffset < 0) {
    // convert negative indices
    byteOffset = this.length + byteOffset;
    if (byteOffset < 0) {
      // still negative? start at 0
      byteOffset = 0;
    }
  } else if (byteOffset >= this.length) {
    return -1; // can't find past end of buffer!
  }

  if (typeof value === 'number') {
    value &= 0xFF; // clamp to 255
    // This is a simpler case, we have a single byte we need to search for
    // so just loop through and try to find it
    return indexOf(this, value, byteOffset);
  }

  // coerce a string to a Buffer
  if (typeof value === 'string') {
    value = fromString(value, encoding);
  }

  // value is now a Buffer...
  const matchLength = value.length;
  if (matchLength === 0) {
    return -1; // never find empty value!
  }

  if (matchLength === 1) {
    // simple case, match one byte!
    return indexOf(this, value[0], byteOffset);
  }
  let currentIndex = byteOffset;
  const thisLength = this.length;
  if (matchLength > thisLength) {
    return -1; // can't match if the value is longer than this Buffer!
  }

  // FIXME: Can we rewrite this in a less funky way?
  // FIXME: Can stop earlier based on matchLength!
  firstMatch: while (currentIndex < thisLength) {
    // eslint-disable-line no-labels
    // match first byte!
    let firstByteMatch = indexOf(this, value[0], currentIndex);
    if (firstByteMatch === -1) {
      // couldn't even match the very first byte, so no match overall!
      return -1;
    }

    // ok, we found the first byte, now we need to see if the next consecutive bytes match!
    for (let x = 1; x < matchLength; x++) {
      if (firstByteMatch + x >= thisLength) {
        currentIndex = firstByteMatch + 1; // move past our first match
        continue firstMatch; // eslint-disable-line no-labels
      }

      if (this[firstByteMatch + x] !== value[x]) {
        // didn't match!
        currentIndex = firstByteMatch + 1; // move past our first match
        continue firstMatch; // eslint-disable-line no-labels
      }
    }

    return firstByteMatch; // the rest matched, hurray!
  }

  return -1;
};
Buffer$1.prototype.keys = function () {
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: nextIndex,
          done: false
        };
        nextIndex++;
        return result;
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
  return myIterator;
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readDoubleBE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 8);

  // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder
  uint8DoubleArray[7] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[0] = this[offset++];
  return doubleArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readDoubleLE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 8);

  // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder
  uint8DoubleArray[0] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[7] = this[offset++];
  return doubleArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readFloatBE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 4);

  // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder
  uint8FloatArray[3] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[0] = this[offset++];
  return floatArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readFloatLE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 4);

  // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder
  uint8FloatArray[0] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[3] = this[offset++];
  return floatArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.readInt8 = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const unsignedValue = this.readUInt8(offset);
  return unsignedToSigned(unsignedValue, 1);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readInt16BE = function (offset) {
  const unsignedValue = this.readUInt16BE(offset);
  return unsignedToSigned(unsignedValue, 2);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readInt16LE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const unsignedValue = this.readUInt16LE(offset);
  return unsignedToSigned(unsignedValue, 2);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readInt32BE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const unsignedValue = this.readUInt32BE(offset);
  return unsignedToSigned(unsignedValue, 4);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readInt32LE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const unsignedValue = this.readUInt32LE(offset);
  return unsignedToSigned(unsignedValue, 4);
};

/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readIntBE = function (offset, byteLength) {
  const unsignedValue = this.readUIntBE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};

/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readIntLE = function (offset, byteLength) {
  const unsignedValue = this.readUIntLE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt8 = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 1);
  return this[offset];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt16BE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 2);
  // first byte shifted and OR'd with second byte
  return this[offset] << 8 | this[offset + 1];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt16LE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 2);
  // first byte OR'd with second byte shifted
  return this[offset] | this[offset + 1] << 8;
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt32BE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 4);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
  // (because bit-wise operators assume a 32-bit number)
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt32LE = function () {
  let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  checkOffset(this, offset, 4);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
};

/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readUIntBE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  // we're doing the same loop as #readUIntLE, just backwards!
  for (let i = byteLength - 1; i >= 0; i--) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};

/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readUIntLE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  for (let i = 0; i < byteLength; i++) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};

/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */
Buffer$1.prototype.slice = function (start, end) {
  const thisLength = this.length;
  if (typeof start === 'undefined') {
    start = 0;
  } else if (start < 0) {
    start = thisLength + start;
    if (start < 0) {
      // if this is still negative, use 0 (that matches Node)
      start = 0;
    }
  }
  if (typeof end === 'undefined') {
    end = thisLength;
  } else if (end < 0) {
    end = thisLength + end;
  }
  // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.
  if (end > thisLength) {
    end = thisLength;
  }
  // What if end is less than start?
  let length = end - start;
  if (length <= 0) {
    length = 0; // return empty view of Buffer! retain byte offset, set length to 0
  }
  // Wrap the same ArrayBuffer object but specify the start/end to "crop" with
  return this._slice(this.byteOffset + start, length);
};
Buffer$1.prototype._slice = function (offset, length) {
  return new FastBuffer(this.buffer, offset, length);
};

/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */
Buffer$1.prototype.subarray = function (start, end) {
  return this.slice(start, end);
};

/**
 * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
 * @returns {Buffer}
 */
Buffer$1.prototype.swap16 = function () {
  const length = this.length;
  if (length % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (let i = 0; i < length; i += 2) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    this.setAdjustedIndex(i, second);
    this.setAdjustedIndex(i + 1, first);
  }
  return this;
};

/**
 * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
 * @returns {Buffer}
 */
Buffer$1.prototype.swap32 = function () {
  const length = this.length;
  if (length % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (let i = 0; i < length; i += 4) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    this.setAdjustedIndex(i, fourth);
    this.setAdjustedIndex(i + 1, third);
    this.setAdjustedIndex(i + 2, second);
    this.setAdjustedIndex(i + 3, first);
  }
  return this;
};

/**
 * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
 * @returns {Buffer}
 */
Buffer$1.prototype.swap64 = function () {
  const length = this.length;
  if (length % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (let i = 0; i < length; i += 8) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    const fifth = this.getAdjustedIndex(i + 4);
    const sixth = this.getAdjustedIndex(i + 5);
    const seventh = this.getAdjustedIndex(i + 6);
    const eighth = this.getAdjustedIndex(i + 7);
    this.setAdjustedIndex(i, eighth);
    this.setAdjustedIndex(i + 1, seventh);
    this.setAdjustedIndex(i + 2, sixth);
    this.setAdjustedIndex(i + 3, fifth);
    this.setAdjustedIndex(i + 4, fourth);
    this.setAdjustedIndex(i + 5, third);
    this.setAdjustedIndex(i + 6, second);
    this.setAdjustedIndex(i + 7, first);
  }
  return this;
};

/**
 * @returns {object}
 */
Buffer$1.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    // Take advantage of slice working on "Array-like" objects (just like `arguments`)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
    data: [].slice.call(this)
  };
};

/**
 * @param {string} [encoding='utf8'] The character encoding to use
 * @param {integer} [start=0] The byte offset to start decoding at
 * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
 * @returns {string}
 */
Buffer$1.prototype.toString = function (encoding, start, end) {
  // fast case of no args
  if (arguments.length === 0) {
    return this.toTiBuffer().toString();
  }
  const length = this.length;
  if (start >= length) {
    return ''; // start is past end of buffer, return empty string
  }

  if (start < 0 || typeof start !== 'number') {
    start = 0;
  }
  if (end > length || typeof end !== 'number') {
    // no end specified, or past end of buffer, use length of buffer
    end = length;
  } // else keep end as passed in

  if (end <= start) {
    return ''; // if end is before start return empty string
  }

  // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?
  if (start !== 0 || end !== length) {
    return this.slice(start, end).toString(encoding);
  }

  // base case, start is 0, end is length
  if (encoding === undefined) {
    encoding = 'utf8';
  } else {
    encoding = encoding.toLowerCase();
    // Throw if bad encoding!
    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
  }
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return this.toTiBuffer().toString(); // we return utf-8 by default natively
  }

  if (encoding === 'base64') {
    return Ti.Utils.base64encode(this.toTiBuffer().toBlob()).toString();
  }
  if (encoding === 'hex') {
    return this.hexSlice(0, length);
  }
  if (encoding === 'latin1' || encoding === 'binary') {
    let latin1String = '';
    for (let i = 0; i < length; i++) {
      // each one is a "byte"
      latin1String += String.fromCharCode(this.getAdjustedIndex(i));
    }
    return latin1String;
  }
  if (encoding === 'ascii') {
    let ascii = '';
    for (let i = 0; i < length; i++) {
      // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
      ascii += String.fromCharCode(this.getAdjustedIndex(i) & 0x7F);
    }
    return ascii;
  }

  // UCS2/UTF16
  return this.ucs2Slice(0, length);
};
Buffer$1.prototype.getAdjustedIndex = function (index) {
  return this[index];
};
Buffer$1.prototype.setAdjustedIndex = function (index, value) {
  return this[index] = value;
};
Buffer$1.prototype.hexSlice = function (start, end) {
  let hexStr = '';
  for (let i = start; i < end; i++) {
    // each one is a "byte"
    let hex = (this.getAdjustedIndex(i) & 0xff).toString(16);
    hex = hex.length === 1 ? '0' + hex : hex;
    hexStr += hex;
  }
  return hexStr;
};
Buffer$1.prototype.ucs2Slice = function (start, end) {
  let out = '';
  let i = start;
  while (i < end) {
    // utf-16/ucs-2 is 2-bytes per character
    const byte1 = this.getAdjustedIndex(i++);
    const byte2 = this.getAdjustedIndex(i++);
    const code_unit = (byte2 << 8) + byte1; // we mash together the two bytes
    out += String.fromCodePoint(code_unit);
  }
  return out;
};

/**
 * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
 * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
 */
Buffer$1.prototype.toTiBuffer = function () {
  const tiBuffer = Ti.createBuffer({
    length: this.length
  });
  copyBuffer(this, tiBuffer, 0, this.length);
  return tiBuffer;
};

/**
 * @param {Buffer} src source Buffer we're copying from
 * @param {Ti.Buffer} dest destination Ti.Buffer we're copying into
 * @param {integer} offset start offset we're copying to in destination
 * @param {integer} length number of bytes to copy
 * @returns {integer} actual number of bytes copied
 */
function copyBuffer(src, dest, offset, length) {
  const srcLength = src.length;
  const destLength = dest.length;
  let i = 0;
  for (; i < length; i++) {
    const destIndex = i + offset;
    // are we trying to write past end of destination? Or read past end of source? Stop!
    if (destIndex >= destLength || i >= srcLength) {
      break;
    }
    dest[destIndex] = src[i];
  }
  return i;
}

/**
 * Creates and returns an iterator for buf values (bytes)
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?
Buffer$1.prototype.values = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: buffer.getAdjustedIndex(nextIndex),
          done: false
        };
        nextIndex++;
        return result;
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
  return myIterator;
};

/**
 * Called when buffer is used in a for..of loop. Delegates to #values()
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?
Buffer$1.prototype[Symbol.iterator] = function () {
  return this.values();
};

/**
 * Writes string to buf at offset according to the character encoding in encoding.
 * The length parameter is the number of bytes to write. If buf did not contain enough space to
 * fit the entire string, only part of string will be written. However, partially encoded
 * characters will not be written.
 * @param {string} string String to write to `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write string
 * @param {integer} [length=buf.length - offset] Number of bytes to write
 * @param {string} [encoding='utf8'] The character encoding of string
 * @returns {integer}
 */
Buffer$1.prototype.write = function (string, offset, length, encoding) {
  if (typeof offset === 'string') {
    encoding = offset;
    offset = 0;
    length = this.length;
  } else if (typeof length === 'string') {
    encoding = length;
    length = this.length - offset;
  } else {
    // we cap `length` at the length of our buffer
    const remaining = this.length - offset;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = encoding || 'utf8';
  // so we need to convert `remaining` bytes of our string into a byte array/buffer
  const src = fromString(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?

  // then stick that into our buffer starting at `offset`!
  return src.copy(this, offset, 0, length);
};
Buffer$1.prototype.writeDoubleBE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeDoubleLE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeFloatBE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  return offset; // at this point, we should have already added 4 to offset
};

Buffer$1.prototype.writeFloatLE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  return offset; // at this point, we should have already added 4 to offset
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt8 = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 1);
  checkValue(value, -128, 127);
  if (value >= 0) {
    // just write it normally
    this.setAdjustedIndex(offset, value);
  } else {
    // convert from signed to 2's complement bits
    this.setAdjustedIndex(offset, 0xFF + value + 1); // max value, plus the negative number, add one
  }

  return offset + 1;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt16BE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value >>> 8); // just shift over a byte
  this.setAdjustedIndex(offset + 1, value & 0xFF); // mask to first byte

  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt16LE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt32BE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xFF);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt32LE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);
  if (value < 0) {
    value = minMaxBase * 2 + value;
  }
  let multiplier = 1;
  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0x100;
  }
  return offset + byteLength;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);
  if (value < 0) {
    value = minMaxBase * 2 + value;
  }
  let multiplier = 1;
  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }
  return offset + byteLength;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt8 = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 1);
  checkValue(value, 0, 255);
  this.setAdjustedIndex(offset, value);
  return offset + 1;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt16BE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value >>> 8);
  this.setAdjustedIndex(offset + 1, value & 0xff);
  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt16LE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt32BE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xff);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt32LE = function (value) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeUIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;
  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }
  return offset + byteLength;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeUIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;
  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }
  return offset + byteLength;
};

// TODO: Implement remaining instance methods:
// buf.lastIndexOf(value[, byteOffset][, encoding])
// buf.readBigInt64BE([offset])
// buf.readBigInt64LE([offset])
// buf.readBigUInt64BE([offset])
// buf.readBigUInt64LE([offset])
// buf.writeBigInt64BE(value[, offset])
// buf.writeBigInt64LE(value[, offset])
// buf.writeBigUInt64BE(value[, offset])
// buf.writeBigUInt64LE(value[, offset])

// FIXME: We need to minimize using a backing Ti.Buffer whenever possible, because
// going back and forth across the bridge for every byte is *very* expensive
// Ideally we should have a "SlowBuffer" that is used when we explicitly wrap a Ti.Buffer
// So that writes are passed through. Otherwise we should avoid using one at all costs
// i.e. when we do Buffer.concat and are only doing reads - why do we need a Ti.Buffer?
// Can we have Ti.Buffer really just wrap a Uint8Array and add it's own methods?
Buffer$1.allocUnsafe = function (length) {
  return new FastBuffer(length);
};
Buffer$1.allocUnsafeSlow = function (length) {
  return Buffer$1.allocUnsafe(length);
};
Buffer$1.alloc = function (length) {
  let fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';
  const buf = Buffer$1.allocUnsafe(length);
  if (fill !== 0) {
    buf.fill(fill, encoding);
  }
  return buf;
};

/**
 * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
 * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
 * @returns {integer}
 */
Buffer$1.byteLength = function (string) {
  let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';
  if (typeof string !== 'string') {
    if (Buffer$1.isBuffer(string)) {
      return string.length; // return Buffer's length
    }

    return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
  }

  let length = string.length;
  switch (encoding.toLowerCase()) {
    case 'utf8':
    case 'utf-8':
      return utf8ByteLength(string);
    case 'latin1':
    case 'binary':
    case 'ascii':
      return length;
    case 'ucs-2':
    case 'ucs2':
    case 'utf16le':
    case 'utf16-le':
      return 2 * length;
    case 'hex':
      return length / 2;
    case 'base64':
      // Subtract up to two padding chars from end of string!
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }
      return Math.floor(length * 3 / 4);
    // drop fractional value
  }

  return utf8ByteLength(string);
};
Buffer$1.compare = function (buf1, buf2) {
  if (!Buffer$1.isBuffer(buf1)) {
    throw new TypeError(`The "buf1" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }
  // TODO: Wrap UInt8Array args in buffers?
  return buf1.compare(buf2);
};

/**
 * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
 * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
 * @returns {Buffer}
 */
Buffer$1.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new TypeError('list argument must be an Array');
  }
  if (list.length === 0) {
    return new FastBuffer(); // one empty Buffer!
  }
  // allocate one Buffer of `totalLength`? Cap at totalLength?
  if (totalLength === undefined) {
    totalLength = 0;
    // generate the total length from each buffer's length?
    for (let i = 0; i < list.length; i++) {
      totalLength += list[i].length;
    }
  }
  const result = Buffer$1.allocUnsafe(totalLength);
  let position = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(result, position);
    position += buf.length;
    if (position >= totalLength) {
      break;
    }
  }
  return result;
};

/**
 * @param {string} encoding possible encoding name
 * @returns {boolean}
 */
Buffer$1.isEncoding = function (encoding) {
  if (typeof encoding !== 'string') {
    return false;
  }
  return VALID_ENCODINGS.includes(encoding.toLowerCase());
};

/**
 * @param {*} obj possible Buffer instance
 * @returns {boolean}
 */
Buffer$1.isBuffer = function (obj) {
  return obj !== null && obj !== undefined && (obj instanceof Buffer$1 || obj[isBuffer] === true);
};
let INSPECT_MAX_BYTES = 50;
// Override how buffers are presented by util.inspect().
Buffer$1.prototype[customInspectSymbol] = function (recurseTimes, ctx) {
  const max = INSPECT_MAX_BYTES;
  const actualMax = Math.min(max, this.length);
  const remaining = this.length - max;
  let str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }
  // Inspect special properties as well, if possible.
  if (ctx) {
    let extras = false;
    const filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;
    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {
      extras = true;
      obj[key] = this[key];
      return obj;
    }, Object.create(null));
    if (extras) {
      if (this.length !== 0) {
        str += ', ';
      }
      // '[Object: null prototype] {'.length === 26
      // This is guarded with a test.
      str += inspect(obj, {
        ...ctx,
        breakLength: Infinity,
        compact: true
      }).slice(27, -2);
    }
  }
  return `<${this.constructor.name} ${str}>`;
};
Buffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol];

// HACK: ArrayBuffer.isView returns true for Node Buffer, but false for us. Until we can extend Uint8Array, we need to hack this sniffing method
const ArrayBufferIsView = ArrayBuffer.isView;
ArrayBuffer.isView = function (thing) {
  return ArrayBufferIsView(thing) || thing instanceof Buffer$1;
};
Object.setPrototypeOf(SlowBuffer.prototype, Buffer$1.prototype);
Object.setPrototypeOf(SlowBuffer, Buffer$1);
var BufferModule = {
  Buffer: Buffer$1,
  // TODO: Implement transcode()!
  transcode: (_source, _fromEncoding, _toEncoding) => {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799
  }
};

/**
 * Searches a Buffer for the index of a single byte.
 * @param {Buffer} buffer buffer to search
 * @param {integer} singleByte byte we're looking for
 * @param {integer} offset start offset we search at
 * @returns {integer}
 */
function indexOf(buffer, singleByte, offset) {
  const length = buffer.length;
  for (let i = offset; i < length; i++) {
    if (buffer.getAdjustedIndex(i) === singleByte) {
      return i;
    }
  }
  return -1;
}

/**
 * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
 * It's possible we may be able to use them when byteLength < 4 if that's faster.
 *
 * @param {integer} unsignedValue value before converting back to signed
 * @param {integer} byteLength number of bytes
 * @returns {integer} the signed value that is represented by the unsigned value's bytes
 */
function unsignedToSigned(unsignedValue, byteLength) {
  const bitLength = byteLength * 8;
  const maxPositiveValue = Math.pow(2, bitLength - 1);
  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }
  const maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}

/**
 * @param {string} string utf-8 string
 * @returns {integer}
 */
function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  const buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8
  });
  const length = buf.length;
  buf.release(); // release the buffer since we just needed the length
  return length;
}

/**
 * Throws a RangeError if offset is out of bounds
 * @param {Buffer} buffer buffer we're operating on
 * @param {integer} offset user supplied offset
 * @param {integer} byteLength number of bytes needed in range
 * @throws {RangeError}
 */
function checkOffset(buffer, offset, byteLength) {
  const endOffset = buffer.length - byteLength;
  if (offset < 0 || offset > endOffset) {
    throw new RangeError(`The value of "offset" is out of range. It must be >= 0 and <= ${endOffset}. Received ${offset}`);
  }
}

/**
 * @param {integer} value user-supplied value
 * @param {integer} min minimum valid value
 * @param {integer} max maximum valid value
 * @throws {RangeError}
 */
function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError(`The value of "value" is out of range. It must be >= ${min} and <= ${max}. Received ${value}`);
  }
}
let bufferWarningAlreadyEmitted = false;
let nodeModulesCheckCounter = 0;
const bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';
function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }
  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

// Copyright Node.js contributors. All rights reserved.
const {
  ALL_PROPERTIES,
  ONLY_ENUMERABLE
} = propertyFilter;
const BooleanPrototype = Boolean.prototype;
const DatePrototype = Date.prototype;
const ErrorPrototype = Error.prototype;
const NumberPrototype = Number.prototype;
const MapPrototype = Map.prototype;
const RegExpPrototype = RegExp.prototype;
const StringPrototype = String.prototype;
const SetPrototype = Set.prototype;
const SymbolPrototype = Symbol.prototype;
const isIos = ['ipad', 'iphone'].includes(Ti.Platform.osname);
const {
  ERR_INVALID_ARG_TYPE
} = codes;
const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
let hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);
const builtInObjects = new Set(Object.getOwnPropertyNames(global).filter((e) => /^([A-Z][a-z]+)+$/.test(e)));
const inspectDefaultOptions = Object.seal({
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
});
const kObjectType = 0;
const kArrayType = 1;
const kArrayExtrasType = 2;

/* eslint-disable no-control-regex */
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c]/g;
/* eslint-enable no-control-regex */

const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const kMinLineLength = 16;

// Constants to map the iterator state.
const kWeak = 0;
const kIterator = 1;
const kMapEntries = 2;

// Escaped special characters. Use empty strings to fill up unused entries.
/* eslint-disable quotes */
const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
/* eslint-enable quotes */

function getUserOptions(ctx) {
  const obj = {
    stylize: ctx.stylize
  };
  for (const key of Object.keys(inspectDefaultOptions)) {
    obj[key] = ctx[key];
  }
  if (ctx.userOptions === undefined) {
    return obj;
  }
  return {
    ...obj,
    ...ctx.userOptions
  };
}

/**
 * Echos the value of any input. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {any} value The value to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @return {string} The string representation of `value`
 */
function inspect(value, opts) {
  // Default options
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters
  };
  if (arguments.length > 1) {
    // Legacy...
    if (arguments.length > 2) {
      if (arguments[2] !== undefined) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== undefined) {
        ctx.colors = arguments[3];
      }
    }
    // Set user-specified options
    if (typeof opts === 'boolean') {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (const key of optKeys) {
        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
        // this function public or add a new API with a similar or better
        // functionality.
        if (hasOwnProperty(inspectDefaultOptions, key) || key === 'stylize') {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === undefined) {
          // This is required to pass through the actual user input.
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }
  if (ctx.maxArrayLength === null) {
    ctx.maxArrayLength = Infinity;
  }
  return formatValue(ctx, value, 0);
}
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, 'defaultOptions', {
  get() {
    return inspectDefaultOptions;
  },
  set(options) {
    if (options === null || typeof options !== 'object') {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    Object.assign(inspectDefaultOptions, options);
  }
});

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = Object.assign(Object.create(null), {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
});

// Don't use 'blue' not visible on cmd.exe
inspect.styles = Object.assign(Object.create(null), {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  // "name": intentionally not styling
  regexp: 'red',
  module: 'underline'
});
function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
const escapeFn = (str) => meta[str.charCodeAt(0)];

// Escape control characters, single quotes and the backslash.
// This is similar to JSON stringify escaping.
function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39;

  // Check for double quotes. If not present, do not escape single quotes and
  // instead wrap the text in double quotes. If double quotes exist, check for
  // backticks. If they do not exist, use those as fallback instead of the
  // double quotes.
  // eslint-disable-next-line quotes
  if (str.includes("'")) {
    // This invalidates the charCode and therefore can not be matched for
    // anymore.
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes('`') && !str.includes('${')) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  }

  // Some magic numbers that worked out fine while benchmarking with v8 6.0
  if (str.length < 5000 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }
  let result = '';
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style !== undefined) {
    const color = inspect.colors[style];
    return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
  }
  return str;
}
function stylizeNoColor(str) {
  return str;
}

// Return a new empty array to push in the results of the default formatter.
function getEmptyFormatArray() {
  return [];
}
function getConstructorName(obj, _ctx) {
  let firstProto;
  // const tmp = obj;
  while (obj) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value.name;
    }
    obj = Object.getPrototypeOf(obj);
    if (firstProto === undefined) {
      firstProto = obj;
    }
  }
  if (firstProto === null) {
    return null;
  }

  /*
   @todo this calls into native, can we replace this somehow?
  return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {
  	...ctx,
  	customInspect: false
  })}>`;
  */

  return null;
}
function getPrefix(constructor, tag, fallback) {
  if (constructor === null) {
    if (tag !== '') {
      return `[${fallback}: null prototype] [${tag}] `;
    }
    return `[${fallback}: null prototype] `;
  }
  if (tag !== '' && constructor !== tag) {
    return `${constructor} [${tag}] `;
  }
  return `${constructor} `;
}

// Look up the keys of the object.
function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      keys.push(...symbols);
    }
  } else {
    // This might throw if `value` is a Module Namespace Object from an
    // unevaluated module, but we don't want to perform the actual type
    // check because it's expensive.
    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
    // and modify this logic as needed.
    try {
      keys = Object.keys(value);
    } catch (err) {
      // @fixme how to du isModuleNamespaceObject?
      /*
      assert(isNativeError(err) && err.name === 'ReferenceError' &&
      			 isModuleNamespaceObject(value));
      */
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
      keys.push(...symbols.filter((key) => propertyIsEnumerable(value, key)));
    }
  }
  return keys;
}
function getCtxStyle(value, constructor, tag) {
  let fallback = '';
  if (constructor === null) {
    fallback = 'Object';
  }
  return getPrefix(constructor, tag, fallback);
}
function findTypedConstructor(value) {
  for (const [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {
    if (check(value)) {
      return clazz;
    }
  }
}
let lazyNullPrototypeCache;
// Creates a subclass and name
// the constructor as `${clazz} : null prototype`
function clazzWithNullPrototype(clazz, name) {
  if (lazyNullPrototypeCache === undefined) {
    lazyNullPrototypeCache = new Map();
  } else {
    const cachedClass = lazyNullPrototypeCache.get(clazz);
    if (cachedClass !== undefined) {
      return cachedClass;
    }
  }
  class NullPrototype extends clazz {
    get [Symbol.toStringTag]() {
      return '';
    }
  }
  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {
    value: `[${name}: null prototype]`
  });
  lazyNullPrototypeCache.set(clazz, NullPrototype);
  return NullPrototype;
}
function noPrototypeIterator(ctx, value, recurseTimes) {
  let newVal;
  if (isSet(value)) {
    const clazz = clazzWithNullPrototype(Set, 'Set');
    newVal = new clazz(SetPrototype.values(value));
  } else if (isMap(value)) {
    const clazz = clazzWithNullPrototype(Map, 'Map');
    newVal = new clazz(MapPrototype.entries(value));
  } else if (Array.isArray(value)) {
    const clazz = clazzWithNullPrototype(Array, 'Array');
    newVal = new clazz(value.length);
  } else if (isTypedArray(value)) {
    const constructor = findTypedConstructor(value);
    const clazz = clazzWithNullPrototype(constructor, constructor.name);
    newVal = new clazz(value);
  }
  if (newVal !== undefined) {
    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));
    return formatRaw(ctx, newVal, recurseTimes);
  }
}
function formatValue(ctx, value, recurseTimes, typedArray) {
  // Primitive types cannot have properties.
  if (typeof value !== 'object' && typeof value !== 'function') {
    return formatPrimitive(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
  // Memorize the context for custom inspection on proxies.
  const context = value;
  /*
  @fixme check for proxies
  // Always check for proxies to prevent side effects and to prevent triggering
  // any proxy handlers.
  const proxy = getProxyDetails(value);
  if (proxy !== undefined) {
  	if (ctx.showProxy) {
  		return formatProxy(ctx, proxy, recurseTimes);
  	}
  	value = proxy[0];
  }
  */
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it.
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];
    if (typeof maybeCustom === 'function'
    // Filter out the util module, its inspect function is special.
    && maybeCustom !== inspect
    // Also filter out any prototype objects using the circular check.
    && !(value.constructor && value.constructor.prototype === value)) {
      // This makes sure the recurseTimes are reported as before while using
      // a counter internally.
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx));
      // If the custom inspection method returned `this`, don't go into
      // infinite recursion.
      if (ret !== context) {
        if (typeof ret !== 'string') {
          return formatValue(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `\n${' '.repeat(ctx.indentationLvl)}`);
      }
    }
  }
  // Using an array here is actually better for the average case than using
  // a Set. `seen` will only check for the depth and will never grow too large.
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === undefined) {
      ctx.circular = new Map([[value, index]]);
    } else {
      index = ctx.circular.get(value);
      if (index === undefined) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, 'special');
  }
  return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  const constructor = getConstructorName(value);
  let tag = value[Symbol.toStringTag];
  // Only list the tag in case it's non-enumerable / not an own property.
  // Otherwise we'd print this twice.
  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty : propertyIsEnumerable)(value, Symbol.toStringTag)) {
    tag = '';
  }
  let base = '';
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType;

  // Iterators and the rest are split to reduce checks.
  if (value[Symbol.iterator]) {
    noIterator = false;
    if (Array.isArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      // Only set the constructor for non ordinary ("Array [...]") arrays.
      const prefix = getPrefix(constructor, tag, 'Array');
      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];
      if (value.length === 0 && keys.length === 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Set');
      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, '}'];
      formatter = formatSet;
    } else if (isMap(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Map');
      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, '}'];
      formatter = formatMap;
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const prefix = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);
      braces = [`${prefix}[`, ']'];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray;
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Map', tag);
      formatter = formatIterator;
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Set', tag);
      formatter = formatIterator;
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ['{', '}'];
    if (constructor === 'Object') {
      if (isArgumentsObject(value)) {
        braces[0] = '[Arguments] {';
      } else if (tag !== '') {
        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;
      }
      if (keys.length === 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === 'function') {
      base = getFunctionBase(value, constructor, tag);
      if (keys.length === 0) {
        return ctx.stylize(base, 'special');
      }
    } else if (isRegExp(value)) {
      // Make RegExps say that they are RegExps
      // eslint-disable-next-line security/detect-non-literal-regexp
      const regExp = constructor !== null ? value : new RegExp(value);
      base = RegExpPrototype.toString.call(regExp);
      const prefix = getPrefix(constructor, tag, 'RegExp');
      if (prefix !== 'RegExp ') {
        base = `${prefix}${base}`;
      }
      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base, 'regexp');
      }
    } else if (isDate(value)) {
      // Make dates with properties first say the date
      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);
      const prefix = getPrefix(constructor, tag, 'Date');
      if (prefix !== 'Date ') {
        base = `${prefix}${base}`;
      }
      if (keys.length === 0) {
        return ctx.stylize(base, 'date');
      }
    } else if (isError(value)) {
      base = formatError(value, constructor, tag, ctx);
      if (keys.length === 0) {
        return base;
      } else if (isIos) {
        const nativeErrorProps = ['line', 'column', 'sourceURL'];
        if (keys.every((key) => nativeErrorProps.includes(key))) {
          return base;
        }
      }
    } else if (isAnyArrayBuffer(value)) {
      // Fast path for ArrayBuffer and SharedArrayBuffer.
      // Can't do the same for DataView because it has a non-primitive
      // .buffer property that we need to recurse for.
      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';
      const prefix = getPrefix(constructor, tag, arrayType);
      if (typedArray === undefined) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0) {
        return `${prefix}{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      keys.unshift('byteLength');
    } else if (isDataView(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;
      // .buffer goes last, it's not a primitive like the others.
      keys.unshift('byteLength', 'byteOffset', 'buffer');
    } else if (isPromise(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
      /*
       * @fixme how to do isModuleNamespaceObject?
      } else if (isModuleNamespaceObject(value)) {
      	braces[0] = `[${tag}] {`;
      	formatter = formatNamespaceObject;
      */
    } else if (isBoxedPrimitive(value)) {
      base = getBoxedBase(value, ctx, keys, constructor, tag);
      if (keys.length === 0) {
        return base;
      }
    } else {
      // The input prototype got manipulated. Special handle these. We have to
      // rebuild the information so we are able to display everything.
      if (constructor === null) {
        const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);
        if (specialIterator) {
          return specialIterator;
        }
      }
      if (isMapIterator(value)) {
        braces = getIteratorBraces('Map', tag);
        formatter = formatIterator;
      } else if (isSetIterator(value)) {
        braces = getIteratorBraces('Set', tag);
        formatter = formatIterator;
        // Handle other regular objects again.
      } else {
        if (keys.length === 0) {
          return `${getCtxStyle(value, constructor, tag)}{}`;
        }
        braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
      }
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, 'special');
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes, keys, braces);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }
  if (ctx.circular !== undefined) {
    const index = ctx.circular.get(value);
    if (index !== undefined) {
      const reference = ctx.stylize(`<ref *${index}>`, 'special');
      // Add reference always to the very beginning of the output.
      if (ctx.compact !== true) {
        base = base === '' ? reference : `${reference} ${base}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? undefined : ctx.sorted;
    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  // If any indentationLvl exceeds this limit, limit further inspecting to the
  // minimum. Otherwise the recursive algorithm might continue inspecting the
  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
  // This limit also makes sure that huge objects don't block the event loop
  // significantly.
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
function getIteratorBraces(type, tag) {
  if (tag !== `${type} Iterator`) {
    if (tag !== '') {
      tag += '] [';
    }
    tag += `${type} Iterator`;
  }
  return [`[${tag}] {`, '}'];
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
  let fn;
  let type;
  if (isNumberObject(value)) {
    fn = NumberPrototype;
    type = 'Number';
  } else if (isStringObject(value)) {
    fn = StringPrototype;
    type = 'String';
    // For boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    // Make boxed primitive Strings look like such
    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    fn = BooleanPrototype;
    type = 'Boolean';
  } else {
    fn = SymbolPrototype;
    type = 'Symbol';
  }
  let base = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base += ' (null prototype)';
    } else {
      base += ` (${constructor})`;
    }
  }
  base += `: ${formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx)}]`;
  if (tag !== '' && tag !== constructor) {
    base += ` [${tag}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base;
  }
  return ctx.stylize(base, type.toLowerCase());
}
function getFunctionBase(value, constructor, tag) {
  let type = 'Function';
  if (isGeneratorFunction(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction(value)) {
    type = `Async${type}`;
  }
  let base = `[${type}`;
  if (constructor === null) {
    base += ' (null prototype)';
  }
  if (value.name === '') {
    base += ' (anonymous)';
  } else {
    base += `: ${value.name}`;
  }
  base += ']';
  if (constructor !== type && constructor !== null) {
    base += ` ${constructor}`;
  }
  if (tag !== '' && constructor !== tag) {
    base += ` [${tag}]`;
  }
  return base;
}
function formatError(err, constructor, tag, ctx) {
  let stack = err.stack || ErrorPrototype.toString.call(err);
  // try to normalize JavaScriptCore stack to match v8
  if (isIos) {
    const lines = stack.split('\n');
    stack = `${err.name}: ${err.message}`;
    if (lines.length > 0) {
      stack += lines.map((stackLine) => {
        const atSymbolIndex = stackLine.indexOf('@');
        const source = stackLine.slice(atSymbolIndex + 1);
        const sourcePattern = /(.*):(\d+):(\d+)/;
        let symbolName = 'unknown';
        if (atSymbolIndex !== -1) {
          symbolName = stackLine.slice(0, atSymbolIndex);
        }
        const sourceMatch = source.match(sourcePattern);
        if (sourceMatch) {
          let filePath = sourceMatch[1];
          const lineNumber = sourceMatch[2];
          const column = sourceMatch[3];
          if (filePath.startsWith('file:')) {
            filePath = filePath.replace(`file://${Ti.Filesystem.resourcesDirectory}`, '');
          }
          return `\n    at ${symbolName} (${filePath}:${lineNumber}:${column})`;
        } else {
          return `\n    at ${symbolName} (${source})`;
        }
      }).join('');
    }
  }

  // A stack trace may contain arbitrary data. Only manipulate the output
  // for "regular errors" (errors that "look normal") for now.
  const name = err.name || 'Error';
  let len = name.length;
  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\n')) {
    let fallback = 'Error';
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || '';
      len = fallback.length;
      fallback = fallback || 'Error';
    }
    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }

  // Ignore the error message if it's contained in the stack.
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  // Wrap the error in brackets in case it has no stack trace.
  let stackStart = stack.indexOf('\n    at', pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    // Highlight userland code and node modules.
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split('\n');
    for (const line of lines) {
      // This adds underscores to all node_modules to quickly identify them.
      let nodeModule;
      newStack += '\n';
      let pos = 0;
      while (nodeModule = nodeModulesRegExp.exec(line)) {
        // '/node_modules/'.length === 14
        newStack += line.slice(pos, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], 'module');
        pos = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos === 0 ? line : line.slice(pos);
    }
    stack = newStack;
  }
  // The message and the stack have to be indented as well!
  if (ctx.indentationLvl !== 0) {
    const indentation = ' '.repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `\n${indentation}`);
  }
  return stack;
}
function formatPromise(ctx, _value, _recurseTimes) {
  // Node calls into native to get promise details which we can't do
  return [ctx.stylize('<unknown>', 'special')];
}
function formatProperty(ctx, value, recurseTimes, key, type) {
  let name, str;
  let extra = ' ';
  const desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key],
    enumerable: true
  };
  if (desc.value !== undefined) {
    const diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);
    if (diff === 3) {
      const len = ctx.colors ? removeColors(str).length : str.length;
      if (ctx.breakLength < len) {
        extra = `\n${' '.repeat(ctx.indentationLvl)}`;
      }
    }
    ctx.indentationLvl -= diff;
  } else if (desc.get !== undefined) {
    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
    const s = ctx.stylize;
    const sp = 'special';
    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {
      try {
        const tmp = value[key];
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;
        } else if (typeof tmp === 'object') {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== undefined) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = ctx.stylize('undefined', 'undefined');
  }
  if (type === kArrayType) {
    return str;
  }
  if (typeof key === 'symbol') {
    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, 'symbol')}]`;
  } else if (desc.enumerable === false) {
    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, 'name');
  } else {
    name = ctx.stylize(strEscape(key), 'string');
  }
  return `${name}:${extra}${str}`;
}
function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    // This makes sure the "... n more items" part is not taken into account.
    outputLength--;
  }
  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.
  const dataLen = new Array(outputLength);
  // Calculate the total length of all output entries and the individual max
  // entries length of all output entries. We have to remove colors first,
  // otherwise the length would not be calculated properly.
  for (; i < outputLength; i++) {
    const len = ctx.colors ? removeColors(output[i]).length : output[i].length;
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  // Add two to `maxLength` as we add a single whitespace character plus a comma
  // in-between two entries.
  const actualMax = maxLength + separatorSpace;
  // Check if at least three entries fit next to each other and prevent grouping
  // of arrays that contains entries of very different length (i.e., if a single
  // entry is longer than 1/5 of all other entries combined). Otherwise the
  // space in-between small entries would be enormous.
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    // Dynamically check how many columns seem possible.
    const columns = Math.min(
    // Ideally a square should be drawn. We expect a character to be about 2.5
    // times as high as wide. This is the area formula to calculate a square
    // which contains n rectangles of size `actualMax * approxCharHeights`.
    // Divide that by `actualMax` to receive the correct number of columns.
    // The added bias increases the columns for short entries.
    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax),
    // Do not exceed the breakLength.
    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax),
    // Limit array grouping for small `compact` modes as the user requested
    // minimal grouping.
    ctx.compact * 4,
    // Limit the columns to a maximum of fifteen.
    15);
    // Return with the original output if no grouping should happen.
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i = 0; i < columns; i++) {
      let lineMaxLength = 0;
      for (let j = i; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i] = lineMaxLength;
    }
    let order = 'padStart';
    if (value !== undefined) {
      for (let i = 0; i < output.length; i++) {
        if (typeof value[i] !== 'number') {
          order = 'padEnd';
          break;
        }
      }
    }
    // Each iteration creates a single line of grouped entries.
    for (let i = 0; i < outputLength; i += columns) {
      // The last lines may contain less entries than columns.
      const max = Math.min(i + columns, outputLength);
      let str = '';
      let j = i;
      for (; j < max - 1; j++) {
        // Calculate extra color padding in case it's active. This has to be
        // done line by line as some lines might contain more colors than
        // others.
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
        str += `${output[j]}, `[order](padding, ' ');
      }
      if (order === 'padStart') {
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, ' ');
      } else {
        str += output[j];
      }
      tmp.push(str);
    }
    if (ctx.maxArrayLength < output.length) {
      tmp.push(output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
  if (isStackOverflowError(err)) {
    ctx.seen.pop();
    ctx.indentationLvl = indentationLvl;
    return ctx.stylize(`[${constructorName}: Inspection interrupted 'prematurely. Maximum call stack size exceeded.]`, 'special');
  }
  throw err;
}
function formatNumber(fn, value) {
  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.
  return fn(Object.is(value, -0) ? '-0' : `${value}`, 'number');
}
function formatBigInt(fn, value) {
  return fn(`${value}n`, 'bigint');
}
function formatPrimitive(fn, value, ctx) {
  if (typeof value === 'string') {
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/\n/).map((line) => fn(strEscape(line), 'string')).join(` +\n${' '.repeat(ctx.indentationLvl + 2)}`);
    }
    return fn(strEscape(value), 'string');
  }
  if (typeof value === 'number') {
    return formatNumber(fn, value);
  }
  /*
  if (typeof value === 'bigint') {
  	return formatBigInt(fn, value);
  }
  */
  if (typeof value === 'boolean') {
    return fn(`${value}`, 'boolean');
  }
  if (typeof value === 'undefined') {
    return fn('undefined', 'undefined');
  }
  // es6 symbol primitive
  return fn(SymbolPrototype.toString.call(value), 'symbol');
}

// The array is sparse and/or has extra keys
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key = keys[i];
    const tmp = +key;
    // Arrays can only have up to 2^32 - 1 entries
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? 's' : '';
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? 's' : '';
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatArrayBuffer(ctx, value) {
  const buffer = new Uint8Array(value);
  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (hexSlice === undefined) {
  	hexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);
  }
  */
  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }
  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];
}
function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (var i = 0; i < len; i++) {
    // Special handle sparse arrays.
    if (!hasOwnProperty(value, i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatTypedArray(ctx, value, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;
  }
  if (ctx.showHidden) {
    // .buffer goes last, it's not a primitive like the others.
    ctx.indentationLvl += 2;
    for (const key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {
      const str = formatValue(ctx, value[key], recurseTimes, true);
      output.push(`[${key}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function formatSet(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v of value) {
    output.push(formatValue(ctx, v, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  // With `showHidden`, `length` will display as a hidden property for
  // arrays. For consistency's sake, do the same for `size`, even though this
  // property isn't selected by Object.getOwnPropertyNames().
  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }
  return output;
}
function formatMap(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const [k, v] of value) {
    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  // See comment in formatSet
  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }
  return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  let output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (var i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak && !ctx.sorted) {
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    output = output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  // Entries exist as [key1, val1, key2, val2, ...]
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` + ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    }
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [formatValue(ctx, entries[pos], recurseTimes), formatValue(ctx, entries[pos + 1], recurseTimes)];
      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatWeakCollection(ctx) {
  return [ctx.stylize('<items unknown>', 'special')];
}
function formatWeakSet(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}
function formatWeakMap(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}
function formatIterator(ctx, value, recurseTimes, _keys, braces) {
  const entries = [];
  let isKeyValue = false;
  let result = value.next();
  while (!result.done) {
    const currentEntry = result.value;
    entries.push(currentEntry);
    if (currentEntry[0] !== currentEntry[1]) {
      isKeyValue = true;
    }
    result = value.next();
  }
  if (isKeyValue) {
    // Mark entry iterators as such.
    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }
  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}
function isBelowBreakLength(ctx, output, start, base) {
  // Each entry is separated by at least a comma. Thus, we start with a total
  // length of at least `output.length`. In addition, some cases have a
  // whitespace in-between each other that is added to the total as well.
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (var i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  // Do not line up properties on the same line if `base` contains line breaks.
  return base === '' || !base.includes('\n');
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
      // Memorize the original output length. In case the the output is grouped,
      // prevent lining up the entries on a single line.
      const entries = output.length;
      // Group array elements together if the array contains at least six
      // separate entries.
      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      }
      // `ctx.currentDepth` is set to the most inner depth of the currently
      // inspected object part while `recurseTimes` is the actual current depth
      // that is inspected.
      //
      // Example:
      //
      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
      //
      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
      // depth of 1.
      //
      // Consolidate all entries of the local most inner depth up to
      // `ctx.compact`, as long as the properties are smaller than
      // `ctx.breakLength`.
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        // Line up all entries on a single line in case the entries do not
        // exceed `breakLength`. Add 10 as constant to start next to all other
        // factors that may reduce `breakLength`.
        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
        if (isBelowBreakLength(ctx, output, start, base)) {
          return `${base ? `${base} ` : ''}${braces[0]} ${join$1(output, ', ')} ${braces[1]}`;
        }
      }
    }
    // Line up each entry on an individual line.
    const indentation = `\n${' '.repeat(ctx.indentationLvl)}`;
    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` + `${join$1(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  }
  // Line up all entries on a single line in case the entries do not exceed
  // `breakLength`.
  if (isBelowBreakLength(ctx, output, 0, base)) {
    return `${braces[0]}${base ? ` ${base}` : ''} ${join$1(output, ', ')} ` + braces[1];
  }
  const indentation = ' '.repeat(ctx.indentationLvl);
  // If the opening "brace" is too large, like in the case of "Set {",
  // we need to force the first item to be on the next line or the
  // items will not line up correctly.
  const ln = base === '' && braces[0].length === 1 ? ' ' : `${base ? ` ${base}` : ''}\n${indentation}  `;
  // Line up each entry on an individual line.
  return `${braces[0]}${ln}${join$1(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function format$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return formatWithOptions(undefined, ...args);
}
const firstErrorLine = (error) => error.message.split('\n')[0];
let CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);
      }
    }
    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }
    throw err;
  }
}

/* eslint-disable max-depth */
function formatWithOptions(inspectOptions) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const first = args[0];
  let a = 0;
  let str = '';
  let join = '';
  if (typeof first === 'string') {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        // '%'
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              // 's'
              const tempArg = args[++a];
              if (typeof tempArg === 'number') {
                tempStr = formatNumber(stylizeNoColor, tempArg);
                /*
                } else if (typeof tempArg === 'bigint') {
                	tempStr = `${tempArg}n`;
                */
              } else {
                let constr;
                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty(tempArg, 'toString')
                // A direct own property on the constructor prototype in
                // case the constructor is not an built-in object.
                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty(constr.prototype, 'toString'))) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, {
                    ...inspectOptions,
                    compact: 3,
                    colors: false,
                    depth: 0
                  });
                }
              }
              break;
            case 106:
              // 'j'
              tempStr = tryStringify(args[++a]);
              break;
            case 100:
              // 'd'
              const tempNum = args[++a];
              /*
              if (typeof tempNum === 'bigint') {
              	tempStr = `${tempNum}n`;
              } else
              */
              if (typeof tempNum === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, Number(tempNum));
              }
              break;
            case 79:
              // 'O'
              tempStr = inspect(args[++a], inspectOptions);
              break;
            case 111:
              // 'o'
              {
                tempStr = inspect(args[++a], {
                  ...inspectOptions,
                  showHidden: true,
                  showProxy: true,
                  depth: 4
                });
                break;
              }
            case 105:
              // 'i'
              const tempInteger = args[++a];
              /*
              if (typeof tempInteger === 'bigint') {
              	tempStr = `${tempInteger}n`;
              } else */
              if (typeof tempInteger === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));
              }
              break;
            case 102:
              // 'f'
              const tempFloat = args[++a];
              if (typeof tempFloat === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));
              }
              break;
            case 37:
              // '%'
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              // Any other character is not a correct placeholder
              continue;}

          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join = ' ';
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join;
    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
    join = ' ';
    a++;
  }
  return str;
}
/* eslint-enable max-depth */

function noop$1() {}
function logTime(self, label, logData) {
  label = `${label}`;
  const startTime = self._times.get(label);
  if (!startTime) {
    process.emitWarning(`Label "${label}" does not exist`);
    return true;
  }
  const duration = Date.now() - startTime;
  if (logData) {
    self.log(`${label}: ${duration}ms`, ...logData);
  } else {
    self.log(`${label}: ${duration}ms`);
  }
  return false;
}
const kColorInspectOptions = {
  colors: true
};
const kNoColorInspectOptions = {};
let tableWarned; // boolean flag for one-time warning about console.table not being implemented

// Make a function that can serve as the callback passed to `stream.write()`.
function createWriteErrorHandler(stream) {
  return (err) => {
    // This conditional evaluates to true if and only if there was an error
    // that was not already emitted (which happens when the _write callback
    // is invoked asynchronously).
    if (err !== null && !stream._writableState.errorEmitted) {
      // If there was an error, it will be emitted on `stream` as
      // an `error` event. Adding a `once` listener will keep that error
      // from becoming an uncaught exception, but since the handler is
      // removed after the event, non-console.* writes won't be affected.
      // we are only adding noop if there is no one else listening for 'error'
      if (stream.listenerCount('error') === 0) {
        stream.once('error', noop$1);
      }
    }
  };
}
class Console {
  constructor(options, stderr, ignoreErrors) {
    if (options && options.apiName === 'Ti.API') {
      // Passing in Ti.API module where we retain log levels
      this._apiModule = options;
    } else {
      // Node.JS streams
      if (!options || typeof options.write === 'function') {
        // no args, or first arg is a stream
        options = {
          stdout: options,
          stderr,
          ignoreErrors
        };
      }
      this._stdout = options.stdout; // TODO: enforce has write function?
      this._stderr = options.stderr || this._stdout;
      this._ignoreErrors = options.ignoreErrors !== false;
      if (this._ignoreErrors) {
        this._stdoutErrorHandler = createWriteErrorHandler(this._stdout);
        this._stderrErrorHandler = createWriteErrorHandler(this._stderr);
      }
      this._colorMode = options.colorMode || 'auto'; // TODO: enforce boolean or 'auto'
      this._inspectOptions = options.inspectOptions; // TODO: enforce undefined or typeof 'object'
    }

    this._times = new Map();
    this._counts = new Map();
    this._groupIndent = '';
  }
  _writeToConsole(level, string) {
    if (this._groupIndent.length !== 0) {
      if (string.includes('\n')) {
        string = string.replace(/\n/g, `\n${this._groupIndent}`);
      }
      string = this._groupIndent + string;
    }

    // Support wrapping Ti.API (which retains log level)
    if (this._apiModule) {
      this._apiModule[level](string);
    } else {
      // Support Node.JS streams like stdout/stderr which don't have log levels
      const useStdErr = level === 'warn' || level === 'error' || level === 'trace';
      const stream = useStdErr ? this._stderr : this._stdout;
      if (this._ignoreErrors === false) {
        return stream.write(string);
      }

      // There may be an error occurring synchronously (e.g. for files or TTYs
      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so
      // handle both situations.
      try {
        // Add and later remove a noop error handler to catch synchronous errors.
        if (stream.listenerCount('error') === 0) {
          stream.once('error', noop$1);
        }
        const errorHandler = useStdErr ? this._stderrErrorHandler : this._stdoutErrorHandler;
        stream.write(string, errorHandler);
      } catch (e) {
        // Console is a debugging utility, so it swallowing errors is not desirable
        // even in edge cases such as low stack space.
        if (isStackOverflowError(e)) {
          throw e;
        }
        // Sorry, there's no proper way to pass along the error here.
      } finally {
        stream.removeListener && stream.removeListener('error', noop$1);
      }
    }
  }
  info() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this._writeToConsole('info', formatWithOptions(kColorInspectOptions, ...args));
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    this._writeToConsole('warn', formatWithOptions(kNoColorInspectOptions, ...args));
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    this._writeToConsole('error', formatWithOptions(kNoColorInspectOptions, ...args));
  }
  debug() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    this._writeToConsole('debug', formatWithOptions(kColorInspectOptions, ...args));
  }
  trace() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    this._writeToConsole('trace', formatWithOptions(kColorInspectOptions, ...args));
  }
  clear() {} // no-op

  group() {
    if (arguments.length > 0) {
      this.log(...arguments);
    }
    this._groupIndent += '  ';
  }
  groupEnd() {
    this._groupIndent = this._groupIndent.slice(0, this._groupIndent.length - 2);
  }
  dir(obj, options) {
    this._writeToConsole('info', inspect(obj, {
      customInspect: false,
      ...options
    }));
  }
  assert(value) {
    if (!value) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;
      this.warn(...args); // The arguments will be formatted in warn() again
    }
  }

  count() {
    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    // Ensures that label is a string, and only things that can be
    // coerced to strings. e.g. Symbol is not allowed
    label = `${label}`;
    let count = this._counts.get(label);
    if (count === undefined) {
      count = 1;
    } else {
      count++;
    }
    this._counts.set(label, count);
    this.log(`${label}: ${count}`);
  }
  countReset() {
    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    if (!this._counts.has(label)) {
      process.emitWarning(`Count for '${label}' does not exist`);
      return;
    }
    this._counts.delete(`${label}`);
  }
  time() {
    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    label = `${label}`;
    if (this._times.has(label)) {
      process.emitWarning(`Label ${label}" already exists`);
      return;
    }
    this._times.set(label, Date.now());
  }
  timeEnd() {
    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    const warned = logTime(this, label);
    if (!warned) {
      this._times.delete(label);
    }
  }
  timeLog() {
    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    for (var _len7 = arguments.length, logData = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
      logData[_key7 - 1] = arguments[_key7];
    }
    logTime(this, label, logData);
  }

  // TODO: implement console.table()
  table() {
    if (!tableWarned) {
      tableWarned = true;
      process.emitWarning('"console.table" is not yet implemented in Titanium!');
    }
  }
}
Console.prototype.log = Console.prototype.info; // Treat log as alias to info
Console.prototype.dirxml = Console.prototype.log; // Treat dirxml as alias to log
Console.prototype.groupCollapsed = Console.prototype.group;
const globalConsole = new Console(Ti.API);
globalConsole.Console = Console;
global.console = globalConsole;

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
 * This file is used to hijack the standard require to allow for JS
 * implementations of "core" modules.
 *
 * You add a binding from the "core" module id to the under the hood JS
 * implementation. We then intercept require calls to handle requests for these modules
 * and lazily load the file.
 */

/**
 * Used by @function bindObjectToCoreModuleId
 * @type {map<string, object>}
 */
const bindings = new Map();

/**
 * Used by @function redirectCoreModuleIdToPath
 * @type {map<string, string>}
 */
const redirects = new Map();

/**
 * Does the request look like a typical core module? (no '.' or '/' characters)
 * @param {string} path original require path/id
 * @returns {boolean}
 */
function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }
  const firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
}

// Hack require to point to this as core module "binding". (Note that iOS does not have a global require.)
const originalRequire = global.require ? global.require : require.main.require.bind(require.main);
// This works for Windows as-is, and also intercepts the call on Android/iOS for ti.main.js (the first file executed)
global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }
  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }
  return originalRequire(moduleId);
};

// ... but we still need to hack it when requiring from other files for Android/iOS (due to module.js impl)
const originalModuleRequire = global.Module.prototype.require;
global.Module.prototype.require = function (path, context) {
  if (bindings.has(path)) {
    return bindings.get(path);
  }
  if (redirects.has(path)) {
    path = redirects.get(path);
  }
  return originalModuleRequire.call(this, path, context);
};

/**
 * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {*} binding an already constructured value/object to return
 */
function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }
  if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }
  bindings.set(moduleId, binding);
}

/**
 * Registers a binding from a short module id to the full under the hood filepath if given a string.
 * This allows for lazy instantiation of the module on-demand
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {string} filepath the full filepath to require under the hood.
 *                              This should be an already resolved absolute path,
 *                              as otherwise the context of the call could change what gets loaded!
 */
function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }
  if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }
  redirects.set(moduleId, filepath);
}

// FIXME: There's a collision here with global.binding declared in KrollBridge.m on iOS
if (!global.binding) {
  global.binding = {};
}
global.binding.register = register;
global.binding.redirect = redirect;

// Load all JavaScript extensions/polyfills
register('console', globalConsole);

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID, OS_IOS, OS_VERSION_MAJOR */
const buffer = Ti.createBuffer({
  value: ''
});
const blob = buffer.toBlob();
const BlobPrototype = Object.getPrototypeOf(blob);
{
  if (OS_VERSION_MAJOR < 13) {
    BlobPrototype.toString = function () {
      const value = this.text;
      return value === undefined ? '[object TiBlob]' : value;
    };
  }
}

/**
 * This script is used at runtime for Ti.UI.fetchSemanticColor - as well as at build time by both iOS/Android.
 * It provides a common interface for handling colors and converting to necessary string forms.
 */
const HEX_3_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F3
const HEX_4_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F38
const HEX_6_REGEX = /^#?([a-f\d]){6}$/i; // i.e. #00FF33
const HEX_8_REGEX = /^#?([a-f\d]){8}$/i; // i.e. #00FF3388

/**
 * @param {number} integer in range of 0-255
 * @returns {string} 2-character hex string value
 */
function paddedHex(integer) {
  const str = integer.toString(16);
  if (str.length === 1) {
    return `0${str}`;
  }
  return str;
}
class Color {
  /**
   * @param {number} r red value in range 0-255
   * @param {number} g green value in range 0-255
   * @param {number} b blue value in range 0-255
   * @param {number} [a=1.0] alpha value in range 0.0-1.0
   */
  constructor(r, g, b) {
    let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;
    this.r = r;
    this.g = g;
    this.b = b;
    this.alpha = a;
  }

  /**
   * indicates if this is a fully opaque color (alpha is 1.0 or was undefined)
   * @returns {boolean}
   */
  isOpaque() {
    return this.alpha === 1.0;
  }

  /**
   * Converts the alpha value into equivalent hex string value properly.
   * @returns {string}
   */
  alphaHex() {
    // need to round to avoid nonsensical values like '7f.8' for a 0.5 alpha
    return paddedHex(Math.round(this.alpha * 255.0));
  }

  /**
   * Discards any alpha value. To be used internally, not external api. Does not provide leading '#' symbol.
   * @returns {string}
   */
  _toRGBHexString() {
    return `${paddedHex(this.r)}${paddedHex(this.g)}${paddedHex(this.b)}`;
  }

  /**
   * Used by CSS.
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0)
   * @returns {string}
   */
  toRGBAHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }
    return `#${this._toRGBHexString()}${this.alphaHex()}`;
  }

  /**
   * Used by Android/iOS
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0). Alpha is the first entry (if there is alpha.)
   * @returns {string}
   */
  toARGBHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }
    return `#${this.alphaHex()}${this._toRGBHexString()}`;
  }

  /**
   * For commonality with native iOS TiColor proxy. Produces an AARRGGBB (or RRGGBB if full alpha) hex string
   * @returns {string}
   */
  toHex() {
    return this.toARGBHexString();
  }

  /**
   * Converts this color to an rgba expression. This expression is more consistent across platforms.
   * (whereas iOS/Android differ in expectations for hex strings.)
   * @returns {string}
   */
  toRGBAString() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.alpha.toFixed(3)})`;
  }

  /**
   * @returns {Color}
   */
  static fallback() {
    return new Color(0, 0, 0); // return black to match native impl in iOS
  }

  /**
   * The supplied hex string MUST be in form '#000000' (i.e. leading pound symbol, 6 hex characters after)
   * @param {string} hex hexadecimal color string
   * @param {number} [alpha] alpha value
   * @returns {Color}
   */
  static fromHex6String(hex, alpha) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const r = parseInt(hex.substr(startIndex, 2), 16);
    const g = parseInt(hex.substr(startIndex + 2, 2), 16);
    const b = parseInt(hex.substr(startIndex + 4, 2), 16);
    return new Color(r, g, b, alpha);
  }

  /**
   * The supplied hex string MUST be in form '#00000000' (i.e. leading pound symbol, 8 hex characters after)
   * @param {string} hex hexadecimal color string
   * @returns {Color}
   */
  static fromHex8String(hex) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const alpha = parseInt(hex.substr(startIndex, 2), 16); // alpha is now 0-255
    const r = parseInt(hex.substr(startIndex + 2, 2), 16);
    const g = parseInt(hex.substr(startIndex + 4, 2), 16);
    const b = parseInt(hex.substr(startIndex + 6, 2), 16);
    return new Color(r, g, b, alpha / 255.0); // convert to 0.0-1.0 (percent)
  }

  /**
   * Note that the hex value can contain alpha, but must follow the CSS standard of #RRGGBBAA (NOT the Android standard of #AARRGGBB)
   * @param {string|object} entry possible hex string or an object
   * @param {string|number} [hex.alpha] alpha value in percent (0.0-100.0) when hex is an object
  	 * @param {string} [hex.color] hex string for the base color when hex is an object
   * @returns {Color}
   * @throws if entry has both an explicit alpha value AND a hex string containing an alpha value
   */
  static fromSemanticColorsEntry(entry) {
    let color = entry;
    let alpha = 1.0;
    let hadAlpha = false;
    if (Object.prototype.hasOwnProperty.call(entry, 'alpha')) {
      alpha = parseFloat(entry.alpha) / 100.0; // convert from 0-100 range to 0-1 range
      hadAlpha = true;
      color = entry.color; // if it has an alpha property assume it has a color property too!
    }

    // expand the shorter hex string forms to 6 or 8 digits
    if (color.length === 3) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      color = color.replace(HEX_3_REGEX, (m, r, g, b) => r + r + g + g + b + b);
    } else if (color.length === 4) {
      // Expand shorthand form (e.g. "03F8") to full form (e.g. "0033FF88")
      color = color.replace(HEX_4_REGEX, (m, a, r, g, b) => a + a + r + r + g + g + b + b);
    }
    if (HEX_6_REGEX.exec(color)) {
      return Color.fromHex6String(color, alpha);
    }
    if (HEX_8_REGEX.exec(color)) {
      if (hadAlpha) {
        throw new Error(`Color ${entry} had an explicit alpha value AND a hex value containing alpha. Use one or the other.`);
      }
      return Color.fromHex8String(color);
    }
    // uh-oh, something is up!
    return Color.fallback();
  }
}
var color = Color;

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
const isIOS13Plus = OS_VERSION_MAJOR >= 13;
const isMacOS = Ti.Platform.name === 'Mac OS X';
const isMACOSXCatalinaPlus = isMacOS && (OS_VERSION_MAJOR > 10 || OS_VERSION_MAJOR === 10 && OS_VERSION_MINOR >= 15);

// As Android passes a new instance of Ti.UI to every JS file we can't just
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.
const UI = Ti.UI;

// Make our read-only constants
// TODO: Remove in SDK 10, DEPRECATED in 9.1.0
Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_LIGHT', {
  value: 'light',
  writable: false
});
Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_DARK', {
  value: 'dark',
  writable: false
});
Object.defineProperty(UI, 'semanticColorType', {
  get: () => {
    // TODO: Guard against ios < 13 and Android api < 29?
    // Assume "light" mode unless we explicitly know it's dark
    if (Ti.UI.userInterfaceStyle === Ti.UI.USER_INTERFACE_STYLE_DARK) {
      return UI.SEMANTIC_COLOR_TYPE_DARK;
    }
    return UI.SEMANTIC_COLOR_TYPE_LIGHT;
  }
});

// on Android/iOS < 13, we need to roll our own fetchSemanticColor impl
// on iOS 13+, we have a native version
if (!isIOS13Plus && !isMACOSXCatalinaPlus) {
  // On iOS < 13, we don't have the theme constants defined, which breaks our tests
  if (!isMacOS) {
    Object.defineProperty(UI, 'USER_INTERFACE_STYLE_UNSPECIFIED', {
      value: 0,
      writable: false
    });
    Object.defineProperty(UI, 'USER_INTERFACE_STYLE_LIGHT', {
      value: 1,
      writable: false
    });
    Object.defineProperty(UI, 'USER_INTERFACE_STYLE_DARK', {
      value: 2,
      writable: false
    });
    // Treat iOS < 13 as 'light' theme
    Object.defineProperty(UI, 'userInterfaceStyle', {
      value: 1,
      writable: false
    });
  }
  let colorset;
  UI.fetchSemanticColor = function fetchSemanticColor(colorName) {
    // Load all semantic colors from JSON if not done already.
    // Do so via require() in case this file was changed while running LiveView.
    if (!colorset) {
      const colorsetFileName = 'semantic.colors.json';
      try {
        const colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, colorsetFileName);
        if (colorsetFile.exists()) {
          // eslint-disable-next-line security/detect-non-literal-require
          colorset = require(`/${colorsetFileName}`);
        }
      } catch (error) {
        console.error(`Failed to load colors file '${colorsetFileName}'`);
        return color.fallback().toHex();
      }
    }
    try {
      if (false) ;else if (colorset[colorName]) {
        // Return the raw color string value from the "semantic.colors.json".
        // Use the more exact rgba function over 8-char ARGB hex. Hard to convert things like 75% alpha properly.
        const entry = colorset[colorName][UI.semanticColorType];
        const colorObj = color.fromSemanticColorsEntry(entry);
        return colorObj.toRGBAString();
      }
    } catch (error) {
      console.error(`Failed to lookup color for ${colorName}`);
    }
    return color.fallback().toHex();
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID, OS_IOS */
{
  const tab = Titanium.UI.createTab();
  const TabPrototype = Object.getPrototypeOf(tab);
  TabPrototype.setWindow = function (window) {
    this.window = window; // forward to setting property
  };
}

/**
 * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
 * @param {string} eventName the name of the event to register for
 * @param {function} listener the listener callback/function to invoke when the event is emitted
 * @param {boolean} prepend whether to prepend or append the listener
 * @returns {EventEmitter}
 */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  }
  // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)
  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }
  const eventListeners = emitter._eventsToListeners[eventName] || [];
  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }
  emitter._eventsToListeners[eventName] = eventListeners;

  // Check max listeners and spit out warning if >
  const max = emitter.getMaxListeners();
  const length = eventListeners.length;
  if (max > 0 && length > max) {
    const w = new Error(`Possible EventEmitter memory leak detected. ${length} ${eventName} listeners added. Use emitter.setMaxListeners() to increase limit`);
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }
  return emitter;
}
function onceWrap(emitter, eventName, listener) {
  function wrapper() {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.listener.apply(this.emitter, args); // then forward the event callback
  }
  // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter
  const wrapperThis = {
    emitter,
    eventName,
    listener
  };
  const bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener
  bound.listener = listener; // have to add listener property for "unwrapping"
  wrapperThis.wrappedFunc = bound;
  return bound;
}

// many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it
class EventEmitter {
  constructor() {
    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }
  addListener(eventName, listener) {
    return _addListener(this, eventName, listener, false);
  }
  on(eventName, listener) {
    return this.addListener(eventName, listener);
  }
  prependListener(eventName, listener) {
    return _addListener(this, eventName, listener, true);
  }
  once(eventName, listener) {
    this.on(eventName, onceWrap(this, eventName, listener));
  }
  prependOnceListener(eventName, listener) {
    this.prependListener(eventName, onceWrap(this, eventName, listener));
  }
  removeListener(eventName, listener) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return this;
    }
    const eventListeners = this._eventsToListeners[eventName] || [];
    const length = eventListeners.length;
    let foundIndex = -1;
    let unwrappedListener;
    // Need to search LIFO, and need to handle wrapped functions (once wrappers)
    for (let i = length - 1; i >= 0; i--) {
      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
        foundIndex = i;
        unwrappedListener = eventListeners[i].listener;
        break;
      }
    }
    if (foundIndex !== -1) {
      if (length === 1) {
        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
        delete this._eventsToListeners[eventName];
      } else {
        // we had 2+ listeners, so store array without this given listener
        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
      }
      // Don't emit if there's no listeners for 'removeListener' type!
      if (this._eventsToListeners.removeListener) {
        this.emit('removeListener', eventName, unwrappedListener || listener);
      }
    }
    return this;
  }
  off(eventName, listener) {
    return this.removeListener(eventName, listener);
  }
  emit(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return false;
    }
    const eventListeners = this._eventsToListeners[eventName] || [];
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    for (const listener of eventListeners.slice()) {
      // must operate on copy because listeners ,ay get remove as side-effect of calling
      listener.call(this, ...args);
    }
    return eventListeners.length !== 0;
  }
  listenerCount(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return 0;
    }
    const eventListeners = this._eventsToListeners[eventName] || [];
    return eventListeners.length;
  }
  eventNames() {
    return Object.getOwnPropertyNames(this._eventsToListeners || {});
  }
  listeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }
    // Need to "unwrap" once wrappers!
    const raw = this._eventsToListeners[eventName] || [];
    return raw.map((l) => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function
  }

  rawListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }
    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
  }

  getMaxListeners() {
    return this._maxListeners || EventEmitter.defaultMaxListeners;
  }
  setMaxListeners(n) {
    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)
    return this;
  }
  removeAllListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      this._eventsToListeners = {}; // initialize it
    }

    if (!this._eventsToListeners.removeListener) {
      // no need to emit! we can just wipe!
      if (eventName === undefined) {
        // remove every type!
        this._eventsToListeners = {};
      } else {
        // remove specific type
        delete this._eventsToListeners[eventName];
      }
      return this;
    }

    // yuck, we'll have to emit 'removeListener' events as we go
    if (eventName === undefined) {
      // Remove all types (but do 'removeListener' last!)
      const names = Object.keys(this._eventsToListeners).filter((name) => name !== 'removeListener');
      names.forEach((name) => this.removeAllListeners(name));
      this.removeAllListeners('removeListener');
      this._eventsToListeners = {};
    } else {
      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
      const listeners = this._eventsToListeners[eventName] || [];
      for (let i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(eventName, listeners[i]);
      }
    }
    return this;
  }
}
EventEmitter.defaultMaxListeners = 10;
EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};
EventEmitter.EventEmitter = EventEmitter;

/**
 * @param  {*} arg passed in argument value
 * @param  {string} name name of the argument
 * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
 * @return {void}
 * @throws {TypeError}
 */
function assertArgumentType(arg, name, typename) {
  const type = typeof arg;
  if (type !== typename.toLowerCase()) {
    throw new TypeError(`The "${name}" argument must be of type ${typename}. Received type ${type}`);
  }
}

// Start our process uptime timer immediately!
const startTime = Date.now();

/**
 * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
 * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
 * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
 * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
 * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
 * @param {string} original original architecture reported by Ti.Platform
 * @returns {string}
 */
function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';

    // coerce 'arm64-v8a' -> 'arm64'
    case 'arm64-v8a':
      return 'arm64';

    // coerce 'i386', 'x86' -> 'ia32'
    case 'i386':
    case 'x86':
      return 'ia32';

    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'
    case 'x86_64':
    case 'ia64':
      return 'x64';

    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17
    case 'mips64':
      return 'mips';

    // coerce 'Unknown' -> 'unknown'
    case 'Unknown':
      return 'unknown';
    default:
      return original;}

}
const process$1 = new EventEmitter();
process$1.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here
process$1.arch = standardizeArch(Ti.Platform.architecture);
process$1.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?
Object.defineProperty(process$1, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false
});
process$1.binding = () => {
  throw new Error('process.binding is unsupported and not user-facing API');
};
process$1.channel = undefined;
process$1.chdir = () => {
  throw new Error('process.chdir is unsupported');
};
process$1.config = {};
process$1.connected = false;
process$1.cpuUsage = () => {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0
  };
};
process$1.cwd = () => __dirname;
Object.defineProperty(process$1, 'debugPort', {
  get: function () {
    let value = 0; // default to 0
    try {
      if (Ti.Platform.osname === 'android') {
        const assets = kroll.binding('assets');
        const json = assets.readAsset('deploy.json');
        if (json) {
          const deployData = JSON.parse(json);
          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      } else if (true) {
        // iOS is 27753 as of ios < 11.3 for simulators
        // for 11.3+ it uses a unix socket
        // for devices, it uses usbmuxd
        value = 27753; // TODO: Can we only return this for simulator < 11.3?
      }
    } catch (error) {

      // ignore
    } // overwrite this getter with static value
    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    return value;
  },
  enumerable: true,
  configurable: true
});
process$1.disconnect = () => {}; // no-op
process$1.dlopen = () => {
  throw new Error('process.dlopen is not supported');
};
process$1.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  let type;
  let detail;
  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }
  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';
    if (code !== undefined) {
      warning.code = code;
    }
    if (detail !== undefined) {
      warning.detail = detail;
    }
  }
  // TODO: Throw TypeError if not an instanceof Error at this point!
  const isDeprecation = warning.name === 'DeprecationWarning';
  if (isDeprecation && process$1.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$1.throwDeprecation) {
    throw warning;
  }
  this.emit('warning', warning);
};
function loadEnvJson() {
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');
    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error(`Failed to read "_env_.json". Reason: ${error.message}`);
  }
  return {};
}
Object.defineProperty(process$1, 'env', {
  get: function () {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true
});
process$1.execArgv = [];
process$1.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?
process$1.exit = () => {
  throw new Error('process.exit is not supported');
};
process$1.exitCode = undefined;
process$1.noDeprecation = false;
process$1.pid = 0;
// FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?
process$1.platform = Ti.Platform.osname;
process$1.ppid = 0;
// TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?
// Don't wrap console.log/error because technically global console wraps process.stdout/stderr (or should)
process$1.stderr = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.error(chunk);
    if (callback) {
      callback();
    }
    return true;
  }
};
process$1.stdout = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.info(chunk);
    if (callback) {
      callback();
    }
    return true;
  }
};
process$1.title = Ti.App.name;
process$1.throwDeprecation = false;
process$1.traceDeprecation = false;
process$1.umask = () => 0; // just always return 0
process$1.uptime = () => {
  const diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$1.version = "12.7.1";
process$1.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

process$1[Symbol.toStringTag] = 'process';
global.process = process$1;
// handle spitting out warnings
const WARNING_PREFIX = `(titanium:${process$1.pid}) `;
process$1.on('warning', (warning) => {
  const isDeprecation = warning.name === 'DeprecationWarning';
  // if we're not doing deprecations, ignore!
  if (isDeprecation && process$1.noDeprecation) {
    return;
  }
  // TODO: Check process.traceDeprecation and if set, include stack trace in message!
  let msg = WARNING_PREFIX;
  if (warning.code !== undefined) {
    msg += `[${warning.code}] `;
  }
  if (warning.toString) {
    msg += warning.toString();
  }
  if (warning.detail) {
    msg += `\n${warning.detail}`;
  }
  console.error(msg);
});
let uncaughtExceptionCallback = null;
process$1.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;
process$1.setUncaughtExceptionCaptureCallback = (fn) => {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }
  assertArgumentType(fn, 'fn', 'function');
  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }
  uncaughtExceptionCallback = fn;
};
Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  const error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;
  if (process$1.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  }
  // otherwise forward the event!
  process$1.emit('uncaughtException', error);
});

// Use a nice predictable class/structure for our Immediate/Tick "timers"
// JS engine should be able to optimize easier
class CallbackWithArgs {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }
  run() {
    if (this.args) {
      this.func.apply(null, this.args);
    } else {
      this.fun();
    }
  }
}
// nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/
const tickQueue = [];
const immediateQueue = [];
let drainingTickQueue = false;
let drainQueuesTimeout = null;

/**
 * Iteratively runs all "ticks" until there are no more.
 * This can cause infinite recursion if a tick schedules another forever.
 */
function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }
  drainingTickQueue = true;
  while (tickQueue.length) {
    const tick = tickQueue.shift();
    tick.run();
  }
  drainingTickQueue = false;
}
function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue();
  // tick queue should be empty!
  const immediatesRemaining = processImmediateQueue();
  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}

/**
 * Attempts to process "immediates" (in a much more leisurely way than ticks)
 * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
 * If any ticks are added during invocation of immediate, we drain the tick queue fully before
 * proceeding to next immediate (if we still have time in our window).
 * @returns {number} number of remaining immediates to be processed
 */
function processImmediateQueue() {
  const immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates
  while (immediateQueue.length && Date.now() < immediateDeadline) {
    const immediate = immediateQueue.shift();
    immediate.run();
    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }
  return immediateQueue.length;
}
process$1.nextTick = function (callback) {
  assertArgumentType(callback, 'callback', 'function');
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  tickQueue.push(new CallbackWithArgs(callback, args));
  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};
global.setImmediate = function (callback) {
  assertArgumentType(callback, 'callback', 'function');
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);
  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
  return immediate;
};
global.clearImmediate = function (immediate) {
  const index = immediateQueue.indexOf(immediate);
  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

const FORWARD_SLASH = 47; // '/'
const BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */
function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}

/**
 * [isAbsolute description]
 * @param  {boolean} isPosix whether this impl is for POSIX or not
 * @param  {string} filepath   input file path
 * @return {Boolean}          [description]
 */
function isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;
  // empty string special case
  if (length === 0) {
    return false;
  }
  const firstChar = filepath.charCodeAt(0);
  if (firstChar === FORWARD_SLASH) {
    return true;
  }
  // we already did our checks for posix
  if (isPosix) {
    return false;
  }
  // win32 from here on out
  if (firstChar === BACKWARD_SLASH) {
    return true;
  }
  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    const thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }
  return false;
}

/**
 * [dirname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */
function dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;
  if (length === 0) {
    return '.';
  }

  // ignore trailing separator
  let fromIndex = length - 1;
  const hadTrailing = filepath.endsWith(separator);
  if (hadTrailing) {
    fromIndex--;
  }
  const foundIndex = filepath.lastIndexOf(separator, fromIndex);
  // no separators
  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      const firstChar = filepath.charCodeAt(0);
      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  }
  // only found root separator
  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  }
  // Handle special case of '//something'
  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }
  return filepath.slice(0, foundIndex);
}

/**
 * [extname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */
function extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const index = filepath.lastIndexOf('.');
  if (index === -1 || index === 0) {
    return '';
  }
  // ignore trailing separator
  let endIndex = filepath.length;
  if (filepath.endsWith(separator)) {
    endIndex--;
  }
  return filepath.slice(index, endIndex);
}
function lastIndexWin32Separator(filepath, index) {
  for (let i = index; i >= 0; i--) {
    const char = filepath.charCodeAt(i);
    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }
  return -1;
}

/**
 * [basename description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @param  {string} [ext]      file extension to drop if it exists
 * @return {string}            [description]
 */
function basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');
  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }
  const length = filepath.length;
  if (length === 0) {
    return '';
  }
  const isPosix = separator === '/';
  let endIndex = length;
  // drop trailing separator (if there is one)
  const lastCharCode = filepath.charCodeAt(length - 1);
  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  }

  // Find last occurence of separator
  let lastIndex = -1;
  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1);
    // handle special case of root path like 'C:' or 'C:\\'
    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  }

  // Take from last occurrence of separator to end of string (or beginning to end if not found)
  const base = filepath.slice(lastIndex + 1, endIndex);

  // drop trailing extension (if specified)
  if (ext === undefined) {
    return base;
  }
  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}

/**
 * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
 *
 * When multiple, sequential path segment separation characters are found (e.g.
 * / on POSIX and either \ or / on Windows), they are replaced by a single
 * instance of the platform-specific path segment separator (/ on POSIX and \
 * on Windows). Trailing separators are preserved.
 *
 * If the path is a zero-length string, '.' is returned, representing the
 * current working directory.
 *
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath  input file path
 * @return {string} [description]
 */
function normalize(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  if (filepath.length === 0) {
    return '.';
  }

  // Windows can handle '/' or '\\' and both should be turned into separator
  const isWindows = separator === '\\';
  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }
  const hadLeading = filepath.startsWith(separator);
  // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash
  const isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  const hadTrailing = filepath.endsWith(separator);
  const parts = filepath.split(separator);
  const result = [];
  for (const segment of parts) {
    if (segment.length !== 0 && segment !== '.') {
      if (segment === '..') {
        result.pop(); // FIXME: What if this goes above root? Should we throw an error?
      } else {
        result.push(segment);
      }
    }
  }
  let normalized = hadLeading ? separator : '';
  normalized += result.join(separator);
  if (hadTrailing) {
    normalized += separator;
  }
  if (isUNC) {
    normalized = '\\' + normalized;
  }
  return normalized;
}

/**
 * [assertSegment description]
 * @param  {*} segment [description]
 * @return {void}         [description]
 */
function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError(`Path must be a string. Received ${segment}`);
  }
}

/**
 * The `path.join()` method joins all given path segments together using the
 * platform-specific separator as a delimiter, then normalizes the resulting path.
 * Zero-length path segments are ignored. If the joined path string is a zero-
 * length string then '.' will be returned, representing the current working directory.
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       The joined filepath
 */
function join(separator, paths) {
  const result = [];
  // naive impl: just join all the paths with separator
  for (const segment of paths) {
    assertSegment(segment);
    if (segment.length !== 0) {
      result.push(segment);
    }
  }
  return normalize(separator, result.join(separator));
}

/**
 * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       [description]
 */
function resolve(separator, paths) {
  let resolved = '';
  let hitRoot = false;
  const isPosix = separator === '/';
  // go from right to left until we hit absolute path/root
  for (let i = paths.length - 1; i >= 0; i--) {
    const segment = paths[i];
    assertSegment(segment);
    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment
    if (isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  }
  // if we didn't hit root, prepend cwd
  if (!hitRoot) {
    resolved = (global.process ? process.cwd() : '/') + separator + resolved;
  }
  const normalized = normalize(separator, resolved);
  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    }
    // otherwise trim trailing separator
    return normalized.slice(0, normalized.length - 1);
  }
  return normalized;
}

/**
 * The `path.relative()` method returns the relative path `from` from to `to` based
 * on the current working directory. If from and to each resolve to the same
 * path (after calling `path.resolve()` on each), a zero-length string is returned.
 *
 * If a zero-length string is passed as `from` or `to`, the current working directory
 * will be used instead of the zero-length strings.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string} from [description]
 * @param  {string} to   [description]
 * @return {string}      [description]
 */
function relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');
  if (from === to) {
    return '';
  }
  from = resolve(separator, [from]);
  to = resolve(separator, [to]);
  if (from === to) {
    return '';
  }

  // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;
  let upCount = 0;
  let remainingPath = '';
  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    }
    // FIXME: Break/throw if we hit bad edge case of no common root!
    from = dirname(separator, from);
    upCount++;
  }
  // remove leading separator from remainingPath if there is any
  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }
  return ('..' + separator).repeat(upCount) + remainingPath;
}

/**
 * The `path.parse()` method returns an object whose properties represent
 * significant elements of the path. Trailing directory separators are ignored,
 * see `path.sep`.
 *
 * The returned object will have the following properties:
 *
 * - dir <string>
 * - root <string>
 * - base <string>
 * - name <string>
 * - ext <string>
 * @param  {string} separator platform-specific file separator
 * @param  {string} filepath [description]
 * @return {object}
 */
function parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: ''
  };
  const length = filepath.length;
  if (length === 0) {
    return result;
  }

  // Cheat and just call our other methods for dirname/basename/extname?
  result.base = basename(separator, filepath);
  result.ext = extname(separator, result.base);
  const baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  const toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!
  const firstCharCode = filepath.charCodeAt(0);
  // both win32 and POSIX return '/' root
  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  }
  // we're done with POSIX...
  if (separator === '/') {
    return result;
  }
  // for win32...
  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  }
  // check for C: style root
  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      const thirdCharCode = filepath.charCodeAt(2);
      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    }
    // nope, just C:, no trailing separator
    result.root = filepath.slice(0, 2);
  }
  return result;
}

/**
 * The `path.format()` method returns a path string from an object. This is the
 * opposite of `path.parse()`.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {object} pathObject object of format returned by `path.parse()`
 * @param  {string} pathObject.dir directory name
 * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
 * @param  {string} pathObject.base file basename
 * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
 * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
 * @return {string}
 */
function format(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;

  // append base to root if `dir` wasn't specified, or if
  // dir is the root
  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return `${pathObject.root || ''}${base}`;
  }
  // combine dir + / + base
  return `${pathObject.dir}${separator}${base}`;
}

/**
 * On Windows systems only, returns an equivalent namespace-prefixed path for
 * the given path. If path is not a string, path will be returned without modifications.
 * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
 * @param  {string} filepath [description]
 * @return {string}          [description]
 */
function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }
  if (filepath.length === 0) {
    return '';
  }
  const resolvedPath = resolve('\\', [filepath]);
  const length = resolvedPath.length;
  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }
  const firstCharCode = resolvedPath.charCodeAt(0);
  // if start with '\\\\', prefix with UNC root, drop the slashes
  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      const thirdChar = resolvedPath.charAt(2);
      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }
    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }
  return filepath;
}
const Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function () {
    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
      paths[_key] = arguments[_key];
    }
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(false, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function () {
    for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      paths[_key2] = arguments[_key2];
    }
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath
};
const PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function () {
    for (var _len3 = arguments.length, paths = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      paths[_key3] = arguments[_key3];
    }
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(true, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function () {
    for (var _len4 = arguments.length, paths = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      paths[_key4] = arguments[_key4];
    }
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: function (filepath) {
    return filepath; // no-op
  }
};

const path = PosixPath;
path.win32 = Win32Path;
path.posix = PosixPath;

const isAndroid$1 = Ti.Platform.osname === 'android';
const isIOS = !isAndroid$1 && true;
const PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};

// default implementations
const OS = {
  EOL: '\n',
  arch: () => process.arch,
  constants: PosixConstants,
  cpus: () => {
    const count = Ti.Platform.processorCount;
    const array = [];
    for (let i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      });
    }
    return array;
  },
  endianness: () => {
    // TODO: Cache the value!
    const result = Ti.Codec.getNativeByteOrder();
    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }
    return 'BE';
  },
  freemem: () => Ti.Platform.availableMemory,
  getPriority: () => 0,
  // fake it
  homedir: () => Ti.Filesystem.applicationDataDirectory,
  // fake it
  hostname: () => Ti.Platform.address,
  // fake it
  loadavg: () => [0, 0, 0],
  // fake it
  networkInterfaces: () => {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: () => process.platform,
  release: () => Ti.Platform.version,
  setPriority: () => {},
  // no-op, fake it
  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: () => Ti.Filesystem.tempDirectory,
  /**
   * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
   * @return {integer} [description]
   */
  totalmem: () => Ti.Platform.totalMemory,
  type: () => 'Unknown',
  // overridden per-platform at bottom
  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: () => Ti.Platform.uptime,
  userInfo: () => {
    // fake it!
    return {
      uid: -1,
      gid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null
    };
  }
};

// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)
if (isIOS) {
  OS.type = () => 'Darwin';

  // Now a giant hack for looking up CPU info for OS.cpus() on iOS
  // https://www.theiphonewiki.com/wiki/List_of_iPhones
  const AppleMap = {
    // iPhone 12 Pro Max
    'iPhone13,4': ['Apple A14 Bionic @ 2.99 GHz', 2990],
    // iPhone 12 Pro
    'iPhone13,3': ['Apple A14 Bionic @ 2.99 GHz', 2990],
    // iPhone 12
    'iPhone13,2': ['Apple A14 Bionic @ 2.99 GHz', 2990],
    // iPhone 12 mini
    'iPhone13,1': ['Apple A14 Bionic @ 2.99 GHz', 2990],
    // iPhone SE (2nd gen)
    'iPhone12,8': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11 Pro Max
    'iPhone12,5': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11 Pro
    'iPhone12,3': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11
    'iPhone12,1': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone XR
    'iPhone11,8': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone XS Max
    'iPhone11,6': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    'iPhone11,4': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone XS
    'iPhone11,2': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone X
    'iPhone10,6': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,3': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 8 Plus
    'iPhone10,5': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,2': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 8
    'iPhone10,4': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,1': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 7 Plus
    'iPhone9,4': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    'iPhone9,2': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    // iPhone 7
    'iPhone9,3': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    'iPhone9,1': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    // iPhone SE
    'iPhone8,4': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6s Plus
    'iPhone8,2': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6s
    'iPhone8,1': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6 Plus
    'iPhone7,1': ['Apple A8 Typhoon @ 1.38 GHz', 1380],
    // iPhone 6
    'iPhone7,2': ['Apple A8 Typhoon @ 1.38 GHz', 1380],
    // iPhone 5s
    'iPhone6,2': ['Apple A7 Cyclone @ 1.3 GHz', 1300],
    'iPhone6,1': ['Apple A7 Cyclone @ 1.3 GHz', 1300],
    // iPhone 5c
    'iPhone5,4': ['Apple A6 Swift @ 1.2 GHz', 1200],
    'iPhone5,3': ['Apple A6 Swift @ 1.2 GHz', 1200],
    // iPhone 5
    'iPhone5,1': ['Apple A6 Swift @ 1.2 GHz', 1200],
    'iPhone5,2': ['Apple A6 Swift @ 1.2 GHz', 1200],
    // iPhone 4s
    'iPhone4,1': ['Apple A5 @ 800 MHz', 800],
    // iPhone 4
    'iPhone3,3': ['Apple A4 @ 800 MHz', 800],
    'iPhone3,2': ['Apple A4 @ 800 MHz', 800],
    'iPhone3,1': ['Apple A4 @ 800 MHz', 800],
    // iPhone 3GS
    'iPhone2,1': ['Samsung S5L8920 @ 620 MHz', 620],
    // iPhone 3G
    'iPhone1,2': ['Samsung S5L8900 @ 412 MHz', 412],
    // iPhone
    'iPhone1,1': ['Samsung S5L8900 @ 412 MHz', 412],
    // ////// iPads
    // https://www.theiphonewiki.com/wiki/List_of_iPads
    // https://en.wikipedia.org/wiki/IPad
    // iPad Pro (4th gen)
    'iPad8,12': ['Apple A12Z @ 2.49 GHz', 2490],
    'iPad8,11': ['Apple A12Z @ 2.49 GHz', 2490],
    // iPad mini (5th gen)
    'iPad11,1': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    'iPad11,2': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPad Air (3rd gen)
    'iPad11,3': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    'iPad11,4': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPad Pro (12.9" 3rd gen)
    'iPad8,8': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,7': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,6': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,5': ['Apple A12X @ 2.49 GHz', 2490],
    // iPad Pro (11")
    'iPad8,4': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,3': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,2': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,1': ['Apple A12X @ 2.49 GHz', 2490],
    // iPad (7th gen)
    'iPad7,11': ['Apple A10 @ 2.31 GHz', 2310],
    'iPad7,12': ['Apple A10 @ 2.31 GHz', 2310],
    // iPad (6th gen)
    'iPad7,6': ['Apple A10 @ 2.31 GHz', 2310],
    // FIXME: Wikipedia says 2.34 GHz
    'iPad7,5': ['Apple A10 @ 2.31 GHz', 2310],
    // iPad Pro (10.5")
    'iPad7,4': ['Apple A10X @ 2.38 GHz', 2380],
    'iPad7,3': ['Apple A10X @ 2.38 GHz', 2380],
    // iPad Pro (12.9" 2nd gen)
    'iPad7,2': ['Apple A10X @ 2.38 GHz', 2380],
    'iPad7,1': ['Apple A10X @ 2.38 GHz', 2380],
    // iPad (5th gen)
    'iPad6,12': ['Apple A9 @ 1.85 GHz', 1850],
    'iPad6,11': ['Apple A9 @ 1.85 GHz', 1850],
    // iPad Pro (12.9" 1st gen)
    'iPad6,8': ['Apple A9X @ 2.24 GHz', 2240],
    'iPad6,7': ['Apple A9X @ 2.24 GHz', 2240],
    // iPad Pro (9.7")
    'iPad6,4': ['Apple A9X @ 2.16 GHz', 2160],
    'iPad6,3': ['Apple A9X @ 2.16 GHz', 2160],
    // iPad Air 2
    'iPad5,4': ['Apple A8X @ 1.5 GHz', 1500],
    'iPad5,3': ['Apple A8X @ 1.5 GHz', 1500],
    // iPad Mini 4
    'iPad5,2': ['Apple A8 @ 1.49 GHz', 1490],
    'iPad5,1': ['Apple A8 @ 1.49 GHz', 1490],
    // iPad Mini 3
    'iPad4,9': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,8': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,7': ['Apple A7 @ 1.3 GHz', 1300],
    // iPad Mini 2
    'iPad4,6': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,5': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,4': ['Apple A7 @ 1.3 GHz', 1300],
    // iPad Air 2
    'iPad4,3': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    'iPad4,2': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    'iPad4,1': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    // iPad (4th gen)
    'iPad3,6': ['Apple A6X @ 1.4 GHz', 1400],
    'iPad3,5': ['Apple A6X @ 1.4 GHz', 1400],
    'iPad3,4': ['Apple A6X @ 1.4 GHz', 1400],
    // iPad (3rd gen)
    'iPad3,3': ['Apple A5X @ 1 GHz', 1000],
    'iPad3,2': ['Apple A5X @ 1 GHz', 1000],
    'iPad3,1': ['Apple A5X @ 1 GHz', 1000],
    // iPad Mini
    'iPad2,7': ['Apple A5 Rev A @ 1 GHz', 1000],
    'iPad2,6': ['Apple A5 Rev A @ 1 GHz', 1000],
    'iPad2,5': ['Apple A5 Rev A @ 1 GHz', 1000],
    // iPad 2
    'iPad2,4': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,3': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,2': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,1': ['Apple A5 @ 1 GHz', 1000],
    // iPad 3G
    'iPad1,2': ['Apple A4 @ 1 GHz', 1000],
    // iPad
    'iPad1,1': ['Apple A4 @ 1 GHz', 1000]
  };

  /**
   * [cpuModel description]
   * @param  {string} model [description]
   * @return {array}       [description]
   */
  const cpuModelAndSpeed = (model) => {
    const trimmed = model.replace(' (Simulator)', '').trim();
    return AppleMap[trimmed] || ['Unknown', 0];
  };
  // override cpus impl
  OS.cpus = () => {
    // TODO: Cache the result!
    const count = Ti.Platform.processorCount;
    const modelAndSpeed = cpuModelAndSpeed(Ti.Platform.model);
    const array = [];
    for (let i = 0; i < count; i++) {
      array.push({
        model: modelAndSpeed[0],
        speed: modelAndSpeed[1],
        times: {}
      });
    }
    return array;
  };
} else if (isAndroid$1) {
  OS.cpus = () => Ti.Platform.cpus();
  OS.type = () => 'Linux';
}

const tty = {
  isatty: () => false,
  ReadStream: () => {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: () => {
    throw new Error('tty.WriteStream is not implemented');
  }
};

const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const util = {
  format: format$1,
  formatWithOptions,
  inspect,
  isArray: Array.isArray,
  isBoolean: (value) => typeof value === 'boolean',
  isBuffer: BufferModule.Buffer.isBuffer,
  isFunction: (value) => typeof value === 'function',
  isNull: (value) => value === null,
  isNullOrUndefined: (value) => value === undefined || value === null,
  isNumber: (value) => typeof value === 'number',
  isObject: (value) => value !== null && typeof value === 'object',
  isPrimitive: (value) => typeof value !== 'object' && typeof value !== 'function' || value === null,
  isString: (value) => typeof value === 'string',
  isSymbol: (value) => typeof value === 'symbol',
  isUndefined: (value) => value === undefined,
  isRegExp: isRegExp,
  isDate: isDate,
  isError: (e) => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,
  log: (string) => {
    const date = new Date();
    const time = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
    // Produces output like: "21 Feb 10:04:23 - message"
    console.log(`${date.getDate()} ${MONTHS[date.getMonth()]} ${time} - ${string}`);
  },
  print: function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return console.log(args.join(''));
  },
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return console.log(args.join('\n'));
  },
  error: function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return console.error(args.join('\n'));
  },
  debug: (string) => console.error(`DEBUG: ${string}`),
  types
};

/**
 * @param {Function} constructor subclass
 * @param {Function} superConstructor base class
 * @returns {void}
 */
util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor
  });
  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};

/**
 * @param {Function} original original function to wrap which is expected to have a final callback argument
 * @returns {Function} function that returns a Promise
 */
util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');
  function wrapped() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return new Promise((resolve, reject) => {
      original.call(this, ...args, (err, result) => {
        if (err) {
          return reject(err);
        }
        return resolve(result);
      });
    });
  }
  // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks
  return wrapped;
};

/**
 * @param {Function} original original function to convert from async/Promise return value to a callback style
 * @returns {Function} wrapped function
 */
util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');
  function wrapped() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    const callback = args.pop();
    const promise = original.apply(this, args);
    promise.then((result) => {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch((err) => {
      if (!err) {
        const wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }
      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};

/**
 * @param {Function} func function to deprecate/wrap
 * @param {string} string message to give when deprecation warning is emitted
 * @param {string} code deprecation code to use to group warnings
 * @returns {Function} wrapped function
 */
util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  }
  // TODO: Support `code` argument by tracking a map of codes we've warned about
  function wrapped() {
    let warned = false;
    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return func.apply(this, args);
  }
  return wrapped;
};
// TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?
const noop = () => {};
util.debuglog = () => {
  return noop;
};

const DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:'
};

// Fake enums to use internally
const COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2
};
const STRICTNESS = {
  Strict: 0,
  Loose: 1
};
class AssertionError extends Error {
  constructor(options) {
    let {
      actual,
      expected,
      message,
      operator
    } = options;
    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = `${DEFAULT_MESSAGES[operator]}\n\n`;
    }
    super(message);
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    this.generatedMessage = !message;
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
  }
}

// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?

const assert = (value, message) => assert.ok(value, message);
assert.AssertionError = AssertionError;
assert.ok = function () {
  const value = arguments.length <= 0 ? undefined : arguments[0];
  if (value) {
    return;
  }
  let message = arguments.length <= 1 ? undefined : arguments[1];
  let generatedMessage = false;

  // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so
  if (arguments.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }
  const err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '=='
  });
  err.generatedMessage = generatedMessage;
  throw err;
};
function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }
  throw new AssertionError(obj);
}
assert.equal = (actual, expected, message) => {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'equal'
  });
};
assert.strictEqual = (actual, expected, message) => {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual'
  });
};
assert.notEqual = (actual, expected, message) => {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual'
  });
};
assert.notStrictEqual = (actual, expected, message) => {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual'
  });
};
const isPrimitive = (value) => {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};

/**
 * @param {Map} actual map we are comparing
 * @param {Map} expected map we're comparing against
 * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */
function compareMaps(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()
  for (const [key, value] of actual) {
    if (typeof key === 'object' && key !== null) {
      // non-null object. We need to do our own checking, not use get()/has()
      looseChecks.add(key);
    } else {
      // handle "primitives"
      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
        // yay! a nice easy match - both key and value matched exactly - move on
        continue;
      }
      if (strictness === STRICTNESS.Strict) {
        // if we didn't match key/value perfectly in strict mode, fail right away
        return false;
      }

      // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again
      looseChecks.add(key);
    }
  }
  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  }

  // only go through the second Map once!
  for (const [expectedKey, expectedValue] of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
      return false;
    }

    // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!
    let found = false;
    for (const key of looseChecks) {
      // if both key and value matches
      if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {
        found = true;
        looseChecks.delete(key); // remove from our looseChecks Set since we already matched it
        break;
      }
    }
    // if not found, we failed to match
    if (!found) {
      return false;
    }
  }
  // did we leave un-matched keys? if so, fail
  return looseChecks.size === 0;
}

/**
 * @param {Set} actual map we are comparing
 * @param {Set} expected map we're comparing against
 * @param {strictness.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */
function compareSets(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()
  for (const value of actual) {
    if (typeof value === 'object' && value !== null) {
      // non-null object. We need to do our own checking, not use has()
      looseChecks.add(value);
    } else if (!expected.has(value)) {
      // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
      // so may need to special case that here, that'd have to be in an else below (since has will return true here)

      if (strictness === STRICTNESS.Strict) {
        // failed "same-value" match for primitive in strict mode, so fail right away
        return false;
      }

      // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
      // add to set of values to check more thoroughly
      looseChecks.add(value);
    }
  }
  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  }

  // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!
  for (const expectedValue of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
      return false;
    }
    let found = false;
    for (const object of looseChecks) {
      if (deepEqual(object, expectedValue, strictness, references)) {
        found = true; // found a match!
        looseChecks.delete(object); // remove from our looseChecks Set since we matched it
        break;
      }
    }
    // if not found, we failed to match
    if (!found) {
      return false;
    }
  }

  // did we leave un-matched values? if so, fail
  return looseChecks.size === 0;
}

/**
 * @param {*} actual value we are comparing
 * @param {*} expected values we're comparing against
 * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
 * @param {object} [references] optional object to keep track of circular references in the hierarchy
 * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
 * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
 * @param {number} [references.depth] The current depth of the hierarchy
 * @returns {boolean}
 */
function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  }

  // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc

  // Type tags of objects should be the same
  const actualTag = Object.prototype.toString.call(actual);
  const expectedTag = Object.prototype.toString.call(expected);
  if (actualTag !== expectedTag) {
    return false;
  }

  // [[Prototype]] of objects are compared using the Strict Equality Comparison.
  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    const actualPrototype = Object.getPrototypeOf(actual);
    const expectedPrototype = Object.getPrototypeOf(expected);
    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }
  let comparison = COMPARE_TYPE.Object;
  if (util.types.isRegExp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    }
    // continue on to check properties...
  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    }
    // continue on to check properties...
  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    }
    // continue on to check properties...
  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    }
    // continue on to check properties...
  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    }
    // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!
    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false;
      // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    }
    // continue on to check properties...
  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }
    comparison = COMPARE_TYPE.Set;
    // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }
    comparison = COMPARE_TYPE.Map;
    // continue on to check properties...
  }

  // Now iterate over properties and compare them!
  const actualKeys = Object.keys(actual); // for an array, this will return the indices that have values
  const expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties
  if (actualKeys.length !== expectedKeys.length) {
    return false;
  }

  // Are they the same keys? If one is missing, then no, fail right away
  if (!actualKeys.every((key) => Object.prototype.hasOwnProperty.call(expected, key))) {
    return false;
  }

  // Don't check own symbols when doing "loose"
  if (strictness === STRICTNESS.Strict) {
    const actualSymbols = Object.getOwnPropertySymbols(actual);
    const expectedSymbols = Object.getOwnPropertySymbols(expected);

    // Must have same number of symbols
    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }
    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      for (const key of actualSymbols) {
        const actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
        const expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);
        if (actualIsEnumerable !== expectedIsEnumerable) {
          return false; // they differ on whetehr symbol is enumerable, fail!
        } else if (actualIsEnumerable) {
          // it's enumerable, add to keys to check
          actualKeys.push(key);
          expectedKeys.push(key);
        }
      }
    }
  }

  // Avoid circular references!
  // Record map from objects to depth in the hierarchy
  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0
    };
  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    const memoizedActual = references.actual.get(actual);
    if (memoizedActual !== undefined) {
      const memoizedExpected = references.expected.get(expected);
      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }
    references.depth++;
  }
  // store the object -> depth mapping
  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth);

  // When comparing Maps/Sets, compare elements before custom properties
  let result = true;
  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }
  if (result) {
    // Now loop over keys and compare them to each other!
    for (const key of actualKeys) {
      if (!deepEqual(actual[key], expected[key], strictness, references)) {
        result = false;
        break;
      }
    }
  }
  // wipe the object to depth mapping for these objects now
  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}
assert.deepStrictEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual'
    });
  }
};
assert.notDeepStrictEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual'
    });
  }
};
assert.deepEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual'
    });
  }
};
assert.notDeepEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual'
    });
  }
};
assert.fail = function () {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Failed';
  return throwError({
    message
  });
};
const NO_EXCEPTION = {};
function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION;
}
function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}
async function executePromise(fn) {
  let promise;
  const fnType = typeof fn;
  if (fnType === 'function') {
    promise = fn();
    if (!isPromiseLike(promise)) {
      throw new TypeError(`Expected instanceof Promise to be returned from the "fn" function but got ${typeof promise}`);
    }
  } else {
    if (!isPromiseLike(fn)) {
      throw new TypeError(`The "fn" argument must be of type Function or Promise. Received type ${fnType}`);
    }
    promise = fn;
  }
  try {
    await promise;
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION;
}
assert.throws = (fn, error, message) => {
  const actual = execute(fn);
  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws'
    });
    return;
  }

  // They didn't specify how to validate, so just roll with it
  if (!error) {
    return;
  }
  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.rejects = async function (asyncFn, error, message) {
  const actual = await executePromise(asyncFn);
  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'rejects'
    });
    return;
  }

  // They didn't specify how to validate, so just roll with it
  if (!error) {
    return;
  }
  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.doesNotThrow = (fn, error, message) => {
  const actual = execute(fn);
  // no Error, just return
  if (actual === NO_EXCEPTION) {
    return;
  }

  // They didn't specify how to validate, so just re-throw
  if (!error) {
    throw actual;
  }

  // If error matches expected, throw an AssertionError
  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}`
    });
    return;
  }
  // doesn't match, re-throw
  throw actual;
};
assert.doesNotReject = async function (fn, error, message) {
  const actual = await executePromise(fn);
  // no Error, just return
  if (actual === NO_EXCEPTION) {
    return;
  }

  // They didn't specify how to validate, so just re-throw
  if (!error) {
    throw actual;
  }

  // If error matches expected, throw an AssertionError
  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}`
    });
    return;
  }
  // doesn't match, re-throw
  throw actual;
};

/**
 * @param {Error} actual the actual Error generated by the wrapped function/block
 * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
 * @param {string} [message] custom message to append
 * @returns {boolean} true if the Error matches the expected value/object
 */
function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegExp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    }

    // Test properties (`expected` is either a generic Object or an Error instance)
    const keys = Object.keys(expected);
    // If we're testing against an instance of an Error, we need to hack in name/message properties.
    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (const key of keys) {
      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual'
            });
          } catch (err) {
            message = err.message;
          }
        }
        throwError({
          actual,
          expected,
          message,
          operator: 'throws'
        });
        return false;
      }
    }
    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    }

    // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail
    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    }

    // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received
    return expected.call({}, actual);
  }
  return false;
}
assert.ifError = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  throwError({
    actual: value,
    expected: null,
    message: `ifError got unwanted exception: ${value}`,
    operator: 'ifError'
  });
};

// Create "strict" copy which overrides "loose" methods to call strict equivalents
assert.strict = (value, message) => assert.ok(value, message);
// "Copy" methods from assert to assert.strict!
Object.assign(assert.strict, assert);
// Override the "loose" methods to point to the strict ones
assert.strict.deepEqual = assert.deepStrictEqual;
assert.strict.notDeepEqual = assert.notDeepStrictEqual;
assert.strict.equal = assert.strictEqual;
assert.strict.notEqual = assert.notStrictEqual;
// hang strict off itself
assert.strict.strict = assert.strict;

/**
 * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.
 */
function StringDecoder() {
  let encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'utf8';
  this.encoding = encoding.toLowerCase();
  switch (this.encoding) {
    case 'utf8':
    case 'utf-8':
      this._impl = new Utf8StringDecoder();
      break;
    case 'ucs2':
    case 'ucs-2':
    case 'utf16-le':
    case 'utf16le':
      this._impl = new Utf16StringDecoder();
      break;
    case 'base64':
      this._impl = new Base64StringDecoder();
      break;
    default:
      this._impl = new StringDecoderImpl(this.encoding);
      break;}

}

/**
 * Returns any remaining input stored in the internal buffer as a string.
 * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution
 * characters appropriate for the character encoding.
 *
 * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.
 * @param {Buffer} [buffer] containing the bytes to decode.
 * @returns {string}
 */
StringDecoder.prototype.end = function end(buffer) {
  return this._impl.end(buffer);
};

/**
 * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or
 * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the
 * next call to stringDecoder.write() or stringDecoder.end().
 * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.
 * @returns {string}
 */
StringDecoder.prototype.write = function write(buffer) {
  if (typeof buffer === 'string') {
    return buffer;
  }
  // empty string for empty buffer
  if (buffer.length === 0) {
    return '';
  }
  return this._impl.write(buffer);
};

/**
 * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy
 */
class StringDecoderImpl {
  constructor() {
    let encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'utf8';
    this.encoding = encoding;
    this.byteCount = 0;
    this.charLength = 1;
  }

  // the actual underlying implementation!
  end(buffer) {
    if (buffer && buffer.length !== 0) {
      return this.write(buffer);
    }
    return '';
  }
  write(buffer) {
    if (buffer && buffer.length !== 0) {
      return buffer.toString(this.encoding); // single byte character encodings are a cinch
    }

    return ''; // no buffer, or empty
  }
}

// For multi-byte encodings, let's implement some base logic...
class MultiByteStringDecoderImpl extends StringDecoderImpl {
  constructor(encoding, bytesPerChar) {
    super(encoding);
    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer
  }

  /**
   * @typedef {Object} IncompleteCharObject
   * @property {integer} bytesNeeded bytes missing to complete the character
   * @property {integer} charLength bytes expected to complete the character
   * @property {integer} index location in the buffer where the character starts
   */

  /**
   * Given a Buffer, sees if we have an incomplete "character" at the end of it.
   * Returns info on that:
   * - bytesNeeded: 0-3, number of bytes still remaining
   * - charLength: expected number of bytes for the incomplete character
   * - index: index in the buffer where the incomplete character begins
   * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte "character" at the end
   */
  _checkIncompleteBytes(_buffer) {
    throw new Error('subclasses must override!');
  }
  _incompleteEnd() {
    throw new Error('subclasses must override!');
  }
  _incompleteBufferEmptied() {
    // typically we reset byte count back to 0 and character length to 1
    this.byteCount = 0;
    this.charLength = 1;
  }
  end(buffer) {
    let result = super.end(buffer);
    if (this.byteCount !== 0) {
      // we have incomplete characters!
      result += this._incompleteEnd();
    }
    this._incompleteBufferEmptied(); // reset our internals to "wipe" the incomplete buffer
    return result;
  }
  write(buffer) {
    // first let's see if we had some multi-byte character we didn't finish...
    let char = '';
    if (this.byteCount !== 0) {
      // we still needed some bytes to finish the character
      // How many bytes do we still need? charLength - bytes we received
      const left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 "left"

      const bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes
      // copy bytes from `buffer` to our incomplete buffer
      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);
      this.byteCount += bytesCopied; // record how many more bytes we copied...

      if (bytesCopied < left) {
        // still need more bytes to complete!
        return '';
      }

      // we were able to complete, yay!
      // grab the character we completed
      char = this.incomplete.slice(0, this.charLength).toString(this.encoding);
      // reset our counters
      this._incompleteBufferEmptied();
      // do we have any bytes left in this buffer?
      if (bytesCopied === buffer.length) {
        return char; // if not, return the character we finished!
      }
      // we still have more bytes, so slice the buffer up
      buffer = buffer.slice(bytesCopied, buffer.length);
    }

    // check this buffer to see if it indicates we need more bytes?
    const incompleteCharData = this._checkIncompleteBytes(buffer);
    if (incompleteCharData.bytesNeeded === 0) {
      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer
    }

    // ok so the buffer holds an incomplete character at it's end
    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'
    const incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete

    // copy from index of incomplete character to end of buffer
    const bytesToCopy = buffer.length - incompleteCharIndex;
    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);
    this.byteCount = bytesToCopy; // record how many bytes we actually copied

    if (bytesToCopy < buffer.length) {
      // buffer had bytes before the incomplete character
      // so smush any character we may have completed with any complete characters in the buffer
      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);
    }
    return char; // any now-completed character that was previously incomplete, possibly empty
  }
}

class Utf8StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf8', 4);
  }
  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    // FIXME: In Node, they check the last character first!
    // And they rely on Buffer#toString() to handle injecting the '\ufffd' character for busted multi-byte sequences!
    // iOS apparently just returns undefined in that special case and
    // Android differs here because we don't work backwards from the last char
    // Can we cheat here and...
    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198
    // - if we see a multi-byte character start, validate the next characters are continuation chars
    // - if they're not replace the sequence with '\ufffd', treat like that multi-byte character was "completed"

    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes
    // then we're at the mercy of the JS engine/platform code for handling that
    // Here's someone's hack there: https://gist.github.com/oleganza/997155

    // if buffer.length >= 3, check 3rd to last byte
    if (length >= 3) {
      let charLength = checkCharLengthForUTF8(buffer[length - 3]);
      if (charLength === 4) {
        return {
          bytesNeeded: 1,
          // we have 3 last bytes, need 4th
          index: length - 3,
          charLength: 4
        };
      }
    }
    // if buffer.length >= 2, check 2nd to last byte
    if (length >= 2) {
      let charLength = checkCharLengthForUTF8(buffer[length - 2]);
      if (charLength >= 3) {
        return {
          bytesNeeded: charLength - 2,
          // we have 2 bytes of whatever we need
          index: length - 2,
          charLength
        };
      }
    }
    // if buffer.length >= 1, check last byte
    if (length >= 1) {
      let charLength = checkCharLengthForUTF8(buffer[length - 1]);
      if (charLength >= 2) {
        return {
          bytesNeeded: charLength - 1,
          // we have 1 byte of whatever we need
          index: length - 1,
          charLength
        };
      }
    }
    // base case, no bytes needed - ends on complete character
    return {
      bytesNeeded: 0,
      index: length - 1,
      charLength: 1
    };
  }
  _incompleteEnd() {
    return '\ufffd'; // we replace the missing character with a special utf8 char
  }
}

class Utf16StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf16le', 4);
  }
  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 2;
    // ok, we have a multiple of 2 bytes
    if (modulo === 0) {
      // is the last byte a leading/high surrogate?
      const byte = buffer[buffer.length - 1];
      if (byte >= 0xD8 && byte <= 0xDB) {
        return {
          bytesNeeded: 2,
          charLength: 4,
          index: length - 2
        };
      }

      // we're good, not a surrogate, so we have our needed 2 bytes
      return {
        bytesNeeded: 0,
        charLength: 2
      };
    }

    // ok we have 1 byte left over, assume we need 2 to form the character
    return {
      bytesNeeded: 1,
      index: length - 1,
      charLength: 2
    };
  }
  _incompleteEnd() {
    // Just write out the last N bytes, hopefully the engine can handle it for us?
    return this.incomplete.toString('utf16le', 0, this.byteCount);
  }
}
class Base64StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('base64', 3);
    this.charLength = 3; // always 3!
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 3;
    // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer
    if (modulo === 0) {
      return {
        bytesNeeded: 0,
        charLength: 3
      };
    }

    // ok we have 1 or 2 bytes left over
    return {
      bytesNeeded: 3 - modulo,
      // always need 3, so if we have 1 left over -> need 2
      index: length - modulo,
      charLength: 3 // always need 3
    };
  }

  _incompleteBufferEmptied() {
    this.byteCount = 0;
    this.charLength = 3; // always 3!
  }

  _incompleteEnd() {
    // Just write out the last N bytes, it should insert the '=' placeholders
    // it's not really 'missing'/'incomplete', just needs placeholder insertion
    return this.incomplete.toString('base64', 0, this.byteCount);
  }
}
function checkCharLengthForUTF8(byte) {
  // 11110XXX => 1110 => 0x1E
  if (byte >> 3 === 0x1E) {
    return 4;
  }

  // 1110XXXX => 1110 => 0x1E
  if (byte >> 4 === 0x0E) {
    return 3;
  }

  // 110XXXXX => 110 => 0x06
  if (byte >> 5 === 0x06) {
    return 2;
  }
  return 1;
}
var StringDecoder$1 = {
  StringDecoder
};

const isAndroid = Ti.Platform.name === 'android';

// Keep track of printing out one-time warning messages for unsupported operations/options/arguments
const printedWarnings = {};
function oneTimeWarning(key, msg) {
  if (!printedWarnings[key]) {
    console.warn(msg);
    printedWarnings[key] = true;
  }
}
/**
 * Prints a one-time warning message that we do not support the given API and performs an effective no-op
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @returns {Function} no-op function
 */
function unsupportedNoop(moduleName, name) {
  return () => {
    const fqn = `${moduleName}.${name}`;
    oneTimeWarning(fqn, `"${fqn}" is not supported yet on Titanium and uses a no-op fallback.`);
    return undefined;
  };
}

/**
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @param {Function} callback async callback we call in a quick setTimeout
 */
function asyncUnsupportedNoop(moduleName, name, callback) {
  callback = maybeCallback(callback); // enforce we have a valid callback
  unsupportedNoop(moduleName, name)();
  setTimeout(callback, 1);
}

// Used to choose the buffer/chunk size when pumping bytes during copies
const COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?

// Keep track of integer -> FileStream mappings
const fileDescriptors = new Map();
let fileDescriptorCount = 4; // global counter used to report file descriptor integers

// Map file system access flags to Ti.Filesystem.MODE_* constants
const FLAGS_TO_TI_MODE = new Map();
FLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE);

// Common errors
const permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);
const noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);
const fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);
const notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);
const directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);
const illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);
const fs = {
  constants: {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1
  }
};
class Stats {
  constructor(path) {
    this._file = null;
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 0;
    this.uid = 0;
    this.gid = 0;
    this.rdev = 0;
    this.size = 0;
    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem
    this.blocks = 0;
    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;
    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);
    if (path) {
      this._file = getTiFileFromPathLikeValue(path);

      // TODO: use lazy getters here?
      this.ctime = this.birthtime = this._file.createdAt();
      this.atime = this.mtime = this._file.modifiedAt();
      this.atimeMs = this.atime.getTime();
      this.birthtimeMs = this.birthtime.getTime();
      this.ctimeMs = this.ctime.getTime();
      this.mtimeMs = this.mtime.getTime();
      this.size = this._file.size;
      this.blocks = Math.ceil(this.size / this.blksize);
      // TODO: Can we fake out the mode based on the readonly/writable/executable properties?
    }
  }

  isFile() {
    return this._file.isFile();
  }
  isDirectory() {
    return this._file.isDirectory();
  }
  isBlockDevice() {
    return false;
  }
  isCharacterDevice() {
    return false;
  }
  isSymbolicLink() {
    return this._file.symbolicLink;
  }
  isFIFO() {
    return false;
  }
  isSocket() {
    return false;
  }
}
fs.Stats = Stats;
class ReadStream {}
fs.ReadStream = ReadStream;
class WriteStream {}
fs.WriteStream = WriteStream;

/**
 * @callback statsCallback
 * @param {Error} err - Error if one occurred
 * @param {fs.Stats} stats - file stats
 */

/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 * @param {function} callback async callback
 */
fs.access = function (path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.constants.F_OK;
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.accessSync(path, mode);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};

/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 */
fs.accessSync = function (path) {
  let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : fs.constants.F_OK;
  // F_OK is just whether file exists or not, no permissions check
  // R_OK is read check
  // W_OK is write check
  // X_OK is execute check (acts like F_OK on Windows)
  const fileHandle = getTiFileFromPathLikeValue(path);
  if (!fileHandle.exists()) {
    throw noSuchFile('access', path);
  }

  // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?
  if (mode & fs.constants.W_OK && !fileHandle.writable) {
    throw permissionDenied('access', path);
  }
  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {
    throw permissionDenied('access', path);
  }
};

/**
 * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 * @param {Function} callback function to call back with error if failed
 */
fs.appendFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a'
  });
  fs.writeFile(file, data, options, callback);
};

/**
 * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 */
fs.appendFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a'
  });
  fs.writeFileSync(file, data, options);
  // TODO: Use Ti.Filesystem.File.append() instead?
};

fs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);
fs.chmodSync = unsupportedNoop('fs', 'chmodSync');
fs.chown = (path, uid, gid, callback) => asyncUnsupportedNoop('fs', 'chown', callback);
fs.chownSync = unsupportedNoop('fs', 'chownSync');

/**
 * Callback for functions that can only throw errors
 *
 * @callback errorCallback
 * @param {Error} [err] - Error thrown
 */

/**
 * @param {integer} fd file descriptor
 * @param {errorCallback} callback callback function
 */
fs.close = (fd, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.closeSync(fd);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};

/**
 * @param {integer} fd file descriptor
 */
fs.closeSync = (fd) => {
  const stream = streamForDescriptor(fd);
  stream.close();
};

// Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!
/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 * @param {errorCallback} callback callback called at end of operation
 */
fs.copyFile = function (src, dest, flags, callback) {
  if (typeof flags === 'function') {
    callback = flags;
    flags = 0;
  }
  callback = maybeCallback(callback);

  // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)
  const srcFile = Ti.Filesystem.getFile(src);
  const srcStream = srcFile.open(Ti.Filesystem.MODE_READ);
  const destFile = Ti.Filesystem.getFile(dest);
  const destStream = destFile.open(Ti.Filesystem.MODE_WRITE);
  pipe(srcStream, destStream, callback);
};

/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 */
fs.copyFileSync = function (src, dest) {
  let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const srcFile = Ti.Filesystem.getFile(src);
  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {
    throw fileAlreadyExists('copyFile', dest);
  }
  if (!srcFile.copy(dest)) {
    throw new Error(`Unable to copy ${src} to ${dest}`); // FIXME: What error should we give?
  }
};

// TODO: fs.createReadStream(path, options)
// /**
//  * @param {string|Buffer|URL} path path like
//  * @param {string|object} [options] options, if a string, it's the encoding
//  * @param {string} [options.flags='r'] See support of file system flags.
//  * @param {string} [options.encoding=null] encoding
//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored
//  * @param {integer} [options.mode=0o666] permissions to set if file is created
//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed
//  * @param {integer} [options.start] start index of range of bytes to read from file
//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file
//  * @param {integer} [options.highWaterMark=64 * 1024]
//  * @returns {fs.ReadStream}
//  */
// fs.createReadStream = (path, options) => {
// 	options = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });

// 	// FIXME: If options.fd, use that in place of path!
// 	const tiFile = getTiFileFromPathLikeValue(path);
// };
// TODO: fs.createWriteStream(path, options)

/**
 * @callback existsCallback
 * @param {boolean} exists - whether path exists
 */

/**
 * @param {string} path path to check
 * @param {existsCallback} callback callback function
 * @returns {void}
 */
fs.exists = function (path, callback) {
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(fs.existsSync(path));
  }, 1);
};

/**
 * @param {string} path path to check
 * @returns {boolean} whether a file or directory exists at that path
 */
fs.existsSync = function (path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
};
fs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);
fs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');
fs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);
fs.fchownSync = unsupportedNoop('fs', 'fchownSync');
fs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);
fs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');

/**
 * @param {integer} fd file descriptor
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {function} callback async callback function
 */
fs.fstat = (fd, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    let stats;
    try {
      stats = fs.fstatSync(fd, options);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, stats);
  }, 1);
};
/**
 * @param {integer} fd file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats} stats for file descriptor
 */
fs.fstatSync = (fd, _options) => {
  const path = pathForFileDescriptor(fd);
  return fs.statSync(path);
};

// TODO: Add versions of these APIs:
// fs.fsync(fd, callback)
// fs.fsyncSync(fd)
// fs.ftruncate(fd[, len], callback)
// fs.ftruncateSync(fd[, len])
// fs.futimes(fd, atime, mtime, callback)
// fs.futimesSync(fd, atime, mtime)
// fs.lchmod(path, mode, callback)
// fs.lchmodSync(path, mode)
// fs.lchown(path, uid, gid, callback)
// fs.lchownSync(path, uid, gid)
// fs.link(existingPath, newPath, callback)
// fs.linkSync(existingPath, newPath)

// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!
fs.lstat = (path, options, callback) => fs.stat(path, options, callback);
fs.lstatSync = (path, options) => fs.statSync(path, options);

/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 * @param {errorCallback} callback async callback
 */
fs.mkdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      recursive: false,
      mode: 0o777
    };
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.mkdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null);
  }, 1);
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 */
fs.mkdirSync = (path, options) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (typeof options === 'number') {
    options = {
      recursive: false,
      mode: options
    };
  } else {
    options = mergeDefaultOptions(options, {
      recursive: false,
      mode: 0o777
    });
  }
  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {
    if (tiFile.exists()) {
      // already existed!
      throw fileAlreadyExists('mkdir', path);
    }
    // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error
    throw noSuchFile('mkdir', path);
  }
};

/**
 * @callback tempDirCallback
 * @param {Error} err - Error if one occurred
 * @param {string} folder - generated folder name
 */

/**
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @param {tempDirCallback} callback async callback
 */
fs.mkdtemp = (prefix, options, callback) => {
  assertArgumentType(prefix, 'prefix', 'string');
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8'
  });

  // try to be all async
  const tryMkdtemp = () => {
    const generated = randomCharacters(6, options.encoding); // generate six random characters
    const path = `${prefix}${generated}`;
    fs.mkdir(path, 0o700, (err) => {
      if (err) {
        if (err.code === 'EEXIST') {
          // retry!
          setTimeout(tryMkdtemp, 1);
          return;
        }
        // bubble up error
        callback(err);
        return;
      }
      // succeeded! Hurray!
      callback(null, path);
    });
  };
  setTimeout(tryMkdtemp, 1);
};

/**
 * Creates a unique temporary directory.
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @returns {string} path to created directory
 */
fs.mkdtempSync = (prefix, options) => {
  assertArgumentType(prefix, 'prefix', 'string');
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8'
  });
  let retryCount = 0;
  const MAX_RETRIES = 100;
  while (retryCount < MAX_RETRIES) {
    const generated = randomCharacters(6, options.encoding); // generate six random characters
    const path = `${prefix}${generated}`;
    try {
      fs.mkdirSync(path, 0o700); // don't try recursive
      return path;
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e; // bubble up error
      }
      // name was not unique, so retry
      retryCount++;
    }
  }
  throw new Error(`Failed to create a unique directory name with prefix ${prefix}`);
};

/**
 * @callback fileDescriptorCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} fileDescriptor - generated file descriptor
 */

/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [mode=0o666] file mode to use when creating file
 * @param {fileDescriptorCallback} callback async callback
 */
fs.open = (path, flags, mode, callback) => {
  // flags and mode are optional, we need to handle if not supplied!
  if (typeof flags === 'function') {
    callback = flags;
    flags = 'r';
    mode = 0o666;
  } else if (typeof mode === 'function') {
    callback = mode;
    mode = 0o666;
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    let fileDescriptor;
    try {
      fileDescriptor = fs.openSync(path, flags, mode);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, fileDescriptor);
  }, 1);
};

/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [_mode=0o666] file mode to use when creating file
 * @returns {integer}
 */
fs.openSync = function (path) {
  let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'r';
  const tiFile = getTiFileFromPathLikeValue(path);
  if (!tiFile.exists()) {
    // TODO: Support creating file with specific mode
    oneTimeWarning('fs.openSync.mode', 'fs.openSync\'s mode parameter is unsupported in Titanium and will be ignored');
    if (!tiFile.createFile()) {
      // Oh crap, we failed to create the file. why?
      if (!tiFile.parent.exists()) {
        // parent does not exist!
        throw noSuchFile('open', path);
      }
      throw new Error(`failed to create file at path ${path}`);
    }
  } else if (flags) {
    // file/dir exists...
    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {
      // If user is trying to write or append and it's a directory, fail
      throw illegalOperationOnADirectory('open', path);
    }
    if (flags.length > 1 && flags.charAt(1) === 'x') {
      // If user has "exclusive" flag on, fail if file already exists
      throw fileAlreadyExists('open', path);
    }
  }
  const tiMode = FLAGS_TO_TI_MODE.get(flags);
  if (tiMode === undefined) {
    // TODO: Make use of common error type/code for this once we have internal/errors.js
    const err = new TypeError(`The value "${String(flags)}" is invalid for option "flags"`);
    err.code = 'ERR_INVALID_OPT_VALUE';
    throw err;
  }
  return createFileDescriptor(path, tiFile.open(tiMode));
};

/**
 * @callback readCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} bytesRead - number of bytes read
 * @param {Buffer} buffer buffer
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} position where to begin reading from in the file
 * @param {readCallback} callback async callback
 */
fs.read = (fd, buffer, offset, length, position, callback) => {
  callback = maybeCallback(callback);
  const tiFileStream = streamForDescriptor(fd);
  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  }
  // FIXME: Allow using position argument!
  if (position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }
  tiFileStream.read(buffer.toTiBuffer(), offset, length, (readObj) => {
    if (!readObj.success) {
      callback(new Error(readObj.error));
      return;
    }
    callback(null, readObj.bytesProcessed, buffer);
  });
};

/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} _position where to begin reading from in the file
 * @returns {integer} bytes read
 */
fs.readSync = (fd, buffer, offset, length, _position) => {
  const fileStream = streamForDescriptor(fd);
  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  }

  // FIXME: Allow using position argument!
  if (_position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }
  return fileStream.read(buffer.toTiBuffer(), offset, length);
};

/**
 * @callback filesCallback
 * @param {Error} err - Error if one occurred
 * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing
 */

/**
 * @param {string} path directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @param {filesCallback} callback async callback
 */
fs.readdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    let result;
    try {
      result = fs.readdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, result);
  }, 1);
};

/**
 * @param {string} filepath directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @returns {string[]|Buffer[]|fs.Dirent[]}
 */
fs.readdirSync = (filepath, options) => {
  const file = getTiFileFromPathLikeValue(filepath);
  if (!file.exists()) {
    throw noSuchFile('scandir', filepath);
  }
  if (!file.isDirectory()) {
    throw notADirectory('scandir', filepath);
  }
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8',
    withFileTypes: false
  });
  const listing = file.getDirectoryListing();
  if (options.withFileTypes === true) {
    // TODO: if options.withFileTypes === true, return fs.Dirent objects
    oneTimeWarning('fs.readdir\'s options.withFileTypes is unsupported by Titanium and strings will be returned');
  } else if (options.encoding === 'buffer') {
    return listing.map((name) => Buffer.from(name));
  }
  return listing;
};

/**
 * @callback readFilePostOpenCallback
 * @param {Error} err - Error if one occurred
 * @param {Ti.Buffer} buffer
 */
/**
 * @param {integer} fileDescriptor file descriptor
 * @param {readFilePostOpenCallback} callback async callback
 */
function readFilePostOpen(fileDescriptor, callback) {
  callback = maybeCallback(callback);
  fs.fstat(fileDescriptor, (err, stats) => {
    if (err) {
      callback(err);
      return;
    }
    const fileSize = stats.size;

    // Create a Ti.Buffer to read into
    const buffer = Ti.createBuffer({
      length: fileSize
    });

    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!
    const sourceStream = streamForDescriptor(fileDescriptor);
    Ti.Stream.readAll(sourceStream, buffer, (readAllObj) => {
      if (!readAllObj.success) {
        callback(new Error(readAllObj.error));
        return;
      }
      callback(null, buffer);
    });
  });
}

/**
 * @callback readFileCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} data
 */
/**
 * Asynchronously read entire contents of file
 * @param {string|Buffer|URL|integer} path filename or file descriptor
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @param {readFileCallback} callback async callback
 */
fs.readFile = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      encoding: null,
      flag: 'r'
    };
  } else {
    options = mergeDefaultOptions(options, {
      encoding: null,
      flag: 'r'
    });
  }
  callback = maybeCallback(callback);
  const wasFileDescriptor = typeof path === 'number';
  let fileDescriptor = path; // may be overriden later
  /**
   * @param {Error} err possible Error
   * @param {Ti.Buffer} buffer Ti.Buffer instance
   */
  const handleBuffer = (err, buffer) => {
    if (err) {
      callback(err);
      return;
    }

    // fs.closeSync if it was not originally a file descriptor
    if (!wasFileDescriptor) {
      fs.closeSync(fileDescriptor);
    }

    // TODO: trim buffer if we didn't read full size?

    callback(null, encodeBuffer(options.encoding, buffer));
  };
  if (!wasFileDescriptor) {
    fs.open(path, options.flag, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }
      fileDescriptor = fd;
      readFilePostOpen(fd, handleBuffer);
    });
  } else {
    readFilePostOpen(path, handleBuffer);
  }
};

/**
 * Returns the contents of the path.
 * @param {string|Buffer|URL|integer} path path to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @returns {string|Buffer} string if encoding is specified, otherwise Buffer
 */
fs.readFileSync = (path, options) => {
  options = mergeDefaultOptions(options, {
    encoding: null,
    flag: 'r'
  });
  const wasFileDescriptor = typeof path === 'number';
  const fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode

  const tiFileStream = streamForDescriptor(fileDescriptor);
  // Just use our own API that reads full stream in
  const buffer = Ti.Stream.readAll(tiFileStream);

  // fs.closeSync if it was not originally a file descriptor
  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }

  // TODO: trim buffer if we didn't read full size?

  return encodeBuffer(options.encoding, buffer);
};

// TODO: fs.readlink(path[, options], callback)
// TODO: fs.readlinkSync(path[, options])

/**
 * @callback realpathCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} resolvedPath the resolved path
 */
/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] optiosn object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @param {realpathCallback} callback async callback
 */
fs.realpath = (filepath, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8'
  });
  setTimeout(() => {
    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
    const result = path.normalize(filepath);
    fs.exists(result, (resultExists) => {
      if (resultExists) {
        if (options.encoding === 'buffer') {
          return callback(null, Buffer.from(result));
        }
        return callback(null, result);
      }

      // this path doesn't exist, try each segment until we find first that doesn't
      const segments = result.split(path.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?
      let partialFilePath = '';
      let index = 0;
      // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case
      if (segments[index].length === 0) {
        index++;
      }
      setTimeout(tryPath, 1);
      function tryPath() {
        if (index >= segments.length) {
          // don't run past end of segments, throw error for resolved path
          return callback(noSuchFile(result));
        }

        // grab next segment
        const segment = segments[index++];
        if (segment.length === 0) {
          // if it's an empty segment...
          // try again at next index
          return setTimeout(tryPath, 1);
        }

        // normal case
        partialFilePath += path.sep + segment;
        // check if path up to this point exists...
        fs.exists(partialFilePath, (partialExists) => {
          if (!partialExists) {
            // nope, throw the Error
            return callback(noSuchFile('lstat', partialFilePath));
          }
          // try again at next depth of dir tree
          setTimeout(tryPath, 1);
        });
      }
    });
  }, 1);
};
fs.realpath.native = (path, options, callback) => {
  fs.realpath(path, options, callback);
};

/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] options object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @returns {string|Buffer}
 */
fs.realpathSync = (filepath, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8'
  });
  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
  const result = path.normalize(filepath);
  if (!fs.existsSync(result)) {
    // this path doesn't exist, try each segment until we find first that doesn't
    const segments = result.split(path.sep);
    let partialFilePath = '';
    for (const segment of segments) {
      if (segment.length === 0) {
        continue;
      }
      partialFilePath += path.sep + segment;
      if (!fs.existsSync(partialFilePath)) {
        throw noSuchFile('lstat', partialFilePath);
      }
    }
  }
  if (options.encoding === 'buffer') {
    return Buffer.from(result);
  }
  return result;
};
fs.realpathSync.native = (path, options) => {
  fs.realpathSync(path, options);
};

/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 * @param {errorCallback} callback async callback
 */
fs.rename = (oldPath, newPath, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.renameSync(oldPath, newPath);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};

/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 */
fs.renameSync = (oldPath, newPath) => {
  const tiFile = getTiFileFromPathLikeValue(oldPath);
  // src doesn't actually exist?
  if (!tiFile.exists()) {
    const err = noSuchFile('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }
  const destFile = getTiFileFromPathLikeValue(newPath);
  if (destFile.isDirectory()) {
    // dest is a directory that already exists
    const err = illegalOperationOnADirectory('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }
  let tempPath;
  if (destFile.isFile()) {
    // destination file exists, we should overwrite
    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original
    tempPath = path.join(fs.mkdtempSync(path.join(Ti.Filesystem.tempDirectory, 'rename-')), path.basename(newPath));
    destFile.move(tempPath);
  }
  let success = false;
  try {
    success = tiFile.move(newPath);
  } finally {
    if (tempPath) {
      // we temporarily copied the existing destination to back it up...
      if (success) {
        // move worked, so we can wipe it away whenever...
        fs.unlink(tempPath, (_err) => {});
      } else {
        // move it back, because we failed!
        const tmpFile = getTiFileFromPathLikeValue(tempPath);
        tmpFile.move(newPath);
      }
    }
  }
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */
fs.rmdir = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.rmdirSync(path);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 */
fs.rmdirSync = (path) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (!tiFile.deleteDirectory(false)) {
    // do not delete contents!
    // we failed to delete, but why?
    // does it exist?
    if (!tiFile.exists()) {
      throw noSuchFile('rmdir', path);
    }
    // is it a file?
    if (tiFile.isFile()) {
      throw notADirectory('rmdir', path);
    }
    // is it not empty?
    const subFiles = tiFile.getDirectoryListing();
    if (subFiles && subFiles.length > 0) {
      throw directoryNotEmpty('rmdir', path);
    }
  }
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {statsCallback} callback async callback
 */
fs.stat = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(null, new fs.Stats(path));
  }, 1);
};
/**
 * @param {string|Buffer|URL|integer} path filepath or file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats}
 */
fs.statSync = (path, _options) => new fs.Stats(path);
fs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);
fs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');

/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 * @param {errorCallback} callback async callback
 */
fs.truncate = (path, len, callback) => {
  callback = maybeCallback(callback || len);
  if (typeof len !== 'number') {
    len = 0;
  }
  if (len <= 0) {
    fs.writeFile(path, '', callback); // empty the file
    return;
  }

  // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it
  fs.open(path, (err, fd) => {
    if (err) {
      return callback(err);
    }
    const buffer = Buffer.alloc(len);
    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {
      if (err) {
        fs.closeSync(fd);
        return callback(err);
      }
      fs.close(fd, (err) => {
        if (err) {
          return callback(err);
        }
        fs.writeFile(path, buffer, callback);
      });
    });
  });
};

/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 */
fs.truncateSync = function (path) {
  let len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (len <= 0) {
    // empty the file
    fs.writeFileSync(path, '');
    return;
  }

  // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it
  const fd = fs.openSync(path);
  const buffer = Buffer.alloc(len);
  fs.readSync(fd, buffer, 0, len, null);
  fs.closeSync(fd);
  fs.writeFileSync(path, buffer);
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */
fs.unlink = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.unlinkSync(path);
    } catch (err) {
      callback(err);
      return;
    }
    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 * @returns {undefined}
 */
fs.unlinkSync = (path) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (!tiFile.deleteFile()) {
    // we failed, but why?
    if (!tiFile.exists()) {
      throw noSuchFile('unlink', path);
    }
    if (tiFile.isDirectory()) {
      throw illegalOperationOnADirectory('unlink', path);
    }
  }
};
fs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');
fs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);
fs.utimesSync = unsupportedNoop('fs', 'utimesSync');
fs.watch = unsupportedNoop('fs', 'watch');
fs.watchFile = unsupportedNoop('fs', 'watchFile');

/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string|null} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 * @param {errorCallback} callback async callback
 */
fs.writeFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w'
  });

  // Turn into file descriptor
  const wasFileDescriptor = typeof file === 'number';
  let fileDescriptor = file; // may be overriden later
  const finish = (err) => {
    if (err) {
      callback(err);
      return;
    }
    if (wasFileDescriptor) {
      callback();
      return;
    }

    // fs.close if it was not originally a file descriptor
    fs.close(fileDescriptor, callback);
  };
  if (!wasFileDescriptor) {
    fs.open(file, options.flag, options.mode, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }
      fileDescriptor = fd;
      fs.write(fileDescriptor, data, finish);
    });
  } else {
    fs.write(fileDescriptor, data, finish);
  }
};

/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 */
fs.writeFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w'
  });

  // Turn into file descriptor
  const wasFileDescriptor = typeof file === 'number';
  const fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode);

  // if data is a string, make it a buffer first
  if (!Buffer.isBuffer(data)) {
    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!
  }

  fs.writeSync(fileDescriptor, data);

  // close if user didn't give us file descriptor
  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }
};

/**
 * @callback writeTiFileStreamCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 */

/**
 * @param {Ti.Filesystem.FileStream} tiFileStream file stream
 * @param {Buffer} buffer buffer we're writing
 * @param {writeTiFileStreamCallback} callback async callback
 */
function writeTiFileStream(tiFileStream, buffer, callback) {
  callback = maybeCallback(callback);
  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), (writeObj) => {
    if (!writeObj.success) {
      callback(new Error(writeObj.error));
      return;
    }
    callback(null, writeObj.bytesProcessed);
  });
}

/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write: Buffer or string
 * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)
 * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding
 * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string
 * @param {writeCallback} [callback] async callback (if Buffer)
 */
fs.write = (fd, buffer, offset, length, position, callback) => {
  const isBuffer = Buffer.isBuffer(buffer);
  if (isBuffer) {
    writeBuffer(fd, buffer, offset, length, position, callback);
  } else {
    writeString(fd, buffer, offset, length, position);
  }
};

/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write
 * @param {integer} [offset] offset from the beginning of the file where this data should be written
 * @param {string|integer} [length]  expected string encoding
 * @param {integer} [position] position
 * @returns {integer} number of bytes written
 */
fs.writeSync = (fd, buffer, offset, length, position) => {
  const isBuffer = Buffer.isBuffer(buffer);
  if (isBuffer) {
    return writeBufferSync(fd, buffer, offset, length);
  }
  return writeStringSync(fd, buffer, offset, length);
};

// TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?
// TODO: Add the fs.promises API!

// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)

// Helper functions
// --------------------------------------------------------

/**
 * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.
 */
class FileDescriptor {
  constructor(number, path, stream) {
    this.path = path;
    this.number = number;
    this.stream = stream;
  }
}

/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */
function pipe(srcStream, destStream, callback) {
  if (isAndroid) {
    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge
    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async
    pipeViaWriteStream(srcStream, destStream, callback);
    return;
  }
  // iOS has some... issues with writeStream calling the callback every iteration of the loop *and* at the end
  // it also doesn't play as expected when doing Ti.Stream.pump and Ti.Stream.write async each
  // it ends up doing all reads first and then all writes
  // so we have to hack here and do Ti.Stream.pump async, but each time the read callback happens we do a *sync* write inside it
  // See https://jira-archive.titaniumsdk.com/TIMOB-27321
  pipeViaPump(srcStream, destStream, callback);
}

/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */
function pipeViaWriteStream(srcStream, destStream, callback) {
  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, (result) => {
    if (!result.success) {
      return callback(new Error(result.error));
    }

    // Android will only call this at the end or error, so we can safely assume we're done here.
    // iOS will call per loop iteration, see https://jira-archive.titaniumsdk.com/TIMOB-27320
    callback();
  });
}

/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */
function pipeViaPump(srcStream, destStream, callback) {
  Ti.Stream.pump(srcStream, (obj) => {
    if (!obj.success) {
      return callback(new Error(obj.error)); // TODO: set code via writeObj.code?
    }

    if (obj.bytesProcessed === -1) {
      // reached EOF
      return callback();
    }

    // we read some segment of the input stream and have not reached EOF yet
    let bytesWritten = 0;
    let offset = 0;
    let length = obj.bytesProcessed;
    try {
      while (true) {
        // try to write all of the current buffer
        const bytesWrittenThisChunk = destStream.write(obj.buffer, offset, length);
        bytesWritten += bytesWrittenThisChunk;
        if (bytesWritten === obj.bytesProcessed) {
          // wrote same amount of bytes as we read, move on
          break;
        }
        // NOTE: This shouldn't ever happen because our APIs should write the entire byte array or fail, but just in case...
        // we didn't write it all, so move on to try and write the rest of buffer...
        offset = bytesWritten;
        length = obj.bytesProcessed - bytesWritten;
      }
    } catch (e) {
      return callback(e);
    }
  }, COPY_FILE_CHUNK_SIZE, true);
}

/**
 * @param {string|Buffer|URL} path file path
 * @param {Ti.Filesystem.FileStream} fileStream file stream
 * @returns {integer} file descriptor
 */
function createFileDescriptor(path, fileStream) {
  const pointer = fileDescriptorCount++; // increment global counter
  const fd = new FileDescriptor(pointer, path, fileStream);
  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the "descriptor"
  return pointer;
}

/**
 * @param {integer} fd file descriptor
 * @returns {Ti.Filesystem.FileStream} matching stream
 */
function streamForDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.stream;
}

/**
 * @param {integer} fd file descriptor
 * @returns {string} matching stream
 */
function pathForFileDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.path;
}

/**
 * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.
 * @param {*} options user-supplied options
 * @param {object} defaults defaults to use
 * @return {object}
 */
function mergeDefaultOptions(options, defaults) {
  if (options === null) {
    return defaults;
  }
  const optionsType = typeof options;
  switch (optionsType) {
    case 'undefined':
    case 'function':
      return defaults;
    case 'string':
      // Use copy of defaults but with encoding set to the 'options' value!
      const merged = Object.assign({}, defaults);
      merged.encoding = options;
      return merged;
    case 'object':
      return options;
    default:
      assertArgumentType(options, 'options', 'object');
      return null;
    // should never get reached
  }
}

/**
 * Enforces that we have a valid callback function. Throws TypeError if not.
 * @param {*} cb possible callback function
 * @returns {Function}
 * @throws {TypeError}
 */
function maybeCallback(cb) {
  if (typeof cb === 'function') {
    return cb;
  }
  const err = new TypeError(`Callback must be a function. Received ${cb}`);
  err.code = 'ERR_INVALID_CALLBACK';
  throw err;
}

/**
 * returns randomly generated characters of given length 1-16
 * @param {integer} length 1 - 16
 * @param {string} [_encoding='utf8'] encoding of the string generated
 * @returns {string}
 */
function randomCharacters(length) {
  // FIXME: use the encoding specified!
  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);
}
function makeError(code, message, errno, syscall, path) {
  const error = new Error(`${code}: ${message}, ${syscall} '${path}'`);
  error.errno = errno;
  error.syscall = syscall;
  error.code = code;
  error.path = path;
  return error;
}

/**
 * @param {string} encoding what we're encoding to
 * @param {Ti.Buffer} tiBuffer Ti.Buffer instance
 * @returns {Buffer} node-compatible Buffer instance
 */
function encodeBuffer(encoding, tiBuffer) {
  switch (encoding) {
    case 'buffer':
    case null:
    case undefined:
      // In this case we're always reading a file into a Ti.Buffer
      // Wrapping Ti.Buffer is super-slow and should really only be if we're going to write to it
      // Go the faster path by converting to ArrayBuffer and wrapping that
      // TODO: Explicitly release the blob after conversion?
      return Buffer.from(tiBuffer.toBlob().toArrayBuffer());
    default:
      // here' were converting to a string based on encoding. Internally our faster Buffer impl still delegates to Ti.Buffer in most cases
      // so I don't think there's much benefit from converting to ArrayBuffer first
      return Buffer.from(tiBuffer).toString(encoding);}

}

/**
 * @param {string|Buffer|URL} path file path
 * @return {Ti.Filesystem.File}
 */
function getTiFileFromPathLikeValue(path) {
  // This is a hack that is likely to work in most cases?
  // Basically assumes Buffer is holding a utf-8 string filename/path
  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator
  if (Buffer.isBuffer(path)) {
    path = path.toString(); // assumes utf-8 string
  }
  // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet
  assertArgumentType(path, 'path', 'string');
  return Ti.Filesystem.getFile(path);
}

/**
 * @callback writeBufferCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {Buffer} buffer - original Buffer being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {writeBufferCallback} callback async callback
 */
function writeBuffer(fd, buffer, offset, length, position, callback) {
  callback = maybeCallback(callback || position || length || offset);
  if (typeof offset !== 'number') {
    offset = 0;
  }
  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }
  if (typeof position !== 'number') {
    position = null;
  }
  // ok now what?
  const tiFileStream = streamForDescriptor(fd);
  // Make use of the buffer slice that's specified by offset/length
  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  }
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }
    callback(null, bytesProcessed, buffer);
  });
}

/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @returns {integer} number of bytes written
 */
function writeBufferSync(fd, buffer, offset, length, position) {
  if (typeof offset !== 'number') {
    offset = 0;
  }
  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }
  // ok now what?
  const tiFileStream = streamForDescriptor(fd);
  // Make use of the buffer slice that's specified by offset/length
  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  }
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  return tiFileStream.write(buffer.toTiBuffer());
}

/**
 * @callback writeStringCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {string} string - original string being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @param {writeStringCallback} [callback] async callback
 */
function writeString(fd, string, position, encoding, callback) {
  callback = maybeCallback(callback || encoding || position);
  // position could be: number, function (callback)
  if (typeof position !== 'number') {
    position = null;
  }
  // encoding could be: function (callback) or string
  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }
  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string
  const buffer = Buffer.from(string, encoding);
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }
    callback(null, bytesProcessed, string);
  });
}

/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @returns {integer} number of bytes written
 */
function writeStringSync(fd, string, position, encoding) {
  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }
  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string
  const buffer = Buffer.from(string, encoding);
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  return tiFileStream.write(buffer.toTiBuffer());
}

function Stream(_opts) {
  // FIXME: Can't call EventEmitter as a function!
  this._eventsToListeners = {};
  this._maxListeners = undefined;
  // EventEmitter.call(this, opts);
  // TODO: Provide more than an empty class?
}

Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
// Use util.inherits?

function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  }

  // TODO: readableState?

  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') {
      this._read = options.read;
    }
    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
  }
  Stream.call(this);
}
util.inherits(Readable, Stream);
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};
Readable.prototype._read = function (_n) {
  throw new Error('method not implemented: _read()');
};
function Writable(options) {
  const isDuplex = this instanceof Duplex;
  if (!isDuplex && !(this instanceof Writable)) {
    return new Writable(options);
  }
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') {
      this._write = options.write;
    }
    if (typeof options.writev === 'function') {
      this._writev = options.writev;
    }
    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
    if (typeof options.final === 'function') {
      this._final = options.final;
    }
  }
  Stream.call(this);
}
util.inherits(Writable, Stream);
function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }
  Readable.call(this, options);
  Writable.call(this, options);
  // TODO: Provide more than an empty class!
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      // this.once('end', onend);
    }
  }
}

util.inherits(Duplex, Readable);
// Copy Writable methods to Duplex (basically the odd double-inheritance)
const writableMethods = Object.keys(Writable.prototype);
for (let i = 0; i < writableMethods.length; i++) {
  const method = writableMethods;
  if (!Duplex.prototype[method]) {
    Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }
  Duplex.call(this, options);
  // TODO: Provide more than an empty class!
  if (options) {
    if (typeof options.transform === 'function') {
      this._transform = options.transform;
    }
    if (typeof options.flush === 'function') {
      this._flush = options.flush;
    }
  } // When the writable side finishes, then flush out anything remaining.

  // this.on('prefinish', prefinish);
}

util.inherits(Transform, Duplex);
Stream.Stream = Stream; // legacy compat
Stream.Transform = Transform;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;

// Load all the node compatible core modules
register('path', path);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert);
register('events', EventEmitter);
register('buffer', BufferModule);
register('string_decoder', StringDecoder$1);
register('fs', fs);
register('stream', Stream);

// Register require('buffer').Buffer as global
global.Buffer = BufferModule.Buffer;

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * Description:
 * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
 * The main intention of this feature is to allow JavaScript files to kick-off functionality or
 * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
 * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
 *
 * Use-Cases:
 * - Automatically kick-off analytics functionality on app startup.
 * - Ensure "Google Play Services" is installed/updated on app startup on Android.
 */

/**
 * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
 * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
 * This JSON file, if provided, must be in the same directory as this script.
 * @returns {string[]}
 * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
 * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
 * Returns null if JSON file was not found.
 */
function fetchScriptsFromJson() {
  const JSON_FILE_NAME = 'bootstrap.json';
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, `ti.internal/${JSON_FILE_NAME}`);
    if (jsonFile.exists()) {
      const settings = JSON.parse(jsonFile.read().text);
      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }
      return [];
    }
  } catch (error) {
    Ti.API.error(`Failed to read "${JSON_FILE_NAME}". Reason: ${error.message}`);
  }
  return null;
}

/**
 * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
 * @returns {Array.<string>}
 * Returns an array of require() compatible strings for each bootstrap found in the search.
 * Returns an empty array if no bootstrap files were found.
 */
function fetchScriptsFromResourcesDirectory() {
  const resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  const resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  const bootstrapScripts = [];
  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        const fileNameArray = file.getDirectoryListing();
        if (fileNameArray) {
          for (let index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        let bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }
  loadFrom(resourceDirectory);
  return bootstrapScripts;
}

/**
 * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
 * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
 */
function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  let bootstrapScripts = fetchScriptsFromJson();
  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  }

  // Do not continue if no bootstraps were found.
  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  }

  // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.
  bootstrapScripts.sort();

  // Loads all bootstrap scripts found.
  function loadBootstrapScripts(finished) {
    let bootstrapIndex = 0;
    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        const fileName = bootstrapScripts[bootstrapIndex];
        const bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require

        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.
        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        }

        // We're done with the current bootstrap. Time to load the next one.
        bootstrapIndex++;
      }

      // Invoke given callback to inform caller that all loading is done.
      finished();
    }
    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(() => doLoad(), 1);
    }
    doLoad();
  }

  // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().
  loadBootstrapScripts(finished);
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This script is loaded on app startup on all platforms. It is used to do the following:
 * - Provide consistent startup behavior between platforms, such as logging Titanium version.
 * - Load Titanium's core JavaScript extensions shared by all platforms.
 * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
 * - Load the app developer's main "app.js" script after doing all of the above.
 */

// Log the app name, app version, and Titanium version on startup.
Ti.API.info(`${Ti.App.name} ${Ti.App.version} (Powered by Titanium ${"12.7.1"}.${"ea857ddd2b"})`);
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app');

  // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.
  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFLEVBQUU7SUFDVkMsV0FBVyxFQUFFLEVBQUU7SUFDZkMsS0FBSyxFQUFFLENBQUM7SUFDUkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsR0FBRyxFQUFFLENBQUM7SUFDTkMsT0FBTyxFQUFFLEVBQUU7SUFDWEMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsS0FBSyxFQUFFLEVBQUU7SUFDVEMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsUUFBUSxFQUFFLEVBQUU7SUFDWkMsU0FBUyxFQUFFLEVBQUU7SUFDYkMsWUFBWSxFQUFFLEVBQUU7SUFDaEJDLFFBQVEsRUFBRSxFQUFFO0lBQ1pDLFNBQVMsRUFBRSxFQUFFO0lBQ2JDLFdBQVcsRUFBRSxFQUFFO0lBQ2ZDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE1BQU0sRUFBRSxDQUFDO0lBQ1RDLE9BQU8sRUFBRSxDQUFDO0lBQ1ZDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLFdBQVcsRUFBRSxFQUFFO0lBQ2ZDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLEtBQUssRUFBRSxFQUFFO0lBQ1RDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLFFBQVEsRUFBRSxFQUFFO0lBQ1pDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLFNBQVMsRUFBRSxFQUFFO0lBQ2JDLFFBQVEsRUFBRSxFQUFFO0lBQ1pDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLEtBQUssRUFBRSxDQUFDO0lBQ1JDLFVBQVUsRUFBRSxHQUFHO0lBQ2ZDLFNBQVMsRUFBRSxFQUFFO0lBQ2JDLEtBQUssRUFBRSxDQUFDO0lBQ1JDLEtBQUssRUFBRSxFQUFFO0lBQ1RDLE1BQU0sRUFBRSxHQUFHO0lBQ1hDLGVBQWUsRUFBRSxFQUFFO0lBQ25CQyxVQUFVLEVBQUUsRUFBRTtJQUNkQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxLQUFLLEVBQUUsRUFBRTtJQUNUQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxLQUFLLEVBQUUsQ0FBQztJQUNSQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxLQUFLLEVBQUUsR0FBRztJQUNWQyxTQUFTLEVBQUUsRUFBRTtJQUNiQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxXQUFXLEVBQUUsRUFBRTtJQUNmQyxLQUFLLEVBQUU7RUFDVCxDQUFDO0VBQ0RDLE9BQU8sRUFBRTtJQUNQQyxNQUFNLEVBQUUsQ0FBQztJQUNUQyxNQUFNLEVBQUUsQ0FBQztJQUNUQyxPQUFPLEVBQUUsQ0FBQztJQUNWQyxNQUFNLEVBQUUsQ0FBQztJQUNUQyxPQUFPLEVBQUUsQ0FBQztJQUNWQyxPQUFPLEVBQUUsQ0FBQztJQUNWQyxNQUFNLEVBQUUsQ0FBQztJQUNUQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxNQUFNLEVBQUUsQ0FBQztJQUNUQyxPQUFPLEVBQUUsQ0FBQztJQUNWQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxTQUFTLEVBQUUsRUFBRTtJQUNiQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxRQUFRLEVBQUUsRUFBRTtJQUNaQyxLQUFLLEVBQUUsRUFBRTtJQUNUQyxPQUFPLEVBQUUsRUFBRTtJQUNY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LHVCQUF1QixFQUFFLElBQUksQ0FBQztJQUMxQyxTQUFTLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxJQUFJLENBQUM7SUFDMUMsU0FBUyxFQUFFLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDO0lBQzFDO0lBQ0EsVUFBVSxFQUFFLENBQUMsc0JBQXNCLEVBQUUsSUFBSSxDQUFDO0lBQzFDLFVBQVUsRUFBRSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQztJQUMxQztJQUNBLFNBQVMsRUFBRSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQztJQUN6QztJQUNBLFNBQVMsRUFBRSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQztJQUN6QztJQUNBLFNBQVMsRUFBRSxDQUFDLHVCQUF1QixFQUFFLElBQUksQ0FBQztJQUMxQyxTQUFTLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxJQUFJLENBQUM7SUFDMUM7SUFDQSxTQUFTLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxJQUFJLENBQUM7SUFDMUMsU0FBUyxFQUFFLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDO0lBQzFDO0lBQ0EsVUFBVSxFQUFFLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDO0lBQ3pDLFVBQVUsRUFBRSxDQUFDLHFCQUFxQixFQUFFLElBQUksQ0FBQztJQUN6QztJQUNBLFNBQVMsRUFBRSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQztJQUN6QyxTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLENBQUM7SUFDekM7SUFDQSxTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLENBQUM7SUFDekMsU0FBUyxFQUFFLENBQUMsc0JBQXNCLEVBQUUsSUFBSSxDQUFDO0lBQ3pDO0lBQ0EsU0FBUyxFQUFFLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDO0lBQ3hDLFNBQVMsRUFBRSxDQUFDLHFCQUFxQixFQUFFLElBQUksQ0FBQztJQUN4QztJQUNBLFNBQVMsRUFBRSxDQUFDLHFCQUFxQixFQUFFLElBQUksQ0FBQztJQUN4QyxTQUFT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eEQsSUFBSyxJQUFHa2lDLEVBQUUsQ0FBQ3F2QixHQUFHLENBQUMzMkQsT0FBUSx5QkFBd0IsUUFBUyxJQUFHLFlBQWEsR0FBRSxDQUFDO0FBQ2pHMjhFLFNBQVMsQ0FBQyxZQUFZO0VBQ3BCO0VBQ0E7RUFDQXh1QixPQUFPLENBQUMsT0FBTyxDQUFDOztFQUVoQjtFQUNBO0VBQ0E7RUFDQTdtQixFQUFFLENBQUNxdkIsR0FBRyxDQUFDdW1CLFNBQVMsQ0FBQyxTQUFTLENBQUM7QUFDN0IsQ0FBQyxDQUFDIiwibmFtZXMiOlsiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImNoZWNrIiwiaXQiLCJNYXRoIiwiZ2xvYmFsJGkiLCJGdW5jdGlvbiIsIm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZhaWxzJGsiLCJleGVjIiwiZXJyb3IiLCJmYWlscyRqIiwiZGVzY3JpcHRvcnMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImZhaWxzJGkiLCJmdW5jdGlvbkJpbmROYXRpdmUiLCJ0ZXN0IiwiYmluZCIsImhhc093blByb3BlcnR5IiwiTkFUSVZFX0JJTkQkMyIsImNhbGwkZCIsInByb3RvdHlwZSIsImNhbGwiLCJmdW5jdGlvbkNhbGwiLCJhcHBseSIsImFyZ3VtZW50cyIsIm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlIiwiJHByb3BlcnR5SXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIk5BU0hPUk5fQlVHIiwiZiIsIlYiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1IiwiYml0bWFwIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk5BVElWRV9CSU5EJDIiLCJGdW5jdGlvblByb3RvdHlwZSQyIiwiY2FsbCRjIiwidW5jdXJyeVRoaXNXaXRoQmluZCIsImZ1bmN0aW9uVW5jdXJyeVRoaXMiLCJmbiIsInVuY3VycnlUaGlzJGwiLCJ0b1N0cmluZyQ2IiwidG9TdHJpbmciLCJzdHJpbmdTbGljZSQ1Iiwic2xpY2UiLCJjbGFzc29mUmF3JDIiLCJ1bmN1cnJ5VGhpcyRrIiwiZmFpbHMkaCIsImNsYXNzb2YkYiIsIiRPYmplY3QkNCIsInNwbGl0IiwiaW5kZXhlZE9iamVjdCIsImlzTnVsbE9yVW5kZWZpbmVkJDYiLCJ1bmRlZmluZWQiLCJpc051bGxPclVuZGVmaW5lZCQ1IiwiJFR5cGVFcnJvciRkIiwiVHlwZUVycm9yIiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1IiwiSW5kZXhlZE9iamVjdCQxIiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0IiwidG9JbmRleGVkT2JqZWN0JDQiLCJkb2N1bWVudEFsbCQyIiwiZG9jdW1lbnQiLCJhbGwiLCJJU19IVE1MRERBIiwiZG9jdW1lbnRBbGxfMSIsIiRkb2N1bWVudEFsbCQxIiwiZG9jdW1lbnRBbGwkMSIsImlzQ2FsbGFibGUkayIsImFyZ3VtZW50IiwiaXNDYWxsYWJsZSRqIiwiJGRvY3VtZW50QWxsIiwiZG9jdW1lbnRBbGwiLCJpc09iamVjdCRlIiwiZ2xvYmFsJGgiLCJpc0NhbGxhYmxlJGkiLCJhRnVuY3Rpb24iLCJnZXRCdWlsdEluJDYiLCJuYW1lc3BhY2UiLCJtZXRob2QiLCJsZW5ndGgiLCJ1bmN1cnJ5VGhpcyRqIiwib2JqZWN0SXNQcm90b3R5cGVPZiIsImlzUHJvdG90eXBlT2YiLCJlbmdpbmVVc2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJTdHJpbmciLCJ1c2VyQWdlbnQiLCJnbG9iYWwkZyIsInByb2Nlc3MkMiIsInByb2Nlc3MiLCJEZW5vIiwidmVyc2lvbnMiLCJ2ZXJzaW9uIiwidjgiLCJtYXRjaCIsImVuZ2luZVY4VmVyc2lvbiIsIlY4X1ZFUlNJT04iLCJmYWlscyRnIiwic3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb24iLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2wiLCJTeW1ib2wiLCJzaGFtIiwiTkFUSVZFX1NZTUJPTCQxIiwidXNlU3ltYm9sQXNVaWQiLCJpdGVyYXRvciIsImdldEJ1aWx0SW4kNSIsImlzQ2FsbGFibGUkaCIsImlzUHJvdG90eXBlT2YkNCIsIlVTRV9TWU1CT0xfQVNfVUlEJDEiLCIkT2JqZWN0JDMiLCJpc1N5bWJvbCQzIiwiJFN5bWJvbCIsIiRTdHJpbmckNCIsInRyeVRvU3RyaW5nJDQiLCJpc0NhbGxhYmxlJGciLCJ0cnlUb1N0cmluZyQzIiwiJFR5cGVFcnJvciRjIiwiYUNhbGxhYmxlJDQiLCJhQ2FsbGFibGUkMyIsImlzTnVsbE9yVW5kZWZpbmVkJDQiLCJnZXRNZXRob2QkNCIsIlAiLCJmdW5jIiwiY2FsbCRiIiwiaXNDYWxsYWJsZSRmIiwiaXNPYmplY3QkZCIsIiRUeXBlRXJyb3IkYiIsIm9yZGluYXJ5VG9QcmltaXRpdmUkMSIsImlucHV0IiwicHJlZiIsInZhbCIsInZhbHVlT2YiLCJzaGFyZWQkNCIsImV4cG9ydHMiLCJpc1B1cmUiLCJnbG9iYWwkZiIsImRlZmluZVByb3BlcnR5JDQiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzIiwia2V5IiwiZ2xvYmFsJGUiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyIiwiU0hBUkVEIiwic3RvcmUkMyIsInNoYXJlZFN0b3JlIiwic3RvcmUkMiIsInB1c2giLCJtb2RlIiwiY29weXJpZ2h0IiwibGljZW5zZSIsInNvdXJjZSIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkMyIsIiRPYmplY3QkMiIsInRvT2JqZWN0JDYiLCJ1bmN1cnJ5VGhpcyRpIiwidG9PYmplY3QkNSIsImhhc093blByb3BlcnR5JDEiLCJoYXNPd25Qcm9wZXJ0eV8xIiwiaGFzT3duIiwidW5jdXJyeVRoaXMkaCIsImlkIiwicG9zdGZpeCIsInJhbmRvbSIsInRvU3RyaW5nJDUiLCJ1aWQkMyIsImdsb2JhbCRkIiwic2hhcmVkJDMiLCJoYXNPd24kYiIsInVpZCQyIiwiTkFUSVZFX1NZTUJPTCIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiU3ltYm9sJDEiLCJXZWxsS25vd25TeW1ib2xzU3RvcmUiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwid2VsbEtub3duU3ltYm9sJGciLCJuYW1lIiwiY2FsbCRhIiwiaXNPYmplY3QkYyIsImlzU3ltYm9sJDIiLCJnZXRNZXRob2QkMyIsIm9yZGluYXJ5VG9QcmltaXRpdmUiLCJ3ZWxsS25vd25TeW1ib2wkZiIsIiRUeXBlRXJyb3IkYSIsIlRPX1BSSU1JVElWRSIsInRvUHJpbWl0aXZlJDIiLCJleG90aWNUb1ByaW0iLCJyZXN1bHQiLCJ0b1ByaW1pdGl2ZSQxIiwiaXNTeW1ib2wkMSIsInRvUHJvcGVydHlLZXkkNCIsImdsb2JhbCRjIiwiaXNPYmplY3QkYiIsImRvY3VtZW50JDEiLCJFWElTVFMkMSIsImNyZWF0ZUVsZW1lbnQiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSIsIkRFU0NSSVBUT1JTJGIiLCJmYWlscyRmIiwiaWU4RG9tRGVmaW5lIiwiYSIsIkRFU0NSSVBUT1JTJGEiLCJjYWxsJDkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0IiwidG9JbmRleGVkT2JqZWN0JDMiLCJ0b1Byb3BlcnR5S2V5JDMiLCJoYXNPd24kYSIsIklFOF9ET01fREVGSU5FJDEiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJPIiwib2JqZWN0RGVmaW5lUHJvcGVydHkiLCJERVNDUklQVE9SUyQ5IiwiZmFpbHMkZSIsInY4UHJvdG90eXBlRGVmaW5lQnVnIiwiaXNPYmplY3QkYSIsIiRTdHJpbmckMyIsIiRUeXBlRXJyb3IkOSIsImFuT2JqZWN0JGMiLCJERVNDUklQVE9SUyQ4IiwiSUU4X0RPTV9ERUZJTkUiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxIiwiYW5PYmplY3QkYiIsInRvUHJvcGVydHlLZXkkMiIsIiRUeXBlRXJyb3IkOCIsIiRkZWZpbmVQcm9wZXJ0eSIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJFTlVNRVJBQkxFIiwiQ09ORklHVVJBQkxFJDEiLCJXUklUQUJMRSIsIkF0dHJpYnV0ZXMiLCJjdXJyZW50IiwiREVTQ1JJUFRPUlMkNyIsImRlZmluZVByb3BlcnR5TW9kdWxlJDYiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2Iiwib2JqZWN0IiwibWFrZUJ1aWx0SW4kMiIsIkRFU0NSSVBUT1JTJDYiLCJoYXNPd24kOSIsIkZ1bmN0aW9uUHJvdG90eXBlJDEiLCJnZXREZXNjcmlwdG9yIiwiRVhJU1RTIiwiUFJPUEVSIiwic29tZXRoaW5nIiwiQ09ORklHVVJBQkxFIiwiZnVuY3Rpb25OYW1lIiwidW5jdXJyeVRoaXMkZyIsImlzQ2FsbGFibGUkZSIsInN0b3JlJDEiLCJmdW5jdGlvblRvU3RyaW5nIiwiaW5zcGVjdFNvdXJjZSIsImluc3BlY3RTb3VyY2UkMiIsImdsb2JhbCRiIiwiaXNDYWxsYWJsZSRkIiwiV2Vha01hcCQxIiwiV2Vha01hcCIsIndlYWtNYXBCYXNpY0RldGVjdGlvbiIsInNoYXJlZCQyIiwidWlkJDEiLCJrZXlzJDEiLCJzaGFyZWRLZXkkMyIsImhpZGRlbktleXMkNCIsIk5BVElWRV9XRUFLX01BUCIsImdsb2JhbCRhIiwiaXNPYmplY3QkOSIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1IiwiaGFzT3duJDgiLCJzaGFyZWQkMSIsInNoYXJlZEtleSQyIiwiaGlkZGVuS2V5cyQzIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJUeXBlRXJyb3IkMiIsInNldCQxIiwiZ2V0JDEiLCJoYXMiLCJlbmZvcmNlIiwiZ2V0dGVyRm9yIiwiVFlQRSIsInN0YXRlIiwidHlwZSIsInN0b3JlIiwic2V0IiwibWV0YWRhdGEiLCJmYWNhZGUiLCJTVEFURSIsImludGVybmFsU3RhdGUiLCJ1bmN1cnJ5VGhpcyRmIiwiZmFpbHMkZCIsImlzQ2FsbGFibGUkYyIsImhhc093biQ3IiwiREVTQ1JJUFRPUlMkNSIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEiLCJpbnNwZWN0U291cmNlJDEiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDQiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSQyIiwiZ2V0SW50ZXJuYWxTdGF0ZSQ1IiwiJFN0cmluZyQyIiwiZGVmaW5lUHJvcGVydHkkMyIsInN0cmluZ1NsaWNlJDQiLCJyZXBsYWNlJDIiLCJyZXBsYWNlIiwiam9pbiQyIiwiam9pbiIsIkNPTkZJR1VSQUJMRV9MRU5HVEgiLCJURU1QTEFURSIsIm1ha2VCdWlsdEluJDEiLCJvcHRpb25zIiwiZ2V0dGVyIiwic2V0dGVyIiwiYXJpdHkiLCJjb25zdHJ1Y3RvciIsImlzQ2FsbGFibGUkYiIsImRlZmluZVByb3BlcnR5TW9kdWxlJDUiLCJtYWtlQnVpbHRJbiIsImRlZmluZUdsb2JhbFByb3BlcnR5JDEiLCJkZWZpbmVCdWlsdEluJDciLCJzaW1wbGUiLCJ1bnNhZmUiLCJub25Db25maWd1cmFibGUiLCJub25Xcml0YWJsZSIsIm9iamVjdEdldE93blByb3BlcnR5TmFtZXMiLCJjZWlsIiwiZmxvb3IkMyIsImZsb29yIiwibWF0aFRydW5jIiwidHJ1bmMiLCJ4IiwibiIsInRvSW50ZWdlck9ySW5maW5pdHkkNyIsIm51bWJlciIsInRvSW50ZWdlck9ySW5maW5pdHkkNiIsIm1heCQyIiwibWF4IiwibWluJDIiLCJtaW4iLCJ0b0Fic29sdXRlSW5kZXgkMyIsImluZGV4IiwiaW50ZWdlciIsInRvSW50ZWdlck9ySW5maW5pdHkkNSIsIm1pbiQxIiwidG9MZW5ndGgkNiIsInRvTGVuZ3RoJDUiLCJsZW5ndGhPZkFycmF5TGlrZSQ1Iiwib2JqIiwidG9JbmRleGVkT2JqZWN0JDIiLCJ0b0Fic29sdXRlSW5kZXgkMiIsImxlbmd0aE9mQXJyYXlMaWtlJDQiLCJjcmVhdGVNZXRob2QkMiIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsImFycmF5SW5jbHVkZXMiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJ1bmN1cnJ5VGhpcyRlIiwiaGFzT3duJDYiLCJ0b0luZGV4ZWRPYmplY3QkMSIsImluZGV4T2YkMiIsImhpZGRlbktleXMkMiIsInB1c2gkMiIsIm9iamVjdEtleXNJbnRlcm5hbCIsIm5hbWVzIiwiaSIsImVudW1CdWdLZXlzJDMiLCJpbnRlcm5hbE9iamVjdEtleXMkMSIsImVudW1CdWdLZXlzJDIiLCJoaWRkZW5LZXlzJDEiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0QnVpbHRJbiQ0IiwidW5jdXJyeVRoaXMkZCIsImdldE93blByb3BlcnR5TmFtZXNNb2R1bGUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJhbk9iamVjdCRhIiwiY29uY2F0JDEiLCJvd25LZXlzJDEiLCJvd25LZXlzIiwia2V5cyIsImhhc093biQ1IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0IiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxIiwidGFyZ2V0IiwiZXhjZXB0aW9ucyIsImZhaWxzJGMiLCJpc0NhbGxhYmxlJGEiLCJyZXBsYWNlbWVudCIsImlzRm9yY2VkJDEiLCJmZWF0dXJlIiwiZGV0ZWN0aW9uIiwiZGF0YSIsIm5vcm1hbGl6ZSQxIiwiUE9MWUZJTEwiLCJOQVRJVkUiLCJub3JtYWxpemUiLCJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImlzRm9yY2VkXzEiLCJnbG9iYWwkOSIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0IiwiZGVmaW5lQnVpbHRJbiQ2IiwiZGVmaW5lR2xvYmFsUHJvcGVydHkiLCJjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzIiwiaXNGb3JjZWQiLCJfZXhwb3J0IiwiVEFSR0VUIiwiR0xPQkFMIiwiU1RBVElDIiwic3RhdCIsIkZPUkNFRCIsInRhcmdldFByb3BlcnR5Iiwic291cmNlUHJvcGVydHkiLCJkb250Q2FsbEdldFNldCIsImZvcmNlZCIsImdsb2JhbCQ4IiwicHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yIiwiUHJvbWlzZSIsIndlbGxLbm93blN5bWJvbCRlIiwiVE9fU1RSSU5HX1RBRyQzIiwidG9TdHJpbmdUYWdTdXBwb3J0IiwiVE9fU1RSSU5HX1RBR19TVVBQT1JUIiwiaXNDYWxsYWJsZSQ5IiwiY2xhc3NvZlJhdyQxIiwid2VsbEtub3duU3ltYm9sJGQiLCJUT19TVFJJTkdfVEFHJDIiLCIkT2JqZWN0JDEiLCJDT1JSRUNUX0FSR1VNRU5UUyIsInRyeUdldCIsImNsYXNzb2YkYSIsInRhZyIsImNhbGxlZSIsInVuY3VycnlUaGlzJGMiLCJmYWlscyRiIiwiaXNDYWxsYWJsZSQ4IiwiY2xhc3NvZiQ5IiwiZ2V0QnVpbHRJbiQzIiwibm9vcCQyIiwiZW1wdHkiLCJjb25zdHJ1Y3QiLCJjb25zdHJ1Y3RvclJlZ0V4cCIsImV4ZWMkMSIsIklOQ09SUkVDVF9UT19TVFJJTkciLCJpc0NvbnN0cnVjdG9yTW9kZXJuIiwiaXNDb25zdHJ1Y3RvciIsImlzQ29uc3RydWN0b3JMZWdhY3kiLCJpc0NvbnN0cnVjdG9yJDIiLCJjYWxsZWQiLCJpc0NvbnN0cnVjdG9yJDEiLCJ0cnlUb1N0cmluZyQyIiwiJFR5cGVFcnJvciQ3IiwiYUNvbnN0cnVjdG9yJDIiLCJhbk9iamVjdCQ5IiwiYUNvbnN0cnVjdG9yJDEiLCJpc051bGxPclVuZGVmaW5lZCQzIiwid2VsbEtub3duU3ltYm9sJGMiLCJTUEVDSUVTJDMiLCJzcGVjaWVzQ29uc3RydWN0b3IkMiIsImRlZmF1bHRDb25zdHJ1Y3RvciIsIkMiLCJTIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkkMSIsImFDYWxsYWJsZSQyIiwiJFR5cGVFcnJvciQ2IiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvbWlzZSIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwiYW5PYmplY3QkOCIsImlzT2JqZWN0JDgiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSIsInByb21pc2VSZXNvbHZlJDEiLCJwcm9taXNlQ2FwYWJpbGl0eSIsIiQkMyIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciIsImZhaWxzJGEiLCJnZXRCdWlsdEluJDIiLCJpc0NhbGxhYmxlJDciLCJzcGVjaWVzQ29uc3RydWN0b3IkMSIsInByb21pc2VSZXNvbHZlIiwiZGVmaW5lQnVpbHRJbiQ1IiwiTmF0aXZlUHJvbWlzZVByb3RvdHlwZSIsIk5PTl9HRU5FUklDIiwidGhlbiIsInByb3RvIiwicmVhbCIsImZpbmFsbHkiLCJvbkZpbmFsbHkiLCJpc0Z1bmN0aW9uIiwiZSIsImNsYXNzb2ZSYXciLCJ1bmN1cnJ5VGhpcyRiIiwiZnVuY3Rpb25VbmN1cnJ5VGhpc0NsYXVzZSIsIm9iamVjdERlZmluZVByb3BlcnRpZXMiLCJpbnRlcm5hbE9iamVjdEtleXMiLCJlbnVtQnVnS2V5cyQxIiwib2JqZWN0S2V5cyQxIiwiREVTQ1JJUFRPUlMkNCIsIlY4X1BST1RPVFlQRV9ERUZJTkVfQlVHIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMyIsImFuT2JqZWN0JDciLCJ0b0luZGV4ZWRPYmplY3QiLCJvYmplY3RLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJwcm9wcyIsImdldEJ1aWx0SW4kMSIsImh0bWwkMSIsImFuT2JqZWN0JDYiLCJkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlIiwiZW51bUJ1Z0tleXMiLCJoaWRkZW5LZXlzIiwiaHRtbCIsImRvY3VtZW50Q3JlYXRlRWxlbWVudCIsInNoYXJlZEtleSQxIiwiR1QiLCJMVCIsIlBST1RPVFlQRSQxIiwiU0NSSVBUIiwiSUVfUFJPVE8kMSIsIkVtcHR5Q29uc3RydWN0b3IiLCJzY3JpcHRUYWciLCJjb250ZW50IiwiTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCIsImFjdGl2ZVhEb2N1bWVudCIsIndyaXRlIiwiY2xvc2UiLCJ0ZW1wIiwicGFyZW50V2luZG93IiwiTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lIiwiaWZyYW1lIiwiSlMiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwic3JjIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJGIiwiTnVsbFByb3RvT2JqZWN0IiwiQWN0aXZlWE9iamVjdCIsImRvbWFpbiIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsImZhaWxzJDkiLCJjb3JyZWN0UHJvdG90eXBlR2V0dGVyIiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd24kNCIsImlzQ2FsbGFibGUkNiIsInRvT2JqZWN0JDQiLCJzaGFyZWRLZXkiLCJDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIiLCJJRV9QUk9UTyIsIiRPYmplY3QiLCJPYmplY3RQcm90b3R5cGUkMiIsIm9iamVjdEdldFByb3RvdHlwZU9mIiwiZmFpbHMkOCIsImlzQ2FsbGFibGUkNSIsImlzT2JqZWN0JDciLCJnZXRQcm90b3R5cGVPZiQyIiwiZGVmaW5lQnVpbHRJbiQ0Iiwid2VsbEtub3duU3ltYm9sJGIiLCJJVEVSQVRPUiQzIiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyIsIkl0ZXJhdG9yUHJvdG90eXBlJDEiLCJQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJhcnJheUl0ZXJhdG9yIiwiTkVXX0lURVJBVE9SX1BST1RPVFlQRSIsIml0ZXJhdG9yc0NvcmUiLCJJdGVyYXRvclByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5JDIiLCJoYXNPd24kMyIsIndlbGxLbm93blN5bWJvbCRhIiwiVE9fU1RSSU5HX1RBRyQxIiwic2V0VG9TdHJpbmdUYWckMiIsIlRBRyIsIml0ZXJhdG9ycyIsImNyZWF0ZSQyIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIiLCJzZXRUb1N0cmluZ1RhZyQxIiwiSXRlcmF0b3JzJDIiLCJyZXR1cm5UaGlzIiwiaXRlcmF0b3JDcmVhdGVDb25zdHJ1Y3RvciIsIkl0ZXJhdG9yQ29uc3RydWN0b3IiLCJOQU1FIiwibmV4dCIsIkVOVU1FUkFCTEVfTkVYVCIsIlRPX1NUUklOR19UQUciLCJjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDEiLCJkb25lIiwiY2xhc3NvZiQ4IiwiJFN0cmluZyQxIiwidG9TdHJpbmckNCIsImlzT2JqZWN0JDYiLCJjbGFzc29mJDciLCJ3ZWxsS25vd25TeW1ib2wkOSIsIk1BVENIIiwiaXNSZWdleHAiLCJpc1JlZ0V4cCIsImFuT2JqZWN0JDUiLCJyZWdleHBGbGFncyQxIiwidGhhdCIsImhhc0luZGljZXMiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwiZG90QWxsIiwidW5pY29kZSIsInVuaWNvZGVTZXRzIiwic3RpY2t5IiwiY2FsbCQ4IiwiaGFzT3duJDIiLCJpc1Byb3RvdHlwZU9mJDMiLCJyZWdFeHBGbGFncyIsIlJlZ0V4cFByb3RvdHlwZSQzIiwiUmVnRXhwIiwicmVnZXhwR2V0RmxhZ3MiLCJSIiwiZmxhZ3MiLCJ1bmN1cnJ5VGhpcyRhIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQ0IiwidG9TdHJpbmckMyIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkMiIsImNoYXJBdCQzIiwiY2hhckF0IiwiY2hhckNvZGVBdCIsInN0cmluZ1NsaWNlJDMiLCJjcmVhdGVNZXRob2QkMSIsIkNPTlZFUlRfVE9fU1RSSU5HIiwicG9zIiwicG9zaXRpb24iLCJzaXplIiwiZmlyc3QiLCJzZWNvbmQiLCJzdHJpbmdNdWx0aWJ5dGUiLCJjb2RlQXQiLCJjaGFyQXQkMiIsImFkdmFuY2VTdHJpbmdJbmRleCQyIiwiZmFpbHMkNyIsImdsb2JhbCQ3IiwiJFJlZ0V4cCQyIiwiVU5TVVBQT1JURURfWSQxIiwicmUiLCJsYXN0SW5kZXgiLCJNSVNTRURfU1RJQ0tZIiwiQlJPS0VOX0NBUkVUIiwicmVnZXhwU3RpY2t5SGVscGVycyIsIlVOU1VQUE9SVEVEX1kiLCJmYWlscyQ2IiwiZ2xvYmFsJDYiLCIkUmVnRXhwJDEiLCJyZWdleHBVbnN1cHBvcnRlZERvdEFsbCIsImZhaWxzJDUiLCJnbG9iYWwkNSIsIiRSZWdFeHAiLCJyZWdleHBVbnN1cHBvcnRlZE5jZyIsImdyb3VwcyIsImNhbGwkNyIsInVuY3VycnlUaGlzJDkiLCJ0b1N0cmluZyQyIiwicmVnZXhwRmxhZ3MiLCJzdGlja3lIZWxwZXJzIiwic2hhcmVkIiwiY3JlYXRlJDEiLCJnZXRJbnRlcm5hbFN0YXRlJDQiLCJVTlNVUFBPUlRFRF9ET1RfQUxMIiwiVU5TVVBQT1JURURfTkNHIiwibmF0aXZlUmVwbGFjZSIsIm5hdGl2ZUV4ZWMiLCJwYXRjaGVkRXhlYyIsImNoYXJBdCQxIiwiaW5kZXhPZiQxIiwicmVwbGFjZSQxIiwic3RyaW5nU2xpY2UkMiIsIlVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyIsInJlMSIsInJlMiIsIk5QQ0dfSU5DTFVERUQiLCJQQVRDSCIsInN0ciIsInJhdyIsInJlQ29weSIsImdyb3VwIiwiY2hhcnNBZGRlZCIsInN0ckNvcHkiLCJyZWdleHBFeGVjJDIiLCJjYWxsJDYiLCJhbk9iamVjdCQ0IiwiaXNDYWxsYWJsZSQ0IiwiY2xhc3NvZiQ2IiwicmVnZXhwRXhlYyQxIiwiJFR5cGVFcnJvciQ1IiwicmVnZXhwRXhlY0Fic3RyYWN0IiwiJCQyIiwiY2FsbCQ1IiwidW5jdXJyeVRoaXMkOCIsImNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IiLCJjcmVhdGVJdGVyUmVzdWx0T2JqZWN0IiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQxIiwidG9MZW5ndGgkNCIsInRvU3RyaW5nJDEiLCJhbk9iamVjdCQzIiwiaXNOdWxsT3JVbmRlZmluZWQkMiIsImNsYXNzb2YkNSIsImlzUmVnRXhwJDEiLCJnZXRSZWdFeHBGbGFncyIsImdldE1ldGhvZCQyIiwiZGVmaW5lQnVpbHRJbiQzIiwiZmFpbHMkNCIsIndlbGxLbm93blN5bWJvbCQ4Iiwic3BlY2llc0NvbnN0cnVjdG9yIiwiYWR2YW5jZVN0cmluZ0luZGV4JDEiLCJyZWdFeHBFeGVjJDEiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDMiLCJJU19QVVJFIiwiTUFUQ0hfQUxMIiwiUkVHRVhQX1NUUklORyIsIlJFR0VYUF9TVFJJTkdfSVRFUkFUT1IiLCJzZXRJbnRlcm5hbFN0YXRlJDIiLCJnZXRJbnRlcm5hbFN0YXRlJDMiLCJSZWdFeHBQcm90b3R5cGUkMiIsIiRUeXBlRXJyb3IkNCIsInN0cmluZ0luZGV4T2YkMSIsIm5hdGl2ZU1hdGNoQWxsIiwibWF0Y2hBbGwiLCJXT1JLU19XSVRIX05PTl9HTE9CQUxfUkVHRVgiLCIkUmVnRXhwU3RyaW5nSXRlcmF0b3IiLCJSZWdFeHBTdHJpbmdJdGVyYXRvciIsInJlZ2V4cCIsIiRnbG9iYWwiLCJmdWxsVW5pY29kZSIsIiRtYXRjaEFsbCIsIm1hdGNoZXIiLCJyeCIsIk5BVElWRV9CSU5EJDEiLCJGdW5jdGlvblByb3RvdHlwZSIsImFwcGx5JDEiLCJjYWxsJDQiLCJmdW5jdGlvbkFwcGx5IiwiUmVmbGVjdCIsIiQkMSIsInVuY3VycnlUaGlzJDciLCJkZWZpbmVCdWlsdEluJDIiLCJyZWdleHBFeGVjIiwiZmFpbHMkMyIsIndlbGxLbm93blN5bWJvbCQ3IiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMiLCJTUEVDSUVTJDIiLCJSZWdFeHBQcm90b3R5cGUkMSIsImZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljIiwiS0VZIiwiU0hBTSIsIlNZTUJPTCIsIkRFTEVHQVRFU19UT19TWU1CT0wiLCJERUxFR0FURVNfVE9fRVhFQyIsImV4ZWNDYWxsZWQiLCJ1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QiLCJtZXRob2RzIiwibmF0aXZlTWV0aG9kIiwiYXJnMiIsImZvcmNlU3RyaW5nTWV0aG9kIiwidW5jdXJyaWVkTmF0aXZlTWV0aG9kIiwiJGV4ZWMiLCJ1bmN1cnJ5VGhpcyQ2IiwidG9PYmplY3QkMyIsImZsb29yJDIiLCJzdHJpbmdTbGljZSQxIiwiU1VCU1RJVFVUSU9OX1NZTUJPTFMiLCJTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCIsImdldFN1YnN0aXR1dGlvbiQxIiwibWF0Y2hlZCIsImNhcHR1cmVzIiwibmFtZWRDYXB0dXJlcyIsInRhaWxQb3MiLCJtIiwic3ltYm9scyIsImNoIiwiY2FwdHVyZSIsImNhbGwkMyIsInVuY3VycnlUaGlzJDUiLCJmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyIsImZhaWxzJDIiLCJhbk9iamVjdCQyIiwiaXNDYWxsYWJsZSQzIiwiaXNOdWxsT3JVbmRlZmluZWQkMSIsInRvSW50ZWdlck9ySW5maW5pdHkkMyIsInRvTGVuZ3RoJDMiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwiYWR2YW5jZVN0cmluZ0luZGV4IiwiZ2V0TWV0aG9kJDEiLCJnZXRTdWJzdGl0dXRpb24iLCJyZWdFeHBFeGVjIiwid2VsbEtub3duU3ltYm9sJDYiLCJSRVBMQUNFIiwibWF4JDEiLCJwdXNoJDEiLCJzdHJpbmdJbmRleE9mIiwic3RyaW5nU2xpY2UiLCJtYXliZVRvU3RyaW5nIiwiUkVQTEFDRV9LRUVQU18kMCIsIlJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFIiwiUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMiLCJfIiwibWF5YmVDYWxsTmF0aXZlIiwiVU5TQUZFX1NVQlNUSVRVVEUiLCJzZWFyY2hWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsInJlcGxhY2VyIiwicmVzIiwiZnVuY3Rpb25hbFJlcGxhY2UiLCJyZXN1bHRzIiwibWF0Y2hTdHIiLCJhY2N1bXVsYXRlZFJlc3VsdCIsIm5leHRTb3VyY2VQb3NpdGlvbiIsImoiLCJyZXBsYWNlckFyZ3MiLCJ0eXBlZEFycmF5Q29uc3RydWN0b3IiLCJ3ZWxsS25vd25TeW1ib2wkNSIsIklURVJBVE9SJDIiLCJTQUZFX0NMT1NJTkciLCJpdGVyYXRvcldpdGhSZXR1cm4iLCJyZXR1cm4iLCJBcnJheSIsImZyb20iLCJjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSIsIlNLSVBfQ0xPU0lORyIsIklURVJBVElPTl9TVVBQT1JUIiwiYXJyYXlCdWZmZXJCYXNpY0RldGVjdGlvbiIsIkFycmF5QnVmZmVyIiwiRGF0YVZpZXciLCJpc0NhbGxhYmxlJDIiLCIkU3RyaW5nIiwiJFR5cGVFcnJvciQzIiwiYVBvc3NpYmxlUHJvdG90eXBlJDEiLCJ1bmN1cnJ5VGhpcyQ0IiwiYW5PYmplY3QkMSIsImFQb3NzaWJsZVByb3RvdHlwZSIsIm9iamVjdFNldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJDT1JSRUNUX1NFVFRFUiIsIl9fcHJvdG9fXyIsIk5BVElWRV9BUlJBWV9CVUZGRVIkMSIsIkRFU0NSSVBUT1JTJDMiLCJnbG9iYWwkNCIsImlzQ2FsbGFibGUkMSIsImlzT2JqZWN0JDUiLCJoYXNPd24kMSIsImNsYXNzb2YkNCIsInRyeVRvU3RyaW5nJDEiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiIsImRlZmluZUJ1aWx0SW4kMSIsImRlZmluZVByb3BlcnR5JDEiLCJpc1Byb3RvdHlwZU9mJDIiLCJnZXRQcm90b3R5cGVPZiQxIiwic2V0UHJvdG90eXBlT2YkMyIsIndlbGxLbm93blN5bWJvbCQ0IiwidWlkIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSQyIiwiZW5mb3JjZUludGVybmFsU3RhdGUkMSIsImdldEludGVybmFsU3RhdGUkMiIsIkludDhBcnJheSQyIiwiSW50OEFycmF5IiwiSW50OEFycmF5UHJvdG90eXBlIiwiVWludDhDbGFtcGVkQXJyYXkkMSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUiLCJUeXBlZEFycmF5JDEiLCJUeXBlZEFycmF5UHJvdG90eXBlJDMiLCJPYmplY3RQcm90b3R5cGUkMSIsIlR5cGVFcnJvciQxIiwiVFlQRURfQVJSQVlfVEFHJDEiLCJUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiIsIk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiIsIm9wZXJhIiwiVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEIiwiQ29uc3RydWN0b3IiLCJQcm90b3R5cGUiLCJUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCIsIlVpbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QiLCJCaWdJbnQ2NEFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJpc1ZpZXciLCJrbGFzcyIsImdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImlzVHlwZWRBcnJheSQyIiwiYVR5cGVkQXJyYXkiLCJhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDMiLCJleHBvcnRUeXBlZEFycmF5TWV0aG9kIiwicHJvcGVydHkiLCJBUlJBWSIsIlR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImVycm9yMiIsImV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMiIsIlR5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlclZpZXdDb3JlIiwiTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyIsIlRZUEVEX0FSUkFZX1RBRyIsImFUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kIiwiaXNUeXBlZEFycmF5IiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdsb2JhbCQzIiwiZmFpbHMkMSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiIsIk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSIsIkFycmF5QnVmZmVyJDIiLCJJbnQ4QXJyYXkkMSIsInR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnMiLCJpdGVyYWJsZSIsImRlZmluZUJ1aWx0SW4iLCJkZWZpbmVCdWlsdElucyQxIiwiaXNQcm90b3R5cGVPZiQxIiwiJFR5cGVFcnJvciQyIiwiYW5JbnN0YW5jZSQyIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQyIiwidG9MZW5ndGgkMiIsIiRSYW5nZUVycm9yJDIiLCJSYW5nZUVycm9yIiwidG9JbmRleCQyIiwiJEFycmF5JDIiLCJhYnMiLCJwb3ciLCJmbG9vciQxIiwibG9nIiwiTE4yIiwicGFjayIsIm1hbnRpc3NhTGVuZ3RoIiwiYnl0ZXMiLCJidWZmZXIiLCJleHBvbmVudExlbmd0aCIsImVNYXgiLCJlQmlhcyIsInJ0Iiwic2lnbiIsImV4cG9uZW50IiwibWFudGlzc2EiLCJjIiwiSW5maW5pdHkiLCJ1bnBhY2siLCJuQml0cyIsIk5hTiIsImllZWU3NTQiLCJ0b09iamVjdCQyIiwidG9BYnNvbHV0ZUluZGV4JDEiLCJsZW5ndGhPZkFycmF5TGlrZSQzIiwiYXJyYXlGaWxsJDEiLCJmaWxsIiwiYXJndW1lbnRzTGVuZ3RoIiwiZW5kIiwiZW5kUG9zIiwidG9Qcm9wZXJ0eUtleSQxIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMiIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxIiwiY3JlYXRlUHJvcGVydHkkMSIsInByb3BlcnR5S2V5IiwidG9BYnNvbHV0ZUluZGV4IiwibGVuZ3RoT2ZBcnJheUxpa2UkMiIsImNyZWF0ZVByb3BlcnR5IiwiJEFycmF5JDEiLCJhcnJheVNsaWNlU2ltcGxlIiwic3RhcnQiLCJrIiwiZmluIiwiZ2xvYmFsJDIiLCJ1bmN1cnJ5VGhpcyQzIiwiREVTQ1JJUFRPUlMkMiIsIk5BVElWRV9BUlJBWV9CVUZGRVIiLCJGdW5jdGlvbk5hbWUiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSIsImRlZmluZUJ1aWx0SW5zIiwiZmFpbHMiLCJhbkluc3RhbmNlJDEiLCJ0b0ludGVnZXJPckluZmluaXR5JDEiLCJ0b0xlbmd0aCQxIiwidG9JbmRleCQxIiwiSUVFRTc1NCIsInNldFByb3RvdHlwZU9mJDIiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzJDEiLCJhcnJheUZpbGwiLCJhcnJheVNsaWNlIiwic2V0VG9TdHJpbmdUYWciLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDEiLCJQUk9QRVJfRlVOQ1RJT05fTkFNRSIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FIiwiZ2V0SW50ZXJuYWxTdGF0ZSQxIiwic2V0SW50ZXJuYWxTdGF0ZSQxIiwiQVJSQVlfQlVGRkVSIiwiREFUQV9WSUVXIiwiUFJPVE9UWVBFIiwiV1JPTkdfTEVOR1RIJDEiLCJXUk9OR19JTkRFWCIsIk5hdGl2ZUFycmF5QnVmZmVyIiwiJEFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXJQcm90b3R5cGUkMSIsIiREYXRhVmlldyIsIkRhdGFWaWV3UHJvdG90eXBlIiwiT2JqZWN0UHJvdG90eXBlIiwiQXJyYXkkMSIsIlJhbmdlRXJyb3IkMiIsInJldmVyc2UiLCJwYWNrSUVFRTc1NCIsInVucGFja0lFRUU3NTQiLCJwYWNrSW50OCIsInBhY2tJbnQxNiIsInBhY2tJbnQzMiIsInVucGFja0ludDMyIiwicGFja0Zsb2F0MzIiLCJwYWNrRmxvYXQ2NCIsImFkZEdldHRlciQxIiwidmlldyIsImNvdW50IiwiaXNMaXR0bGVFbmRpYW4iLCJpbnRJbmRleCIsImJ5dGVMZW5ndGgiLCJieXRlT2Zmc2V0IiwiY29udmVyc2lvbiIsImJ1ZmZlckxlbmd0aCIsIm9mZnNldCIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEludDgiLCJzZXRVaW50OCIsInNldEludDE2Iiwic2V0VWludDE2Iiwic2V0SW50MzIiLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwic2V0RmxvYXQ2NCIsIklOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSIsInRlc3RWaWV3IiwiJHNldEludDgiLCJhcnJheUJ1ZmZlciIsImlzT2JqZWN0JDQiLCJpc0ludGVncmFsTnVtYmVyJDEiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpc0Zpbml0ZSIsInRvSW50ZWdlck9ySW5maW5pdHkiLCIkUmFuZ2VFcnJvciQxIiwidG9Qb3NpdGl2ZUludGVnZXIkMSIsInRvUG9zaXRpdmVJbnRlZ2VyIiwiJFJhbmdlRXJyb3IiLCJ0b09mZnNldCQxIiwiQllURVMiLCJ1bmN1cnJ5VGhpcyQyIiwiYUNhbGxhYmxlJDEiLCJOQVRJVkVfQklORCIsImJpbmQkMiIsImZ1bmN0aW9uQmluZENvbnRleHQiLCJjbGFzc29mJDMiLCJnZXRNZXRob2QiLCJpc051bGxPclVuZGVmaW5lZCIsIkl0ZXJhdG9ycyQxIiwid2VsbEtub3duU3ltYm9sJDMiLCJJVEVSQVRPUiQxIiwiZ2V0SXRlcmF0b3JNZXRob2QkMiIsImNhbGwkMiIsImFDYWxsYWJsZSIsImFuT2JqZWN0IiwidHJ5VG9TdHJpbmciLCJnZXRJdGVyYXRvck1ldGhvZCQxIiwiJFR5cGVFcnJvciQxIiwiZ2V0SXRlcmF0b3IkMSIsInVzaW5nSXRlcmF0b3IiLCJpdGVyYXRvck1ldGhvZCIsIndlbGxLbm93blN5bWJvbCQyIiwiSXRlcmF0b3JzIiwiSVRFUkFUT1IiLCJBcnJheVByb3RvdHlwZSIsImlzQXJyYXlJdGVyYXRvck1ldGhvZCQxIiwiY2xhc3NvZiQyIiwiaXNCaWdJbnRBcnJheSQxIiwidG9QcmltaXRpdmUiLCIkVHlwZUVycm9yIiwidG9CaWdJbnQkMSIsInByaW0iLCJCaWdJbnQiLCJiaW5kJDEiLCJjYWxsJDEiLCJhQ29uc3RydWN0b3IiLCJ0b09iamVjdCQxIiwibGVuZ3RoT2ZBcnJheUxpa2UkMSIsImdldEl0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJpc0FycmF5SXRlcmF0b3JNZXRob2QiLCJpc0JpZ0ludEFycmF5IiwiYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyIiwidG9CaWdJbnQiLCJ0eXBlZEFycmF5RnJvbSQyIiwibWFwZm4iLCJtYXBwaW5nIiwidGhpc0lzQmlnSW50QXJyYXkiLCJzdGVwIiwiY2xhc3NvZiQxIiwiaXNBcnJheSQxIiwiaXNBcnJheSIsImlzT2JqZWN0JDMiLCJ3ZWxsS25vd25TeW1ib2wkMSIsIlNQRUNJRVMkMSIsIiRBcnJheSIsImFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDEiLCJvcmlnaW5hbEFycmF5IiwiYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IiLCJhcnJheVNwZWNpZXNDcmVhdGUkMSIsInVuY3VycnlUaGlzJDEiLCJJbmRleGVkT2JqZWN0IiwidG9PYmplY3QiLCJsZW5ndGhPZkFycmF5TGlrZSIsImFycmF5U3BlY2llc0NyZWF0ZSIsImNyZWF0ZU1ldGhvZCIsIklTX01BUCIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJJU19GSUxURVJfUkVKRUNUIiwiTk9fSE9MRVMiLCJjYWxsYmFja2ZuIiwic3BlY2lmaWNDcmVhdGUiLCJib3VuZEZ1bmN0aW9uIiwiYXJyYXlJdGVyYXRpb24iLCJmb3JFYWNoIiwibWFwIiwiZmlsdGVyIiwic29tZSIsImV2ZXJ5IiwiZmluZCIsImZpbmRJbmRleCIsImZpbHRlclJlamVjdCIsImdldEJ1aWx0SW4iLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxIiwid2VsbEtub3duU3ltYm9sIiwiREVTQ1JJUFRPUlMkMSIsIlNQRUNJRVMiLCJzZXRTcGVjaWVzJDEiLCJDT05TVFJVQ1RPUl9OQU1FIiwiaXNDYWxsYWJsZSIsImlzT2JqZWN0JDIiLCJzZXRQcm90b3R5cGVPZiQxIiwiaW5oZXJpdElmUmVxdWlyZWQkMSIsImR1bW15IiwiV3JhcHBlciIsIk5ld1RhcmdldCIsIk5ld1RhcmdldFByb3RvdHlwZSIsIiQiLCJnbG9iYWwkMSIsIkRFU0NSSVBUT1JTIiwiVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQyIiwiQXJyYXlCdWZmZXJWaWV3Q29yZSQxIiwiQXJyYXlCdWZmZXJNb2R1bGUiLCJhbkluc3RhbmNlIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5IiwiaXNJbnRlZ3JhbE51bWJlciIsInRvTGVuZ3RoIiwidG9JbmRleCIsInRvT2Zmc2V0IiwidG9Qcm9wZXJ0eUtleSIsImNsYXNzb2YiLCJpc09iamVjdCQxIiwiaXNTeW1ib2wiLCJ0eXBlZEFycmF5RnJvbSQxIiwic2V0U3BlY2llcyIsImRlZmluZVByb3BlcnR5TW9kdWxlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsImluaGVyaXRJZlJlcXVpcmVkIiwiZ2V0SW50ZXJuYWxTdGF0ZSIsInNldEludGVybmFsU3RhdGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsIm5hdGl2ZURlZmluZVByb3BlcnR5IiwibmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicm91bmQiLCJSYW5nZUVycm9yJDEiLCJBcnJheUJ1ZmZlciQxIiwiQXJyYXlCdWZmZXJQcm90b3R5cGUiLCJEYXRhVmlldyQxIiwiVHlwZWRBcnJheVByb3RvdHlwZSQyIiwiYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQxIiwiaXNUeXBlZEFycmF5JDEiLCJCWVRFU19QRVJfRUxFTUVOVCIsIldST05HX0xFTkdUSCIsImZyb21MaXN0IiwibGlzdCIsImFkZEdldHRlciIsImlzQXJyYXlCdWZmZXIkMSIsImlzVHlwZWRBcnJheUluZGV4Iiwid3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIndyYXBwZWREZWZpbmVQcm9wZXJ0eSIsIndyYXBwZXIiLCJDTEFNUEVEIiwiR0VUVEVSIiwiU0VUVEVSIiwiTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhwb3J0ZWQiLCJhZGRFbGVtZW50IiwiJGxlbmd0aCIsIiRsZW4iLCJ0eXBlZEFycmF5T2Zmc2V0IiwiY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yJDgiLCJpbml0IiwiY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yJDciLCJjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNiIsImNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQ1IiwiY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yJDQiLCJjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkMyIsImNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyIiwiY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEiLCJjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTJDEiLCJleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEiLCJ0eXBlZEFycmF5RnJvbSIsIkFycmF5QnVmZmVyVmlld0NvcmUiLCJUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTIiwib2YiLCJPU19WRVJTSU9OX01BSk9SIiwiVGkiLCJQbGF0Zm9ybSIsInZlcnNpb25NYWpvciIsIk9TX1ZFUlNJT05fTUlOT1IiLCJ2ZXJzaW9uTWlub3IiLCJPU19WRVJTSU9OX1BBVENIIiwidmVyc2lvblBhdGNoIiwia05vZGVNb2R1bGVzUkUiLCJjdXN0b21JbnNwZWN0U3ltYm9sIiwiZm9yIiwiaXNCdWZmZXIiLCJjb2xvclJlZ0V4cCIsInJlbW92ZUNvbG9ycyIsImlzRXJyb3IiLCJpc05hdGl2ZUVycm9yIiwiRXJyb3IiLCJnZXRTdHJ1Y3R1cmVkU3RhY2siLCJTdGFja1RyYWNlRXJyb3IiLCJwcmVwYXJlU3RhY2tUcmFjZSIsImVyciIsInRyYWNlIiwic3RhY2tUcmFjZUxpbWl0IiwiaXNJbnNpZGVOb2RlTW9kdWxlcyIsInN0YWNrIiwic3RhY2tGcmFtZXMiLCJsaW5lcyIsImxpbmUiLCJsaW5lSW5mbyIsImZpbGVuYW1lIiwiZ2V0RmlsZU5hbWUiLCJmcmFtZSIsImpvaW4kMSIsIm91dHB1dCIsInNlcGFyYXRvciIsInVuY3VycnlUaGlzIiwiQUxMX1BST1BFUlRJRVMkMiIsIk9OTFlfRU5VTUVSQUJMRSQyIiwicHJvcGVydHlGaWx0ZXIiLCJBTExfUFJPUEVSVElFUyIsIk9OTFlfRU5VTUVSQUJMRSIsImdldE93bk5vbkluZGV4UHJvcGVydGllcyIsImlzQWxsRGlnaXRzIiwicyIsImNvZGUiLCJUeXBlZEFycmF5UHJvdG90eXBlJDEiLCJUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImlzT2JqZWN0IiwiY2hlY2tQcm90b3R5cGUiLCJpc0FueUFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlciIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FyZ3VtZW50c09iamVjdCIsImlzQXJyYXlCdWZmZXJWaWV3IiwiaXNBc3luY0Z1bmN0aW9uIiwiaXNCaWdJbnQ2NEFycmF5IiwiaXNCaWdVaW50NjRBcnJheSIsImlzQm9vbGVhbk9iamVjdCIsImlzQm94ZWRQcmltaXRpdmUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0RhdGFWaWV3IiwiaXNEYXRlIiwiaXNGbG9hdDMyQXJyYXkiLCJpc0Zsb2F0NjRBcnJheSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJpc0dlbmVyYXRvck9iamVjdCIsImlzSW50OEFycmF5IiwiaXNJbnQxNkFycmF5IiwiaXNJbnQzMkFycmF5IiwiaXNNYXAiLCJpc01hcEl0ZXJhdG9yIiwiaXNQcm9taXNlIiwiaXNTZXQiLCJpc1NldEl0ZXJhdG9yIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0J1aWx0SW5UeXBlZEFycmF5IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwidHlwZXMiLCJmcmVlemUiLCJsYXp5RXJyb3IiLCJjb2RlcyIsIkVSUl9JTlRFUk5BTF9BU1NFUlRJT04iLCJhc3NlcnQkMSIsIm1lc3NhZ2UiLCJmYWlsIiwibWVzc2FnZXMiLCJNYXAiLCJTeXN0ZW1FcnJvciIsIkUiLCJzeW0iLCJkZWYiLCJtYWtlTm9kZUVycm9yV2l0aENvZGUiLCJfbGVuIiwib3RoZXJDbGFzc2VzIiwiX2tleSIsImNsYXp6IiwiQmFzZSIsIk5vZGVFcnJvciIsIl9sZW4yIiwiYXJncyIsIl9rZXkyIiwiZ2V0TWVzc2FnZSIsImFkZENvZGVUb05hbWUiLCJtc2ciLCJleHBlY3RlZExlbmd0aCIsInVuc2hpZnQiLCJmb3JtYXQkMSIsInN1ZmZpeCIsImV4cGVjdGVkIiwiYWN0dWFsIiwiZGV0ZXJtaW5lciIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsIm9uZU9mIiwibWF4U3RhY2tfRXJyb3JOYW1lIiwibWF4U3RhY2tfRXJyb3JNZXNzYWdlIiwiaXNTdGFja092ZXJmbG93RXJyb3IiLCJvdmVyZmxvd1N0YWNrIiwidGhpbmciLCJsZW4iLCJGYXN0QnVmZmVyIiwic3RyaW5nVG9IZXhCeXRlcyIsImJ5dGVBcnJheSIsIm51bWVyaWNWYWx1ZSIsInBhcnNlSW50Iiwic3Vic3RyIiwiaXNOYU4iLCJhcnJheUluZGV4SGFuZGxlciIsInByb3BLZXkiLCJyZWNlaXZlciIsIm51bSIsImlzU2FmZUludGVnZXIiLCJnZXRBZGp1c3RlZEluZGV4Iiwic2V0QWRqdXN0ZWRJbmRleCIsIl90aUJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJ0aUJ1ZmZlciIsImZyb21UaUJ1ZmZlciIsIlByb3h5IiwiZnJvbVN0cmluZyIsImVuY29kaW5nIiwiQnVmZmVyIiwiaXNFbmNvZGluZyIsImJsb2IiLCJVdGlscyIsImJhc2U2NGRlY29kZSIsImJsb2JTdHJlYW0iLCJTdHJlYW0iLCJjcmVhdGVTdHJlYW0iLCJNT0RFX1JFQUQiLCJyZWFkQWxsIiwiY3JlYXRlQnVmZmVyIiwiZ2V0VGlDb2RlY0NoYXJzZXQiLCJfc2xpY2UiLCJfZmlsbCIsInZhbHVlVHlwZSIsImJ1ZlRvRmlsbFdpdGgiLCJmaWxsQnVmTGVuZ3RoIiwiZmlsbENoYXIiLCJudW1CeXRlcyIsInRvVGlCdWZmZXIiLCJjbG9uZSIsImJ1ZiIsIlRJX0NPREVDX01BUCIsIkNvZGVjIiwiQ0hBUlNFVF9VVEY4IiwiQ0hBUlNFVF9VVEYxNkxFIiwiQ0hBUlNFVF9JU09fTEFUSU5fMSIsIkNIQVJTRVRfQVNDSUkiLCJBTExfUFJPUEVSVElFUyQxIiwiT05MWV9FTlVNRVJBQkxFJDEiLCJWQUxJRF9FTkNPRElOR1MiLCJkb3VibGVBcnJheSIsInVpbnQ4RG91YmxlQXJyYXkiLCJmbG9hdEFycmF5IiwidWludDhGbG9hdEFycmF5IiwiQnVmZmVyJDEiLCJwb29sU2l6ZSIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhcGlOYW1lIiwic2hvd0ZsYWdnZWREZXByZWNhdGlvbiIsImFsbG9jIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbUFycmF5IiwiZnJvbUJ1ZmZlciIsIm1heExlbmd0aCIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsInRvQXJyYXlCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImNvcHkiLCJjb21wYXJlIiwidGFyZ2V0U3RhcnQiLCJ0YXJnZXRFbmQiLCJzb3VyY2VTdGFydCIsInNvdXJjZUVuZCIsImJ1ZjEiLCJzb3VyY2VMZW5ndGgiLCJkZXN0IiwiZGVzdExlbmd0aCIsInRhcmdldFZhbHVlIiwic291cmNlVmFsdWUiLCJyZW1haW5pbmciLCJzb3VyY2VMZW4iLCJlbnRyaWVzIiwibmV4dEluZGV4IiwiZW50cnlJdGVyYXRvciIsImVxdWFscyIsIm90aGVyQnVmZmVyIiwib2Zmc2V0VHlwZSIsIlR5cGVkQXJyYXlQcm90b19ieXRlTGVuZ3RoIiwiVHlwZWRBcnJheUZpbGwiLCJieXRlTGVuIiwiZmlsbExlbmd0aCIsIm1hdGNoTGVuZ3RoIiwiY3VycmVudEluZGV4IiwidGhpc0xlbmd0aCIsImZpcnN0TWF0Y2giLCJmaXJzdEJ5dGVNYXRjaCIsIm15SXRlcmF0b3IiLCJyZWFkRG91YmxlQkUiLCJjaGVja09mZnNldCIsInJlYWREb3VibGVMRSIsInJlYWRGbG9hdEJFIiwicmVhZEZsb2F0TEUiLCJyZWFkSW50OCIsInVuc2lnbmVkVmFsdWUiLCJyZWFkVUludDgiLCJ1bnNpZ25lZFRvU2lnbmVkIiwicmVhZEludDE2QkUiLCJyZWFkVUludDE2QkUiLCJyZWFkSW50MTZMRSIsInJlYWRVSW50MTZMRSIsInJlYWRJbnQzMkJFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludDMyTEUiLCJyZWFkVUludDMyTEUiLCJyZWFkSW50QkUiLCJyZWFkVUludEJFIiwicmVhZEludExFIiwicmVhZFVJbnRMRSIsIm11bHRpcGxpZXIiLCJzdWJhcnJheSIsInN3YXAxNiIsInN3YXAzMiIsInRoaXJkIiwiZm91cnRoIiwic3dhcDY0IiwiZmlmdGgiLCJzaXh0aCIsInNldmVudGgiLCJlaWdodGgiLCJ0b0pTT04iLCJiYXNlNjRlbmNvZGUiLCJ0b0Jsb2IiLCJoZXhTbGljZSIsImxhdGluMVN0cmluZyIsImZyb21DaGFyQ29kZSIsImFzY2lpIiwidWNzMlNsaWNlIiwiaGV4U3RyIiwiaGV4Iiwib3V0IiwiYnl0ZTEiLCJieXRlMiIsImNvZGVfdW5pdCIsImZyb21Db2RlUG9pbnQiLCJjb3B5QnVmZmVyIiwic3JjTGVuZ3RoIiwiZGVzdEluZGV4IiwidmFsdWVzIiwid3JpdGVEb3VibGVCRSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUludDgiLCJjaGVja1ZhbHVlIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQzMkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnRCRSIsIm1pbk1heEJhc2UiLCJieXRlVmFsdWUiLCJ3cml0ZUludExFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludExFIiwiYWxsb2NVbnNhZmVTbG93IiwidXRmOEJ5dGVMZW5ndGgiLCJidWYyIiwidG90YWxMZW5ndGgiLCJJTlNQRUNUX01BWF9CWVRFUyIsInJlY3Vyc2VUaW1lcyIsImN0eCIsImFjdHVhbE1heCIsInRyaW0iLCJleHRyYXMiLCJzaG93SGlkZGVuIiwicmVkdWNlIiwiaW5zcGVjdCIsImJyZWFrTGVuZ3RoIiwiY29tcGFjdCIsIkFycmF5QnVmZmVySXNWaWV3IiwiQnVmZmVyTW9kdWxlIiwidHJhbnNjb2RlIiwiX3NvdXJjZSIsIl9mcm9tRW5jb2RpbmciLCJfdG9FbmNvZGluZyIsImtNYXhMZW5ndGgiLCJrU3RyaW5nTWF4TGVuZ3RoIiwiY29uc3RhbnRzIiwiTUFYX0xFTkdUSCIsIk1BWF9TVFJJTkdfTEVOR1RIIiwic2luZ2xlQnl0ZSIsImJpdExlbmd0aCIsIm1heFBvc2l0aXZlVmFsdWUiLCJtYXhVbnNpZ25lZFZhbHVlIiwicmVsZWFzZSIsImVuZE9mZnNldCIsImJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCIsIm5vZGVNb2R1bGVzQ2hlY2tDb3VudGVyIiwiYnVmZmVyV2FybmluZyIsImVtaXRXYXJuaW5nIiwiQm9vbGVhblByb3RvdHlwZSIsIkJvb2xlYW4iLCJEYXRlUHJvdG90eXBlIiwiRGF0ZSIsIkVycm9yUHJvdG90eXBlIiwiTnVtYmVyUHJvdG90eXBlIiwiTWFwUHJvdG90eXBlIiwiUmVnRXhwUHJvdG90eXBlIiwiU3RyaW5nUHJvdG90eXBlIiwiU2V0UHJvdG90eXBlIiwiU2V0IiwiU3ltYm9sUHJvdG90eXBlIiwiaXNJb3MiLCJvc25hbWUiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImJ1aWx0SW5PYmplY3RzIiwiaW5zcGVjdERlZmF1bHRPcHRpb25zIiwic2VhbCIsImRlcHRoIiwiY29sb3JzIiwiY3VzdG9tSW5zcGVjdCIsInNob3dQcm94eSIsIm1heEFycmF5TGVuZ3RoIiwic29ydGVkIiwiZ2V0dGVycyIsImtPYmplY3RUeXBlIiwia0FycmF5VHlwZSIsImtBcnJheUV4dHJhc1R5cGUiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciIsInN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSIsInN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlIiwia2V5U3RyUmVnRXhwIiwibnVtYmVyUmVnRXhwIiwibm9kZU1vZHVsZXNSZWdFeHAiLCJrTWluTGluZUxlbmd0aCIsImtXZWFrIiwia0l0ZXJhdG9yIiwia01hcEVudHJpZXMiLCJtZXRhIiwiZ2V0VXNlck9wdGlvbnMiLCJzdHlsaXplIiwidXNlck9wdGlvbnMiLCJvcHRzIiwiYnVkZ2V0IiwiaW5kZW50YXRpb25MdmwiLCJzZWVuIiwiY3VycmVudERlcHRoIiwic3R5bGl6ZU5vQ29sb3IiLCJvcHRLZXlzIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwiY3VzdG9tIiwiYXNzaWduIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImludmVyc2UiLCJ3aGl0ZSIsImdyZXkiLCJibGFjayIsImJsdWUiLCJjeWFuIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwic3R5bGVzIiwic3BlY2lhbCIsImJpZ2ludCIsImJvb2xlYW4iLCJudWxsIiwiZGF0ZSIsIm1vZHVsZSIsImFkZFF1b3RlcyIsInF1b3RlcyIsImVzY2FwZUZuIiwic3RyRXNjYXBlIiwiZXNjYXBlVGVzdCIsImVzY2FwZVJlcGxhY2UiLCJzaW5nbGVRdW90ZSIsImxhc3QiLCJwb2ludCIsInN0eWxlVHlwZSIsImNvbG9yIiwiZ2V0RW1wdHlGb3JtYXRBcnJheSIsImdldENvbnN0cnVjdG9yTmFtZSIsIl9jdHgiLCJmaXJzdFByb3RvIiwiZ2V0UHJlZml4IiwiZmFsbGJhY2siLCJnZXRLZXlzIiwiZ2V0Q3R4U3R5bGUiLCJmaW5kVHlwZWRDb25zdHJ1Y3RvciIsImxhenlOdWxsUHJvdG90eXBlQ2FjaGUiLCJjbGF6eldpdGhOdWxsUHJvdG90eXBlIiwiY2FjaGVkQ2xhc3MiLCJOdWxsUHJvdG90eXBlIiwibm9Qcm90b3R5cGVJdGVyYXRvciIsIm5ld1ZhbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJmb3JtYXRSYXciLCJ0eXBlZEFycmF5IiwiZm9ybWF0UHJpbWl0aXZlIiwiY29udGV4dCIsIm1heWJlQ3VzdG9tIiwicmV0IiwicmVwZWF0IiwiY2lyY3VsYXIiLCJiYXNlIiwiZm9ybWF0dGVyIiwiYnJhY2VzIiwibm9JdGVyYXRvciIsImV4dHJhc1R5cGUiLCJwcmVmaXgiLCJmb3JtYXRBcnJheSIsImZvcm1hdFNldCIsImZvcm1hdE1hcCIsImZvcm1hdFR5cGVkQXJyYXkiLCJnZXRJdGVyYXRvckJyYWNlcyIsImZvcm1hdEl0ZXJhdG9yIiwiZ2V0RnVuY3Rpb25CYXNlIiwicmVnRXhwIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiZm9ybWF0RXJyb3IiLCJuYXRpdmVFcnJvclByb3BzIiwiYXJyYXlUeXBlIiwiZm9ybWF0QXJyYXlCdWZmZXIiLCJmb3JtYXROdW1iZXIiLCJmb3JtYXRQcm9taXNlIiwiZm9ybWF0V2Vha1NldCIsImZvcm1hdFdlYWtDb2xsZWN0aW9uIiwiZm9ybWF0V2Vha01hcCIsImdldEJveGVkQmFzZSIsInNwZWNpYWxJdGVyYXRvciIsImNvbnN0cnVjdG9yTmFtZSIsImZvcm1hdFByb3BlcnR5IiwiaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZSIsInJlZmVyZW5jZSIsInBvcCIsImNvbXBhcmF0b3IiLCJzb3J0Iiwic3BsaWNlIiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJuZXdMZW5ndGgiLCJzdGFja0xpbmUiLCJhdFN5bWJvbEluZGV4Iiwic291cmNlUGF0dGVybiIsInN5bWJvbE5hbWUiLCJzb3VyY2VNYXRjaCIsImZpbGVQYXRoIiwibGluZU51bWJlciIsImNvbHVtbiIsIkZpbGVzeXN0ZW0iLCJyZXNvdXJjZXNEaXJlY3RvcnkiLCJzdGFja1N0YXJ0IiwibmV3U3RhY2siLCJub2RlTW9kdWxlIiwiaW5kZW50YXRpb24iLCJfdmFsdWUiLCJfcmVjdXJzZVRpbWVzIiwiZXh0cmEiLCJkZXNjIiwiZGlmZiIsImxhYmVsIiwic3AiLCJ0bXAiLCJwcmltaXRpdmUiLCJncm91cEFycmF5RWxlbWVudHMiLCJvdXRwdXRMZW5ndGgiLCJzZXBhcmF0b3JTcGFjZSIsImRhdGFMZW4iLCJhcHByb3hDaGFySGVpZ2h0cyIsImF2ZXJhZ2VCaWFzIiwic3FydCIsImJpYXNlZE1heCIsImNvbHVtbnMiLCJtYXhMaW5lTGVuZ3RoIiwibGluZU1heExlbmd0aCIsIm9yZGVyIiwicGFkZGluZyIsInBhZFN0YXJ0IiwiaXMiLCJmb3JtYXRCaWdJbnQiLCJmb3JtYXRTcGVjaWFsQXJyYXkiLCJlbXB0eUl0ZW1zIiwiZW5kaW5nIiwidmFsTGVuIiwiZWxlbWVudEZvcm1hdHRlciIsInYiLCJmb3JtYXRTZXRJdGVySW5uZXIiLCJmb3JtYXRNYXBJdGVySW5uZXIiLCJfa2V5cyIsImlzS2V5VmFsdWUiLCJjdXJyZW50RW50cnkiLCJpc0JlbG93QnJlYWtMZW5ndGgiLCJsbiIsImZvcm1hdFdpdGhPcHRpb25zIiwiZmlyc3RFcnJvckxpbmUiLCJDSVJDVUxBUl9FUlJPUl9NRVNTQUdFIiwidHJ5U3RyaW5naWZ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImluc3BlY3RPcHRpb25zIiwidGVtcFN0ciIsImxhc3RQb3MiLCJuZXh0Q2hhciIsInRlbXBBcmciLCJjb25zdHIiLCJ0ZW1wTnVtIiwidGVtcEludGVnZXIiLCJ0ZW1wRmxvYXQiLCJwYXJzZUZsb2F0Iiwibm9vcCQxIiwibG9nVGltZSIsImxvZ0RhdGEiLCJzdGFydFRpbWUiLCJfdGltZXMiLCJkdXJhdGlvbiIsIm5vdyIsImtDb2xvckluc3BlY3RPcHRpb25zIiwia05vQ29sb3JJbnNwZWN0T3B0aW9ucyIsInRhYmxlV2FybmVkIiwiY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIiLCJzdHJlYW0iLCJfd3JpdGFibGVTdGF0ZSIsImVycm9yRW1pdHRlZCIsImxpc3RlbmVyQ291bnQiLCJvbmNlIiwiQ29uc29sZSIsInN0ZGVyciIsImlnbm9yZUVycm9ycyIsIl9hcGlNb2R1bGUiLCJzdGRvdXQiLCJfc3Rkb3V0IiwiX3N0ZGVyciIsIl9pZ25vcmVFcnJvcnMiLCJfc3Rkb3V0RXJyb3JIYW5kbGVyIiwiX3N0ZGVyckVycm9ySGFuZGxlciIsIl9jb2xvck1vZGUiLCJjb2xvck1vZGUiLCJfaW5zcGVjdE9wdGlvbnMiLCJfY291bnRzIiwiX2dyb3VwSW5kZW50IiwiX3dyaXRlVG9Db25zb2xlIiwibGV2ZWwiLCJ1c2VTdGRFcnIiLCJlcnJvckhhbmRsZXIiLCJyZW1vdmVMaXN0ZW5lciIsImluZm8iLCJ3YXJuIiwiX2xlbjMiLCJfa2V5MyIsImRlYnVnIiwiX2xlbjQiLCJfa2V5NCIsIl9sZW41IiwiX2tleTUiLCJjbGVhciIsImdyb3VwRW5kIiwiZGlyIiwiYXNzZXJ0IiwiX2xlbjYiLCJfa2V5NiIsImNvdW50UmVzZXQiLCJkZWxldGUiLCJ0aW1lIiwidGltZUVuZCIsIndhcm5lZCIsInRpbWVMb2ciLCJfbGVuNyIsIl9rZXk3IiwidGFibGUiLCJkaXJ4bWwiLCJncm91cENvbGxhcHNlZCIsImdsb2JhbENvbnNvbGUiLCJBUEkiLCJjb25zb2xlIiwicHJvcGVydGllcyIsImJpbmRpbmdzIiwicmVkaXJlY3RzIiwiaXNIaWphY2thYmxlTW9kdWxlSWQiLCJwYXRoIiwiZmlyc3RDaGFyIiwib3JpZ2luYWxSZXF1aXJlIiwicmVxdWlyZSIsIm1haW4iLCJtb2R1bGVJZCIsIm9yaWdpbmFsTW9kdWxlUmVxdWlyZSIsIk1vZHVsZSIsInJlZ2lzdGVyIiwiYmluZGluZyIsInJlZGlyZWN0IiwiZmlsZXBhdGgiLCJCbG9iUHJvdG90eXBlIiwidGV4dCIsIkhFWF8zX1JFR0VYIiwiSEVYXzRfUkVHRVgiLCJIRVhfNl9SRUdFWCIsIkhFWF84X1JFR0VYIiwicGFkZGVkSGV4IiwiQ29sb3IiLCJyIiwiZyIsImIiLCJhbHBoYSIsImlzT3BhcXVlIiwiYWxwaGFIZXgiLCJfdG9SR0JIZXhTdHJpbmciLCJ0b1JHQkFIZXhTdHJpbmciLCJ0b0FSR0JIZXhTdHJpbmciLCJ0b0hleCIsInRvUkdCQVN0cmluZyIsInRvRml4ZWQiLCJmcm9tSGV4NlN0cmluZyIsInN0YXJ0SW5kZXgiLCJmcm9tSGV4OFN0cmluZyIsImZyb21TZW1hbnRpY0NvbG9yc0VudHJ5IiwiZW50cnkiLCJoYWRBbHBoYSIsImlzSU9TMTNQbHVzIiwiaXNNYWNPUyIsImlzTUFDT1NYQ2F0YWxpbmFQbHVzIiwiVUkiLCJ1c2VySW50ZXJmYWNlU3R5bGUiLCJVU0VSX0lOVEVSRkFDRV9TVFlMRV9EQVJLIiwiU0VNQU5USUNfQ09MT1JfVFlQRV9EQVJLIiwiU0VNQU5USUNfQ09MT1JfVFlQRV9MSUdIVCIsImNvbG9yc2V0IiwiZmV0Y2hTZW1hbnRpY0NvbG9yIiwiY29sb3JOYW1lIiwiY29sb3JzZXRGaWxlTmFtZSIsImNvbG9yc2V0RmlsZSIsImdldEZpbGUiLCJleGlzdHMiLCJzZW1hbnRpY0NvbG9yVHlwZSIsImNvbG9yT2JqIiwidGFiIiwiVGl0YW5pdW0iLCJjcmVhdGVUYWIiLCJUYWJQcm90b3R5cGUiLCJzZXRXaW5kb3ciLCJfYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwiZXZlbnROYW1lIiwibGlzdGVuZXIiLCJwcmVwZW5kIiwiX2V2ZW50c1RvTGlzdGVuZXJzIiwibmV3TGlzdGVuZXIiLCJlbWl0IiwiZXZlbnRMaXN0ZW5lcnMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJ3Iiwib25jZVdyYXAiLCJ3cmFwcGVkRnVuYyIsIndyYXBwZXJUaGlzIiwiYm91bmQiLCJFdmVudEVtaXR0ZXIiLCJfbWF4TGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJmb3VuZEluZGV4IiwidW53cmFwcGVkTGlzdGVuZXIiLCJvZmYiLCJldmVudE5hbWVzIiwibGlzdGVuZXJzIiwibCIsInJhd0xpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhc3NlcnRBcmd1bWVudFR5cGUiLCJ0eXBlbmFtZSIsInN0YW5kYXJkaXplQXJjaCIsIm9yaWdpbmFsIiwicHJvY2VzcyQxIiwiYWJvcnQiLCJhcmNoIiwiYXJjaGl0ZWN0dXJlIiwiYXJndiIsImNoYW5uZWwiLCJjaGRpciIsImNvbmZpZyIsImNvbm5lY3RlZCIsImNwdVVzYWdlIiwidXNlciIsInN5c3RlbSIsImN3ZCIsIl9fZGlybmFtZSIsImFzc2V0cyIsImtyb2xsIiwianNvbiIsInJlYWRBc3NldCIsImRlcGxveURhdGEiLCJwYXJzZSIsImRlYnVnZ2VyUG9ydCIsImRpc2Nvbm5lY3QiLCJkbG9wZW4iLCJ3YXJuaW5nIiwiY3RvciIsImRldGFpbCIsImlzRGVwcmVjYXRpb24iLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsImxvYWRFbnZKc29uIiwianNvbkZpbGUiLCJyZWFkIiwiZW52IiwiZXhlY0FyZ3YiLCJleGVjUGF0aCIsImV4aXQiLCJleGl0Q29kZSIsInBpZCIsInBsYXRmb3JtIiwicHBpZCIsImlzVFRZIiwiY2h1bmsiLCJjYWxsYmFjayIsInRpdGxlIiwiQXBwIiwidHJhY2VEZXByZWNhdGlvbiIsInVtYXNrIiwidXB0aW1lIiwiZGlmZk1zIiwibW9kdWxlcyIsImpzYyIsIldBUk5JTkdfUFJFRklYIiwidW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayIsImhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrIiwic2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJiYWNrdHJhY2UiLCJmaWxlTmFtZSIsInNvdXJjZU5hbWUiLCJjb2x1bW5OdW1iZXIiLCJsaW5lT2Zmc2V0IiwiQ2FsbGJhY2tXaXRoQXJncyIsInJ1biIsImZ1biIsInRpY2tRdWV1ZSIsImltbWVkaWF0ZVF1ZXVlIiwiZHJhaW5pbmdUaWNrUXVldWUiLCJkcmFpblF1ZXVlc1RpbWVvdXQiLCJkcmFpblRpY2tRdWV1ZSIsInRpY2siLCJzaGlmdCIsImRyYWluUXVldWVzIiwiaW1tZWRpYXRlc1JlbWFpbmluZyIsInByb2Nlc3NJbW1lZGlhdGVRdWV1ZSIsInNldFRpbWVvdXQiLCJpbW1lZGlhdGVEZWFkbGluZSIsImltbWVkaWF0ZSIsIm5leHRUaWNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJGT1JXQVJEX1NMQVNIIiwiQkFDS1dBUkRfU0xBU0giLCJpc1dpbmRvd3NEZXZpY2VOYW1lIiwiY2hhckNvZGUiLCJpc0Fic29sdXRlIiwiaXNQb3NpeCIsInRoaXJkQ2hhciIsImRpcm5hbWUiLCJoYWRUcmFpbGluZyIsImxhc3RJbmRleE9mIiwiZXh0bmFtZSIsImVuZEluZGV4IiwibGFzdEluZGV4V2luMzJTZXBhcmF0b3IiLCJjaGFyIiwiYmFzZW5hbWUiLCJleHQiLCJsYXN0Q2hhckNvZGUiLCJpc1dpbmRvd3MiLCJoYWRMZWFkaW5nIiwiaXNVTkMiLCJwYXJ0cyIsInNlZ21lbnQiLCJub3JtYWxpemVkIiwiYXNzZXJ0U2VnbWVudCIsInBhdGhzIiwicmVzb2x2ZWQiLCJoaXRSb290IiwicmVsYXRpdmUiLCJ0byIsInVwQ291bnQiLCJyZW1haW5pbmdQYXRoIiwicm9vdCIsImJhc2VMZW5ndGgiLCJ0b1N1YnRyYWN0IiwiZmlyc3RDaGFyQ29kZSIsInRoaXJkQ2hhckNvZGUiLCJmb3JtYXQiLCJwYXRoT2JqZWN0IiwidG9OYW1lc3BhY2VkUGF0aCIsInJlc29sdmVkUGF0aCIsIldpbjMyUGF0aCIsInNlcCIsImRlbGltaXRlciIsIlBvc2l4UGF0aCIsIndpbjMyIiwicG9zaXgiLCJpc0FuZHJvaWQkMSIsImlzSU9TIiwiUG9zaXhDb25zdGFudHMiLCJVVl9VRFBfUkVVU0VBRERSIiwiZXJybm8iLCJFMkJJRyIsIkVBQ0NFUyIsIkVBRERSSU5VU0UiLCJFQUREUk5PVEFWQUlMIiwiRUFGTk9TVVBQT1JUIiwiRUFHQUlOIiwiRUFMUkVBRFkiLCJFQkFERiIsIkVCQURNU0ciLCJFQlVTWSIsIkVDQU5DRUxFRCIsIkVDSElMRCIsIkVDT05OQUJPUlRFRCIsIkVDT05OUkVGVVNFRCIsIkVDT05OUkVTRVQiLCJFREVBRExLIiwiRURFU1RBRERSUkVRIiwiRURPTSIsIkVEUVVPVCIsIkVFWElTVCIsIkVGQVVMVCIsIkVGQklHIiwiRUhPU1RVTlJFQUNIIiwiRUlEUk0iLCJFSUxTRVEiLCJFSU5QUk9HUkVTUyIsIkVJTlRSIiwiRUlOVkFMIiwiRUlPIiwiRUlTQ09OTiIsIkVJU0RJUiIsIkVMT09QIiwiRU1GSUxFIiwiRU1MSU5LIiwiRU1TR1NJWkUiLCJFTVVMVElIT1AiLCJFTkFNRVRPT0xPTkciLCJFTkVURE9XTiIsIkVORVRSRVNFVCIsIkVORVRVTlJFQUNIIiwiRU5GSUxFIiwiRU5PQlVGUyIsIkVOT0RBVEEiLCJFTk9ERVYiLCJFTk9FTlQiLCJFTk9FWEVDIiwiRU5PTENLIiwiRU5PTElOSyIsIkVOT01FTSIsIkVOT01TRyIsIkVOT1BST1RPT1BUIiwiRU5PU1BDIiwiRU5PU1IiLCJFTk9TVFIiLCJFTk9TWVMiLCJFTk9UQ09OTiIsIkVOT1RESVIiLCJFTk9URU1QVFkiLCJFTk9UU09DSyIsIkVOT1RTVVAiLCJFTk9UVFkiLCJFTlhJTyIsIkVPUE5PVFNVUFAiLCJFT1ZFUkZMT1ciLCJFUEVSTSIsIkVQSVBFIiwiRVBST1RPIiwiRVBST1RPTk9TVVBQT1JUIiwiRVBST1RPVFlQRSIsIkVSQU5HRSIsIkVST0ZTIiwiRVNQSVBFIiwiRVNSQ0giLCJFU1RBTEUiLCJFVElNRSIsIkVUSU1FRE9VVCIsIkVUWFRCU1kiLCJFV09VTERCTE9DSyIsIkVYREVWIiwic2lnbmFscyIsIlNJR0hVUCIsIlNJR0lOVCIsIlNJR1FVSVQiLCJTSUdJTEwiLCJTSUdUUkFQIiwiU0lHQUJSVCIsIlNJR0lPVCIsIlNJR0JVUyIsIlNJR0ZQRSIsIlNJR0tJTEwiLCJTSUdVU1IxIiwiU0lHU0VHViIsIlNJR1VTUjIiLCJTSUdQSVBFIiwiU0lHQUxSTSIsIlNJR1RFUk0iLCJTSUdDSExEIiwiU0lHQ09OVCIsIlNJR1NUT1AiLCJTSUdUU1RQIiwiU0lHVFRJTiIsIlNJR1RUT1UiLCJTSUdVUkciLCJTSUdYQ1BVIiwiU0lHWEZTWiIsIlNJR1ZUQUxSTSIsIlNJR1BST0YiLCJTSUdXSU5DSCIsIlNJR0lPIiwiU0lHSU5GTyIsIlNJR1NZUyIsInByaW9yaXR5IiwiUFJJT1JJVFlfTE9XIiwiUFJJT1JJVFlfQkVMT1dfTk9STUFMIiwiUFJJT1JJVFlfTk9STUFMIiwiUFJJT1JJVFlfQUJPVkVfTk9STUFMIiwiUFJJT1JJVFlfSElHSCIsIlBSSU9SSVRZX0hJR0hFU1QiLCJPUyIsIkVPTCIsImNwdXMiLCJwcm9jZXNzb3JDb3VudCIsImFycmF5IiwibW9kZWwiLCJzcGVlZCIsInRpbWVzIiwibmljZSIsInN5cyIsImlkbGUiLCJpcnEiLCJlbmRpYW5uZXNzIiwiZ2V0TmF0aXZlQnl0ZU9yZGVyIiwiTElUVExFX0VORElBTiIsImZyZWVtZW0iLCJhdmFpbGFibGVNZW1vcnkiLCJnZXRQcmlvcml0eSIsImhvbWVkaXIiLCJhcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnkiLCJob3N0bmFtZSIsImFkZHJlc3MiLCJsb2FkYXZnIiwibmV0d29ya0ludGVyZmFjZXMiLCJzZXRQcmlvcml0eSIsInRtcGRpciIsInRlbXBEaXJlY3RvcnkiLCJ0b3RhbG1lbSIsInRvdGFsTWVtb3J5IiwidXNlckluZm8iLCJnaWQiLCJ1c2VybmFtZSIsInNoZWxsIiwiQXBwbGVNYXAiLCJjcHVNb2RlbEFuZFNwZWVkIiwidHJpbW1lZCIsIm1vZGVsQW5kU3BlZWQiLCJ0dHkiLCJpc2F0dHkiLCJSZWFkU3RyZWFtIiwiV3JpdGVTdHJlYW0iLCJNT05USFMiLCJ1dGlsIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdW1iZXIiLCJpc1ByaW1pdGl2ZSIsImlzU3RyaW5nIiwiaXNVbmRlZmluZWQiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwicHJpbnQiLCJwdXRzIiwiaW5oZXJpdHMiLCJzdXBlckNvbnN0cnVjdG9yIiwicHJvbWlzaWZ5Iiwid3JhcHBlZCIsImNhbGxiYWNraWZ5IiwiY2F0Y2giLCJ3cmFwcGVkRXJyb3IiLCJyZWFzb24iLCJkZXByZWNhdGUiLCJub29wIiwiZGVidWdsb2ciLCJERUZBVUxUX01FU1NBR0VTIiwiZGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJkZWVwRXF1YWwiLCJlcXVhbCIsIm5vdERlZXBTdHJpY3RFcXVhbCIsIm5vdFN0cmljdEVxdWFsIiwibm90RGVlcEVxdWFsIiwibm90RXF1YWwiLCJDT01QQVJFX1RZUEUiLCJTVFJJQ1RORVNTIiwiU3RyaWN0IiwiTG9vc2UiLCJBc3NlcnRpb25FcnJvciIsIm9wZXJhdG9yIiwiZ2VuZXJhdGVkTWVzc2FnZSIsIm9rIiwidGhyb3dFcnJvciIsImNvbXBhcmVNYXBzIiwic3RyaWN0bmVzcyIsInJlZmVyZW5jZXMiLCJsb29zZUNoZWNrcyIsImFkZCIsImV4cGVjdGVkS2V5IiwiZXhwZWN0ZWRWYWx1ZSIsImZvdW5kIiwiY29tcGFyZVNldHMiLCJhY3R1YWxUYWciLCJleHBlY3RlZFRhZyIsImFjdHVhbFByb3RvdHlwZSIsImV4cGVjdGVkUHJvdG90eXBlIiwiY29tcGFyaXNvbiIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJOT19FWENFUFRJT04iLCJleGVjdXRlIiwiaXNQcm9taXNlTGlrZSIsImV4ZWN1dGVQcm9taXNlIiwiZm5UeXBlIiwidGhyb3dzIiwiY2hlY2tFcnJvciIsInJlamVjdHMiLCJhc3luY0ZuIiwiZG9lc05vdFRocm93IiwiZG9lc05vdFJlamVjdCIsImlmRXJyb3IiLCJzdHJpY3QiLCJTdHJpbmdEZWNvZGVyIiwiX2ltcGwiLCJVdGY4U3RyaW5nRGVjb2RlciIsIlV0ZjE2U3RyaW5nRGVjb2RlciIsIkJhc2U2NFN0cmluZ0RlY29kZXIiLCJTdHJpbmdEZWNvZGVySW1wbCIsImJ5dGVDb3VudCIsImNoYXJMZW5ndGgiLCJNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCIsImJ5dGVzUGVyQ2hhciIsImluY29tcGxldGUiLCJfY2hlY2tJbmNvbXBsZXRlQnl0ZXMiLCJfYnVmZmVyIiwiX2luY29tcGxldGVFbmQiLCJfaW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQiLCJsZWZ0IiwiYnl0ZXNDb3BpZWQiLCJpbmNvbXBsZXRlQ2hhckRhdGEiLCJieXRlc05lZWRlZCIsImluY29tcGxldGVDaGFySW5kZXgiLCJieXRlc1RvQ29weSIsImNoZWNrQ2hhckxlbmd0aEZvclVURjgiLCJtb2R1bG8iLCJieXRlIiwiU3RyaW5nRGVjb2RlciQxIiwiaXNBbmRyb2lkIiwicHJpbnRlZFdhcm5pbmdzIiwib25lVGltZVdhcm5pbmciLCJ1bnN1cHBvcnRlZE5vb3AiLCJtb2R1bGVOYW1lIiwiZnFuIiwiYXN5bmNVbnN1cHBvcnRlZE5vb3AiLCJtYXliZUNhbGxiYWNrIiwiQ09QWV9GSUxFX0NIVU5LX1NJWkUiLCJmaWxlRGVzY3JpcHRvcnMiLCJmaWxlRGVzY3JpcHRvckNvdW50IiwiRkxBR1NfVE9fVElfTU9ERSIsIk1PREVfQVBQRU5EIiwiTU9ERV9XUklURSIsInBlcm1pc3Npb25EZW5pZWQiLCJzeXNjYWxsIiwibWFrZUVycm9yIiwibm9TdWNoRmlsZSIsImZpbGVBbHJlYWR5RXhpc3RzIiwibm90QURpcmVjdG9yeSIsImRpcmVjdG9yeU5vdEVtcHR5IiwiaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSIsImZzIiwiT19SRE9OTFkiLCJPX1dST05MWSIsIk9fUkRXUiIsIlNfSUZNVCIsIlNfSUZSRUciLCJTX0lGRElSIiwiU19JRkNIUiIsIlNfSUZCTEsiLCJTX0lGSUZPIiwiU19JRkxOSyIsIlNfSUZTT0NLIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fTk9DVFRZIiwiT19UUlVOQyIsIk9fQVBQRU5EIiwiT19ESVJFQ1RPUlkiLCJPX05PRk9MTE9XIiwiT19TWU5DIiwiT19EU1lOQyIsIk9fU1lNTElOSyIsIk9fTk9OQkxPQ0siLCJTX0lSV1hVIiwiU19JUlVTUiIsIlNfSVdVU1IiLCJTX0lYVVNSIiwiU19JUldYRyIsIlNfSVJHUlAiLCJTX0lXR1JQIiwiU19JWEdSUCIsIlNfSVJXWE8iLCJTX0lST1RIIiwiU19JV09USCIsIlNfSVhPVEgiLCJGX09LIiwiUl9PSyIsIldfT0siLCJYX09LIiwiVVZfRlNfQ09QWUZJTEVfRVhDTCIsIkNPUFlGSUxFX0VYQ0wiLCJTdGF0cyIsIl9maWxlIiwiZGV2IiwiaW5vIiwibmxpbmsiLCJyZGV2IiwiYmxrc2l6ZSIsImJsb2NrcyIsImF0aW1lTXMiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmlydGh0aW1lIiwiZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUiLCJjcmVhdGVkQXQiLCJtb2RpZmllZEF0IiwiaXNGaWxlIiwiaXNEaXJlY3RvcnkiLCJpc0Jsb2NrRGV2aWNlIiwiaXNDaGFyYWN0ZXJEZXZpY2UiLCJpc1N5bWJvbGljTGluayIsInN5bWJvbGljTGluayIsImlzRklGTyIsImlzU29ja2V0IiwiYWNjZXNzIiwiYWNjZXNzU3luYyIsImZpbGVIYW5kbGUiLCJleGVjdXRhYmxlIiwiYXBwZW5kRmlsZSIsImZpbGUiLCJtZXJnZURlZmF1bHRPcHRpb25zIiwiZmxhZyIsIndyaXRlRmlsZSIsImFwcGVuZEZpbGVTeW5jIiwid3JpdGVGaWxlU3luYyIsImNobW9kIiwiY2htb2RTeW5jIiwiY2hvd24iLCJjaG93blN5bmMiLCJmZCIsImNsb3NlU3luYyIsInN0cmVhbUZvckRlc2NyaXB0b3IiLCJjb3B5RmlsZSIsInNyY0ZpbGUiLCJzcmNTdHJlYW0iLCJkZXN0RmlsZSIsImRlc3RTdHJlYW0iLCJwaXBlIiwiY29weUZpbGVTeW5jIiwiZXhpc3RzU3luYyIsImZjaG1vZCIsImZjaG1vZFN5bmMiLCJmY2hvd24iLCJmY2hvd25TeW5jIiwiZmRhdGFzeW5jIiwiZmRhdGFzeW5jU3luYyIsImZzdGF0Iiwic3RhdHMiLCJmc3RhdFN5bmMiLCJfb3B0aW9ucyIsInBhdGhGb3JGaWxlRGVzY3JpcHRvciIsInN0YXRTeW5jIiwibHN0YXQiLCJsc3RhdFN5bmMiLCJta2RpciIsInJlY3Vyc2l2ZSIsIm1rZGlyU3luYyIsInRpRmlsZSIsImNyZWF0ZURpcmVjdG9yeSIsIm1rZHRlbXAiLCJ0cnlNa2R0ZW1wIiwiZ2VuZXJhdGVkIiwicmFuZG9tQ2hhcmFjdGVycyIsIm1rZHRlbXBTeW5jIiwicmV0cnlDb3VudCIsIk1BWF9SRVRSSUVTIiwiZmlsZURlc2NyaXB0b3IiLCJvcGVuU3luYyIsImNyZWF0ZUZpbGUiLCJwYXJlbnQiLCJ0aU1vZGUiLCJjcmVhdGVGaWxlRGVzY3JpcHRvciIsInRpRmlsZVN0cmVhbSIsInJlYWRPYmoiLCJzdWNjZXNzIiwiYnl0ZXNQcm9jZXNzZWQiLCJyZWFkU3luYyIsIl9wb3NpdGlvbiIsImZpbGVTdHJlYW0iLCJyZWFkZGlyIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwibGlzdGluZyIsImdldERpcmVjdG9yeUxpc3RpbmciLCJyZWFkRmlsZVBvc3RPcGVuIiwiZmlsZVNpemUiLCJzb3VyY2VTdHJlYW0iLCJyZWFkQWxsT2JqIiwicmVhZEZpbGUiLCJ3YXNGaWxlRGVzY3JpcHRvciIsImhhbmRsZUJ1ZmZlciIsImVuY29kZUJ1ZmZlciIsInJlYWRGaWxlU3luYyIsInJlYWxwYXRoIiwicmVzdWx0RXhpc3RzIiwic2VnbWVudHMiLCJwYXJ0aWFsRmlsZVBhdGgiLCJ0cnlQYXRoIiwicGFydGlhbEV4aXN0cyIsIm5hdGl2ZSIsInJlYWxwYXRoU3luYyIsInJlbmFtZSIsIm9sZFBhdGgiLCJuZXdQYXRoIiwicmVuYW1lU3luYyIsInRlbXBQYXRoIiwibW92ZSIsInVubGluayIsIl9lcnIiLCJ0bXBGaWxlIiwicm1kaXIiLCJybWRpclN5bmMiLCJkZWxldGVEaXJlY3RvcnkiLCJzdWJGaWxlcyIsInN5bWxpbmsiLCJzeW1saW5rU3luYyIsInRydW5jYXRlIiwiYnl0ZXNSZWFkIiwidHJ1bmNhdGVTeW5jIiwidW5saW5rU3luYyIsImRlbGV0ZUZpbGUiLCJ1bndhdGNoRmlsZSIsInV0aW1lcyIsInV0aW1lc1N5bmMiLCJ3YXRjaCIsIndhdGNoRmlsZSIsImZpbmlzaCIsIndyaXRlU3luYyIsIndyaXRlVGlGaWxlU3RyZWFtIiwid3JpdGVPYmoiLCJ3cml0ZUJ1ZmZlciIsIndyaXRlU3RyaW5nIiwid3JpdGVCdWZmZXJTeW5jIiwid3JpdGVTdHJpbmdTeW5jIiwiRmlsZURlc2NyaXB0b3IiLCJwaXBlVmlhV3JpdGVTdHJlYW0iLCJwaXBlVmlhUHVtcCIsIndyaXRlU3RyZWFtIiwicHVtcCIsImJ5dGVzV3JpdHRlbiIsImJ5dGVzV3JpdHRlblRoaXNDaHVuayIsInBvaW50ZXIiLCJkZWZhdWx0cyIsIm9wdGlvbnNUeXBlIiwibWVyZ2VkIiwiY2IiLCJfb3B0cyIsIlJlYWRhYmxlIiwicmVhZGFibGUiLCJfcmVhZCIsImRlc3Ryb3kiLCJfZGVzdHJveSIsIl9uIiwiV3JpdGFibGUiLCJpc0R1cGxleCIsIkR1cGxleCIsIl93cml0ZSIsIndyaXRldiIsIl93cml0ZXYiLCJmaW5hbCIsIl9maW5hbCIsImFsbG93SGFsZk9wZW4iLCJ3cml0YWJsZU1ldGhvZHMiLCJUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJfdHJhbnNmb3JtIiwiZmx1c2giLCJfZmx1c2giLCJmZXRjaFNjcmlwdHNGcm9tSnNvbiIsIkpTT05fRklMRV9OQU1FIiwic2V0dGluZ3MiLCJzY3JpcHRzIiwiZmV0Y2hTY3JpcHRzRnJvbVJlc291cmNlc0RpcmVjdG9yeSIsInJlc291cmNlRGlyZWN0b3J5IiwicmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoIiwibmF0aXZlUGF0aCIsImJvb3RzdHJhcFNjcmlwdHMiLCJsb2FkRnJvbSIsImZpbGVOYW1lQXJyYXkiLCJzZWFyY2giLCJib290c3RyYXBQYXRoIiwibG9hZEFzeW5jIiwiZmluaXNoZWQiLCJsb2FkQm9vdHN0cmFwU2NyaXB0cyIsImJvb3RzdHJhcEluZGV4IiwiZG9Mb2FkIiwiYm9vdHN0cmFwIiwib25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCIsImZpcmVFdmVudCJdLCJzb3VyY2VSb290IjoiL1VzZXJzL2FkaXRpc3VyeWF3YW5zaGkvTGlicmFyeS9BcHBsaWNhdGlvbiBTdXBwb3J0L1RpdGFuaXVtL21vYmlsZXNkay9vc3gvMTIuNy4xLkdBL2NvbW1vbi9SZXNvdXJjZXMvaW9zIiwic291cmNlcyI6WyJ0aS5tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkaSA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG52YXIgZmFpbHMkayA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkaiA9IGZhaWxzJGs7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkaihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgZmFpbHMkaSA9IGZhaWxzJGs7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkaShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGQgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDMgPyBjYWxsJGQuYmluZChjYWxsJGQpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRkLmFwcGx5KGNhbGwkZCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNSA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgTkFUSVZFX0JJTkQkMiA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgY2FsbCRjID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCQyICYmIEZ1bmN0aW9uUHJvdG90eXBlJDIuYmluZC5iaW5kKGNhbGwkYywgY2FsbCRjKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQyID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGMuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQ2ID0gdW5jdXJyeVRoaXMkbCh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UkNSA9IHVuY3VycnlUaGlzJGwoJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSQ1KHRvU3RyaW5nJDYoaXQpLCA4LCAtMSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkayA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkaCA9IGZhaWxzJGs7XG52YXIgY2xhc3NvZiRiID0gY2xhc3NvZlJhdyQyO1xuXG52YXIgJE9iamVjdCQ0ID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkaygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkNCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkYihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdCQ0KGl0KTtcbn0gOiAkT2JqZWN0JDQ7XG5cbi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2Vcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3QtYWVjXG52YXIgaXNOdWxsT3JVbmRlZmluZWQkNiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCQ1ID0gaXNOdWxsT3JVbmRlZmluZWQkNjtcblxudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZCQ1KGl0KSkgdGhyb3cgJFR5cGVFcnJvciRkKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChpdCkpO1xufTtcblxudmFyIGRvY3VtZW50QWxsJDIgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10eXBlb2YtdW5kZWZpbmVkIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgSVNfSFRNTEREQSA9IHR5cGVvZiBkb2N1bWVudEFsbCQyID09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50QWxsJDIgIT09IHVuZGVmaW5lZDtcblxudmFyIGRvY3VtZW50QWxsXzEgPSB7XG4gIGFsbDogZG9jdW1lbnRBbGwkMixcbiAgSVNfSFRNTEREQTogSVNfSFRNTEREQVxufTtcblxudmFyICRkb2N1bWVudEFsbCQxID0gZG9jdW1lbnRBbGxfMTtcblxudmFyIGRvY3VtZW50QWxsJDEgPSAkZG9jdW1lbnRBbGwkMS5hbGw7XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkayA9ICRkb2N1bWVudEFsbCQxLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbCQxO1xufSA6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRrO1xudmFyICRkb2N1bWVudEFsbCA9IGRvY3VtZW50QWxsXzE7XG5cbnZhciBkb2N1bWVudEFsbCA9ICRkb2N1bWVudEFsbC5hbGw7XG5cbnZhciBpc09iamVjdCRlID0gJGRvY3VtZW50QWxsLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRqKGl0KSB8fCBpdCA9PT0gZG9jdW1lbnRBbGw7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkaihpdCk7XG59O1xuXG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkaTtcbnZhciBpc0NhbGxhYmxlJGkgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDYgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRoW25hbWVzcGFjZV0pIDogZ2xvYmFsJGhbbmFtZXNwYWNlXSAmJiBnbG9iYWwkaFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkaih7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gJ3VuZGVmaW5lZCcgJiYgU3RyaW5nKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkaTtcbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkZy5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwkZy5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQyICYmIHByb2Nlc3MkMi52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkZyA9IGZhaWxzJGs7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb24gPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJGcoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kNjtcbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNQcm90b3R5cGVPZiQ0ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQzID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kNSgnU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJGgoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiQ0KCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDMoaXQpKTtcbn07XG5cbnZhciAkU3RyaW5nJDQgPSBTdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmckNChhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRrO1xudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ0O1xuXG52YXIgJFR5cGVFcnJvciRjID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDYWxsYWJsZSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlJGcoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkYyh0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ0O1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDQgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG52YXIgZ2V0TWV0aG9kJDQgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBpc051bGxPclVuZGVmaW5lZCQ0KGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDMoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkaztcbnZhciBpc09iamVjdCRkID0gaXNPYmplY3QkZTtcblxudmFyICRUeXBlRXJyb3IkYiA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRmKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRkKHZhbCA9IGNhbGwkYihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkZihmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRkKHZhbCA9IGNhbGwkYihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkZCh2YWwgPSBjYWxsJGIoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkYihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpc1B1cmUgPSBmYWxzZTtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJGk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ0KGdsb2JhbCRmLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRmW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJGUgPSBnbG9iYWwkaTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkZVtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yNy4yJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMyBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjI3LjIvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkNiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQyKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyhhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCQ2O1xuXG52YXIgaGFzT3duUHJvcGVydHkkMSA9IHVuY3VycnlUaGlzJGkoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSQxKHRvT2JqZWN0JDUoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDUgPSB1bmN1cnJ5VGhpcyRoKDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQ1KCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkaTtcbnZhciBzaGFyZWQkMyA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgaGFzT3duJGIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQyID0gdWlkJDM7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHN5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRkLlN5bWJvbDtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMygnd2tzJyk7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMVsnZm9yJ10gfHwgU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQyO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGcgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRiKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBOQVRJVkVfU1lNQk9MICYmIGhhc093biRiKFN5bWJvbCQxLCBuYW1lKVxuICAgICAgPyBTeW1ib2wkMVtuYW1lXVxuICAgICAgOiBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkYyA9IGlzT2JqZWN0JGU7XG52YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sJDM7XG52YXIgZ2V0TWV0aG9kJDMgPSBnZXRNZXRob2QkNDtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJGYoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMiA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JGMoaW5wdXQpIHx8IGlzU3ltYm9sJDIoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMyhpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCRhKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkYyhyZXN1bHQpIHx8IGlzU3ltYm9sJDIocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yJGEoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUkMSA9IHRvUHJpbWl0aXZlJDI7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDM7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUkMShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2wkMShrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkaTtcbnZhciBpc09iamVjdCRiID0gaXNPYmplY3QkZTtcblxudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkYy5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkYihkb2N1bWVudCQxKSAmJiBpc09iamVjdCRiKGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGYgPSBmYWlscyRrO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGIgJiYgIWZhaWxzJGYoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDQ7XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJGEgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDMoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biRhKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQoIWNhbGwkOShwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRlID0gZmFpbHMkaztcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG52YXIgdjhQcm90b3R5cGVEZWZpbmVCdWcgPSBERVNDUklQVE9SUyQ5ICYmIGZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBpc09iamVjdCRhID0gaXNPYmplY3QkZTtcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRjID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCRhKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDkoJFN0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGM7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xuXG52YXIgJFR5cGVFcnJvciQ4ID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyQ4ID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYihBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYihBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvciQ4KCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDYgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYgPSBERVNDUklQVE9SUyQ3ID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkNi5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kOSA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQ2ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24kOShGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQ2IHx8IChERVNDUklQVE9SUyQ2ICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxudmFyIHVuY3VycnlUaGlzJGcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkaztcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkZyhGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRlKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQyID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJGIgPSBnbG9iYWwkaTtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkYi5XZWFrTWFwO1xuXG52YXIgd2Vha01hcEJhc2ljRGV0ZWN0aW9uID0gaXNDYWxsYWJsZSRkKFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQyID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciB1aWQkMSA9IHVpZCQzO1xuXG52YXIga2V5cyQxID0gc2hhcmVkJDIoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5cyQxW2tleV0gfHwgKGtleXMkMVtrZXldID0gdWlkJDEoa2V5KSk7XG59O1xuXG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSB3ZWFrTWFwQmFzaWNEZXRlY3Rpb247XG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkaTtcbnZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkZTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGEuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkYS5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQkMSwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldCQxKGl0KSA6IHNldCQxKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDkoaXQpIHx8IChzdGF0ZSA9IGdldCQxKGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHN0b3JlLmdldCA9IHN0b3JlLmdldDtcbiAgc3RvcmUuaGFzID0gc3RvcmUuaGFzO1xuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoc3RvcmUuaGFzKGl0KSkgdGhyb3cgVHlwZUVycm9yJDIoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHN0b3JlLnNldChpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkkMignc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQzW1NUQVRFXSA9IHRydWU7XG4gIHNldCQxID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kOChpdCwgU1RBVEUpKSB0aHJvdyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kOChpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kOChpdCwgU1RBVEUpO1xuICB9O1xufVxuXG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQkMSxcbiAgZ2V0OiBnZXQkMSxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkZCA9IGZhaWxzJGs7XG52YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRrO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQyO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNCA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQ1ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LmdldDtcbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIHN0cmluZ1NsaWNlJDQgPSB1bmN1cnJ5VGhpcyRmKCcnLnNsaWNlKTtcbnZhciByZXBsYWNlJDIgPSB1bmN1cnJ5VGhpcyRmKCcnLnJlcGxhY2UpO1xudmFyIGpvaW4kMiA9IHVuY3VycnlUaGlzJGYoW10uam9pbik7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkNSAmJiAhZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQzKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKHN0cmluZ1NsaWNlJDQoJFN0cmluZyQyKG5hbWUpLCAwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIHJlcGxhY2UkMigkU3RyaW5nJDIobmFtZSksIC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQ3KHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDUpIGRlZmluZVByb3BlcnR5JDModmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kNyhvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQzKHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQ3KG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQ1KSBkZWZpbmVQcm9wZXJ0eSQzKHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUkMih2YWx1ZSk7XG4gIGlmICghaGFzT3duJDcoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IGpvaW4kMihURU1QTEFURSwgdHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGModGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQ1KHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDEodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkaztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJDcgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkYih2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlJDUuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yJDMgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDMgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDYgPSB0b0ludGVnZXJPckluZmluaXR5JDc7XG5cbnZhciBtYXgkMiA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDIoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNztcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkNiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQ1KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGgkNSA9IHRvTGVuZ3RoJDY7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoJDUob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkNDtcbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IHRvQWJzb2x1dGVJbmRleCQzO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQyKCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMihmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDIodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDIoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDQ7XG52YXIgaW5kZXhPZiQyID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkMiA9IHVuY3VycnlUaGlzJGUoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQxKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDYoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQ2KE8sIGtleSkgJiYgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ2KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkMihyZXN1bHQsIGtleSkgfHwgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBoaWRkZW5LZXlzJDEpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDY7XG52YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRjO1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyRkKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDQoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkYShpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0LmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093biQ1KHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duJDUoZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWlscyRjID0gZmFpbHMkaztcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQxID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZSQxKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkYShkZXRlY3Rpb24pID8gZmFpbHMkYyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUkMSA9IGlzRm9yY2VkJDEubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQxLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQxLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDEuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMTtcblxudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJGk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBkZWZpbmVCdWlsdEluJDYgPSBkZWZpbmVCdWlsdEluJDc7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJDk7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJDlbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJDlbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDYodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJGk7XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkOC5Qcm9taXNlO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRlKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHJDNdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRrO1xudmFyIGNsYXNzb2ZSYXckMSA9IGNsYXNzb2ZSYXckMjtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGQoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyQxKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiRhID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyQxIDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdCQxKGl0KSwgVE9fU1RSSU5HX1RBRyQyKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyQxKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXckMShPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZSQ5KE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIHVuY3VycnlUaGlzJGMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGIgPSBmYWlscyRrO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkaztcbnZhciBjbGFzc29mJDkgPSBjbGFzc29mJGE7XG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ2O1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDI7XG5cbnZhciBub29wJDIgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluJDMoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMkMSA9IHVuY3VycnlUaGlzJGMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3AkMik7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkOChhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCQyLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQ4KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YkOShhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6IHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMkMShjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbnZhciBpc0NvbnN0cnVjdG9yJDIgPSAhY29uc3RydWN0IHx8IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ0O1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yJDEoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNyh0cnlUb1N0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkYztcbnZhciBhQ29uc3RydWN0b3IkMSA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDMgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkYygnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDIgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QkOShPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgaXNOdWxsT3JVbmRlZmluZWQkMyhTID0gYW5PYmplY3QkOShDKVtTUEVDSUVTJDNdKSA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvciQxKFMpO1xufTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSB7fTtcblxudmFyIGFDYWxsYWJsZSQyID0gYUNhbGxhYmxlJDQ7XG5cbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgJFR5cGVFcnJvciQ2KCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUkMihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhQ2FsbGFibGUkMihyZWplY3QpO1xufTtcblxuLy8gYE5ld1Byb21pc2VDYXBhYmlsaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbmV3cHJvbWlzZWNhcGFiaWxpdHlcbm5ld1Byb21pc2VDYXBhYmlsaXR5JDEuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGM7XG52YXIgaXNPYmplY3QkOCA9IGlzT2JqZWN0JGU7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXG52YXIgcHJvbWlzZVJlc29sdmUkMSA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0JDgoQyk7XG4gIGlmIChpc09iamVjdCQ4KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxudmFyICQkMyA9IF9leHBvcnQ7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGZhaWxzJGEgPSBmYWlscyRrO1xudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kNjtcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGs7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDEgPSBzcGVjaWVzQ29uc3RydWN0b3IkMjtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZXNvbHZlJDE7XG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZGVmaW5lQnVpbHRJbiQ3O1xuXG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4vLyBTYWZhcmkgYnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDA4MjlcbnZhciBOT05fR0VORVJJQyA9ICEhTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIGZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10aGVuYWJsZSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBOYXRpdmVQcm9taXNlUHJvdG90eXBlWydmaW5hbGx5J10uY2FsbCh7IHRoZW46IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuZmluYWxseVxuJCQzKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IE5PTl9HRU5FUklDIH0sIHtcbiAgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IkMSh0aGlzLCBnZXRCdWlsdEluJDIoJ1Byb21pc2UnKSk7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSBpc0NhbGxhYmxlJDcob25GaW5hbGx5KTtcbiAgICByZXR1cm4gdGhpcy50aGVuKFxuICAgICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICAgIH0gOiBvbkZpbmFsbHksXG4gICAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgICB9IDogb25GaW5hbGx5XG4gICAgKTtcbiAgfVxufSk7XG5cbi8vIG1ha2VzIHN1cmUgdGhhdCBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzIGBQcm9taXNlI2ZpbmFsbHlgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUkNyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDIoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2ZpbmFsbHknXTtcbiAgaWYgKE5hdGl2ZVByb21pc2VQcm90b3R5cGVbJ2ZpbmFsbHknXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQ1KE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdmaW5hbGx5JywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMjtcbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXNDbGF1c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpcyRiKGZuKTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMSA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkYztcbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b0luZGV4ZWRPYmplY3QkNDtcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQxO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDQgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkNyhPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kNjtcblxudmFyIGh0bWwkMSA9IGdldEJ1aWx0SW4kMSgnZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ2ID0gYW5PYmplY3QkYztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNDtcbnZhciBodG1sID0gaHRtbCQxO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUkMSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFJDFdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzW0lFX1BST1RPJDFdID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gYW5PYmplY3QkNihPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJGs7XG5cbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkaztcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkNjtcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkMztcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUkMiA9ICRPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkNChPKTtcbiAgaWYgKGhhc093biQ0KG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSQ2KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUkMiA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkOCA9IGZhaWxzJGs7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRrO1xudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCRlO1xudmFyIGdldFByb3RvdHlwZU9mJDIgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDQgPSBkZWZpbmVCdWlsdEluJDc7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSQxLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQyKGdldFByb3RvdHlwZU9mJDIoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSAhaXNPYmplY3QkNyhJdGVyYXRvclByb3RvdHlwZSQxKSB8fCBmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDNdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJDUoSXRlcmF0b3JQcm90b3R5cGUkMVtJVEVSQVRPUiQzXSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ0KEl0ZXJhdG9yUHJvdG90eXBlJDEsIElURVJBVE9SJDMsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJGEoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyQyID0gZnVuY3Rpb24gKHRhcmdldCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKHRhcmdldCAmJiAhU1RBVElDKSB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xuICBpZiAodGFyZ2V0ICYmICFoYXNPd24kMyh0YXJnZXQsIFRPX1NUUklOR19UQUckMSkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQyKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxudmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSQyID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDI7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGl0ZXJhdG9yQ3JlYXRlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSQyKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckMShJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG4gIEl0ZXJhdG9ycyQyW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG4vLyBgQ3JlYXRlSXRlclJlc3VsdE9iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWl0ZXJyZXN1bHRvYmplY3RcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDEgPSBmdW5jdGlvbiAodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiBkb25lIH07XG59O1xuXG52YXIgY2xhc3NvZiQ4ID0gY2xhc3NvZiRhO1xuXG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiQ4KGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmckMShhcmd1bWVudCk7XG59O1xuXG52YXIgaXNPYmplY3QkNiA9IGlzT2JqZWN0JGU7XG52YXIgY2xhc3NvZiQ3ID0gY2xhc3NvZlJhdyQyO1xudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQ5KCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxudmFyIGlzUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0JDYoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZiQ3KGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG52YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGM7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciByZWdleHBGbGFncyQxID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0JDUodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuaGFzSW5kaWNlcykgcmVzdWx0ICs9ICdkJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQudW5pY29kZVNldHMpIHJlc3VsdCArPSAndic7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkMyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgcmVnRXhwRmxhZ3MgPSByZWdleHBGbGFncyQxO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlJDMgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgcmVnZXhwR2V0RmxhZ3MgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlJDMpICYmICFoYXNPd24kMihSLCAnZmxhZ3MnKSAmJiBpc1Byb3RvdHlwZU9mJDMoUmVnRXhwUHJvdG90eXBlJDMsIFIpXG4gICAgPyBjYWxsJDgocmVnRXhwRmxhZ3MsIFIpIDogZmxhZ3M7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ3O1xudmFyIHRvU3RyaW5nJDMgPSB0b1N0cmluZyQ0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcblxudmFyIGNoYXJBdCQzID0gdW5jdXJyeVRoaXMkYSgnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcyRhKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlJDMgPSB1bmN1cnJ5VGhpcyRhKCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmckMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5JDQocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0JDMoUywgcG9zaXRpb24pXG4gICAgICAgICAgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBzdHJpbmdTbGljZSQzKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QkMShmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCQxKHRydWUpXG59O1xuXG52YXIgY2hhckF0JDIgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4JDIgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQkMihTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuXG52YXIgZmFpbHMkNyA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkaTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDIgPSBnbG9iYWwkNy5SZWdFeHA7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDEgPSBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCQyKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbi8vIFVDIEJyb3dzZXIgYnVnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTAwOFxudmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZJDEgfHwgZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhJFJlZ0V4cCQyKCdhJywgJ3knKS5zdGlja3k7XG59KTtcblxudmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kkMSB8fCBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzczNjg3XG4gIHZhciByZSA9ICRSZWdFeHAkMignXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxudmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG4gIEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVULFxuICBNSVNTRURfU1RJQ0tZOiBNSVNTRURfU1RJQ0tZLFxuICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZJDFcbn07XG5cbnZhciBmYWlscyQ2ID0gZmFpbHMkaztcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRpO1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAncycpIC0+IC8uL3MgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAkMSA9IGdsb2JhbCQ2LlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsID0gZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMSgnLicsICdzJyk7XG4gIHJldHVybiAhKHJlLmRvdEFsbCAmJiByZS5leGVjKCdcXG4nKSAmJiByZS5mbGFncyA9PT0gJ3MnKTtcbn0pO1xuXG52YXIgZmFpbHMkNSA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkaTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsJDUuUmVnRXhwO1xuXG52YXIgcmVnZXhwVW5zdXBwb3J0ZWROY2cgPSBmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCgnKD88YT5iKScsICdnJyk7XG4gIHJldHVybiByZS5leGVjKCdiJykuZ3JvdXBzLmEgIT09ICdiJyB8fFxuICAgICdiJy5yZXBsYWNlKHJlLCAnJDxhPmMnKSAhPT0gJ2JjJztcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgY2FsbCQ3ID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ0O1xudmFyIHJlZ2V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcbnZhciBzdGlja3lIZWxwZXJzID0gcmVnZXhwU3RpY2t5SGVscGVycztcbnZhciBzaGFyZWQgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGNyZWF0ZSQxID0gb2JqZWN0Q3JlYXRlO1xudmFyIGdldEludGVybmFsU3RhdGUkNCA9IGludGVybmFsU3RhdGUuZ2V0O1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZWdleHBVbnN1cHBvcnRlZERvdEFsbDtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZWdleHBVbnN1cHBvcnRlZE5jZztcblxudmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgY2hhckF0JDEgPSB1bmN1cnJ5VGhpcyQ5KCcnLmNoYXJBdCk7XG52YXIgaW5kZXhPZiQxID0gdW5jdXJyeVRoaXMkOSgnJy5pbmRleE9mKTtcbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyQ5KCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlJDIgPSB1bmN1cnJ5VGhpcyQ5KCcnLnNsaWNlKTtcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgY2FsbCQ3KG5hdGl2ZUV4ZWMsIHJlMSwgJ2EnKTtcbiAgY2FsbCQ3KG5hdGl2ZUV4ZWMsIHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kgfHwgVU5TVVBQT1JURURfRE9UX0FMTCB8fCBVTlNVUFBPUlRFRF9OQ0c7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDQocmUpO1xuICAgIHZhciBzdHIgPSB0b1N0cmluZyQyKHN0cmluZyk7XG4gICAgdmFyIHJhdyA9IHN0YXRlLnJhdztcbiAgICB2YXIgcmVzdWx0LCByZUNvcHksIGxhc3RJbmRleCwgbWF0Y2gsIGksIG9iamVjdCwgZ3JvdXA7XG5cbiAgICBpZiAocmF3KSB7XG4gICAgICByYXcubGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgcmVzdWx0ID0gY2FsbCQ3KHBhdGNoZWRFeGVjLCByYXcsIHN0cik7XG4gICAgICByZS5sYXN0SW5kZXggPSByYXcubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBzID0gc3RhdGUuZ3JvdXBzO1xuICAgIHZhciBzdGlja3kgPSBVTlNVUFBPUlRFRF9ZICYmIHJlLnN0aWNreTtcbiAgICB2YXIgZmxhZ3MgPSBjYWxsJDcocmVnZXhwRmxhZ3MsIHJlKTtcbiAgICB2YXIgc291cmNlID0gcmUuc291cmNlO1xuICAgIHZhciBjaGFyc0FkZGVkID0gMDtcbiAgICB2YXIgc3RyQ29weSA9IHN0cjtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGZsYWdzID0gcmVwbGFjZSQxKGZsYWdzLCAneScsICcnKTtcbiAgICAgIGlmIChpbmRleE9mJDEoZmxhZ3MsICdnJykgPT09IC0xKSB7XG4gICAgICAgIGZsYWdzICs9ICdnJztcbiAgICAgIH1cblxuICAgICAgc3RyQ29weSA9IHN0cmluZ1NsaWNlJDIoc3RyLCByZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgY2hhckF0JDEoc3RyLCByZS5sYXN0SW5kZXggLSAxKSAhPT0gJ1xcbicpKSB7XG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcbiAgICAgICAgc3RyQ29weSA9ICcgJyArIHN0ckNvcHk7XG4gICAgICAgIGNoYXJzQWRkZWQrKztcbiAgICAgIH1cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBzdHIgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuICAgIG1hdGNoID0gY2FsbCQ3KG5hdGl2ZUV4ZWMsIHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5pbnB1dCA9IHN0cmluZ1NsaWNlJDIobWF0Y2guaW5wdXQsIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaFswXSA9IHN0cmluZ1NsaWNlJDIobWF0Y2hbMF0sIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSByZS5sYXN0SW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbid0IHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIGNhbGwkNyhuYXRpdmVSZXBsYWNlLCBtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoICYmIGdyb3Vwcykge1xuICAgICAgbWF0Y2guZ3JvdXBzID0gb2JqZWN0ID0gY3JlYXRlJDEobnVsbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBvYmplY3RbZ3JvdXBbMF1dID0gbWF0Y2hbZ3JvdXBbMV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxudmFyIHJlZ2V4cEV4ZWMkMiA9IHBhdGNoZWRFeGVjO1xuXG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDQgPSBhbk9iamVjdCRjO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkaztcbnZhciBjbGFzc29mJDYgPSBjbGFzc29mUmF3JDI7XG52YXIgcmVnZXhwRXhlYyQxID0gcmVnZXhwRXhlYyQyO1xuXG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbnZhciByZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKGlzQ2FsbGFibGUkNChleGVjKSkge1xuICAgIHZhciByZXN1bHQgPSBjYWxsJDYoZXhlYywgUiwgUyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgYW5PYmplY3QkNChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YkNihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsJDYocmVnZXhwRXhlYyQxLCBSLCBTKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zdHJpbmctcHJvdG90eXBlLW1hdGNoYWxsIC0tIHNhZmUgKi9cbnZhciAkJDIgPSBfZXhwb3J0O1xudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpc0NsYXVzZTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gaXRlcmF0b3JDcmVhdGVDb25zdHJ1Y3RvcjtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0ID0gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQxO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciB0b0xlbmd0aCQ0ID0gdG9MZW5ndGgkNjtcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckNDtcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkYztcbnZhciBpc051bGxPclVuZGVmaW5lZCQyID0gaXNOdWxsT3JVbmRlZmluZWQkNjtcbnZhciBjbGFzc29mJDUgPSBjbGFzc29mUmF3JDI7XG52YXIgaXNSZWdFeHAkMSA9IGlzUmVnZXhwO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVnZXhwR2V0RmxhZ3M7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkNDtcbnZhciBkZWZpbmVCdWlsdEluJDMgPSBkZWZpbmVCdWlsdEluJDc7XG52YXIgZmFpbHMkNCA9IGZhaWxzJGs7XG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkZztcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBzcGVjaWVzQ29uc3RydWN0b3IkMjtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXgkMSA9IGFkdmFuY2VTdHJpbmdJbmRleCQyO1xudmFyIHJlZ0V4cEV4ZWMkMSA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xudmFyIElTX1BVUkUgPSBpc1B1cmU7XG5cbnZhciBNQVRDSF9BTEwgPSB3ZWxsS25vd25TeW1ib2wkOCgnbWF0Y2hBbGwnKTtcbnZhciBSRUdFWFBfU1RSSU5HID0gJ1JlZ0V4cCBTdHJpbmcnO1xudmFyIFJFR0VYUF9TVFJJTkdfSVRFUkFUT1IgPSBSRUdFWFBfU1RSSU5HICsgJyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDMgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuZ2V0dGVyRm9yKFJFR0VYUF9TVFJJTkdfSVRFUkFUT1IpO1xudmFyIFJlZ0V4cFByb3RvdHlwZSQyID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG52YXIgc3RyaW5nSW5kZXhPZiQxID0gdW5jdXJyeVRoaXMkOCgnJy5pbmRleE9mKTtcbnZhciBuYXRpdmVNYXRjaEFsbCA9IHVuY3VycnlUaGlzJDgoJycubWF0Y2hBbGwpO1xuXG52YXIgV09SS1NfV0lUSF9OT05fR0xPQkFMX1JFR0VYID0gISFuYXRpdmVNYXRjaEFsbCAmJiAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZU1hdGNoQWxsKCdhJywgLy4vKTtcbn0pO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihmdW5jdGlvbiBSZWdFeHBTdHJpbmdJdGVyYXRvcihyZWdleHAsIHN0cmluZywgJGdsb2JhbCwgZnVsbFVuaWNvZGUpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBSRUdFWFBfU1RSSU5HX0lURVJBVE9SLFxuICAgIHJlZ2V4cDogcmVnZXhwLFxuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIGdsb2JhbDogJGdsb2JhbCxcbiAgICB1bmljb2RlOiBmdWxsVW5pY29kZSxcbiAgICBkb25lOiBmYWxzZVxuICB9KTtcbn0sIFJFR0VYUF9TVFJJTkcsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMyh0aGlzKTtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIHZhciBSID0gc3RhdGUucmVnZXhwO1xuICB2YXIgUyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIG1hdGNoID0gcmVnRXhwRXhlYyQxKFIsIFMpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICB9XG4gIGlmIChzdGF0ZS5nbG9iYWwpIHtcbiAgICBpZiAodG9TdHJpbmckMShtYXRjaFswXSkgPT09ICcnKSBSLmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleCQxKFMsIHRvTGVuZ3RoJDQoUi5sYXN0SW5kZXgpLCBzdGF0ZS51bmljb2RlKTtcbiAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChtYXRjaCwgZmFsc2UpO1xuICB9XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChtYXRjaCwgZmFsc2UpO1xufSk7XG5cbnZhciAkbWF0Y2hBbGwgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBSID0gYW5PYmplY3QkMyh0aGlzKTtcbiAgdmFyIFMgPSB0b1N0cmluZyQxKHN0cmluZyk7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKFIsIFJlZ0V4cCk7XG4gIHZhciBmbGFncyA9IHRvU3RyaW5nJDEoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICB2YXIgbWF0Y2hlciwgJGdsb2JhbCwgZnVsbFVuaWNvZGU7XG4gIG1hdGNoZXIgPSBuZXcgQyhDID09PSBSZWdFeHAgPyBSLnNvdXJjZSA6IFIsIGZsYWdzKTtcbiAgJGdsb2JhbCA9ICEhfnN0cmluZ0luZGV4T2YkMShmbGFncywgJ2cnKTtcbiAgZnVsbFVuaWNvZGUgPSAhIX5zdHJpbmdJbmRleE9mJDEoZmxhZ3MsICd1Jyk7XG4gIG1hdGNoZXIubGFzdEluZGV4ID0gdG9MZW5ndGgkNChSLmxhc3RJbmRleCk7XG4gIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKG1hdGNoZXIsIFMsICRnbG9iYWwsIGZ1bGxVbmljb2RlKTtcbn07XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaGFsbFxuJCQyKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogV09SS1NfV0lUSF9OT05fR0xPQkFMX1JFR0VYIH0sIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKHRoaXMpO1xuICAgIHZhciBmbGFncywgUywgbWF0Y2hlciwgcng7XG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCQyKHJlZ2V4cCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCQxKHJlZ2V4cCkpIHtcbiAgICAgICAgZmxhZ3MgPSB0b1N0cmluZyQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMShnZXRSZWdFeHBGbGFncyhyZWdleHApKSk7XG4gICAgICAgIGlmICghfnN0cmluZ0luZGV4T2YkMShmbGFncywgJ2cnKSkgdGhyb3cgJFR5cGVFcnJvciQ0KCdgLm1hdGNoQWxsYCBkb2VzIG5vdCBhbGxvdyBub24tZ2xvYmFsIHJlZ2V4ZXMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChXT1JLU19XSVRIX05PTl9HTE9CQUxfUkVHRVgpIHJldHVybiBuYXRpdmVNYXRjaEFsbChPLCByZWdleHApO1xuICAgICAgbWF0Y2hlciA9IGdldE1ldGhvZCQyKHJlZ2V4cCwgTUFUQ0hfQUxMKTtcbiAgICAgIGlmIChtYXRjaGVyID09PSB1bmRlZmluZWQgJiYgSVNfUFVSRSAmJiBjbGFzc29mJDUocmVnZXhwKSA9PSAnUmVnRXhwJykgbWF0Y2hlciA9ICRtYXRjaEFsbDtcbiAgICAgIGlmIChtYXRjaGVyKSByZXR1cm4gY2FsbCQ1KG1hdGNoZXIsIHJlZ2V4cCwgTyk7XG4gICAgfSBlbHNlIGlmIChXT1JLU19XSVRIX05PTl9HTE9CQUxfUkVHRVgpIHJldHVybiBuYXRpdmVNYXRjaEFsbChPLCByZWdleHApO1xuICAgIFMgPSB0b1N0cmluZyQxKE8pO1xuICAgIHJ4ID0gbmV3IFJlZ0V4cChyZWdleHAsICdnJyk7XG4gICAgcmV0dXJuIHJ4W01BVENIX0FMTF0oUyk7XG4gIH1cbn0pO1xuXG5NQVRDSF9BTEwgaW4gUmVnRXhwUHJvdG90eXBlJDIgfHwgZGVmaW5lQnVpbHRJbiQzKFJlZ0V4cFByb3RvdHlwZSQyLCBNQVRDSF9BTEwsICRtYXRjaEFsbCk7XG5cbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkkMSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwkNCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1yZWZsZWN0IC0tIHNhZmVcbnZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQkMSA/IGNhbGwkNC5iaW5kKGFwcGx5JDEpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCQ0LmFwcGx5KGFwcGx5JDEsIGFyZ3VtZW50cyk7XG59KTtcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgZXhlYyA9IHJlZ2V4cEV4ZWMkMjtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCQxKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMgfSwge1xuICBleGVjOiBleGVjXG59KTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcblxudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzQ2xhdXNlO1xudmFyIGRlZmluZUJ1aWx0SW4kMiA9IGRlZmluZUJ1aWx0SW4kNztcbnZhciByZWdleHBFeGVjID0gcmVnZXhwRXhlYyQyO1xudmFyIGZhaWxzJDMgPSBmYWlscyRrO1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcblxudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCQ3KCdzcGVjaWVzJyk7XG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBGT1JDRUQsIFNIQU0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbCQ3KEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgRk9SQ0VEXG4gICkge1xuICAgIHZhciB1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QgPSB1bmN1cnJ5VGhpcyQ3KC8uL1tTWU1CT0xdKTtcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIHZhciB1bmN1cnJpZWROYXRpdmVNZXRob2QgPSB1bmN1cnJ5VGhpcyQ3KG5hdGl2ZU1ldGhvZCk7XG4gICAgICB2YXIgJGV4ZWMgPSByZWdleHAuZXhlYztcbiAgICAgIGlmICgkZXhlYyA9PT0gcmVnZXhwRXhlYyB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlJDEuZXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmN1cnJpZWROYXRpdmVNZXRob2Qoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0pO1xuXG4gICAgZGVmaW5lQnVpbHRJbiQyKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgbWV0aG9kc1swXSk7XG4gICAgZGVmaW5lQnVpbHRJbiQyKFJlZ0V4cFByb3RvdHlwZSQxLCBTWU1CT0wsIG1ldGhvZHNbMV0pO1xuICB9XG5cbiAgaWYgKFNIQU0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzKFJlZ0V4cFByb3RvdHlwZSQxW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkMyA9IHRvT2JqZWN0JDY7XG5cbnZhciBmbG9vciQyID0gTWF0aC5mbG9vcjtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcyQ2KCcnLmNoYXJBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzJDYoJycucmVwbGFjZSk7XG52YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJDYoJycuc2xpY2UpO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9KS9nO1xuXG4vLyBgR2V0U3Vic3RpdHV0aW9uYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG52YXIgZ2V0U3Vic3RpdHV0aW9uJDEgPSBmdW5jdGlvbiAobWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QkMyhuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoYXJBdChjaCwgMCkpIHtcbiAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHJpbmdTbGljZSQxKHN0ciwgMCwgcG9zaXRpb24pO1xuICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0cmluZ1NsaWNlJDEoc3RyLCB0YWlsUG9zKTtcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tzdHJpbmdTbGljZSQxKGNoLCAxLCAtMSldO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgIHZhciBmID0gZmxvb3IkMihuIC8gMTApO1xuICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2hhckF0KGNoLCAxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoYXJBdChjaCwgMSk7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gIH0pO1xufTtcblxudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYztcbnZhciBmYWlscyQyID0gZmFpbHMkaztcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkYztcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQkMSA9IGlzTnVsbE9yVW5kZWZpbmVkJDY7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQzID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ3O1xudmFyIHRvTGVuZ3RoJDMgPSB0b0xlbmd0aCQ2O1xudmFyIHRvU3RyaW5nID0gdG9TdHJpbmckNDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleCQyO1xudmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDQ7XG52YXIgZ2V0U3Vic3RpdHV0aW9uID0gZ2V0U3Vic3RpdHV0aW9uJDE7XG52YXIgcmVnRXhwRXhlYyA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgUkVQTEFDRSA9IHdlbGxLbm93blN5bWJvbCQ2KCdyZXBsYWNlJyk7XG52YXIgbWF4JDEgPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ1KFtdLmNvbmNhdCk7XG52YXIgcHVzaCQxID0gdW5jdXJyeVRoaXMkNShbXS5wdXNoKTtcbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMkNSgnJy5pbmRleE9mKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzJDUoJycuc2xpY2UpO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIElFIDw9IDExIHJlcGxhY2VzICQwIHdpdGggdGhlIHdob2xlIG1hdGNoLCBhcyBpZiBpdCB3YXMgJCZcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwMjQ2NjYvZ2V0dGluZy1pZS10by1yZXBsYWNlLWEtcmVnZXgtd2l0aC10aGUtbGl0ZXJhbC1zdHJpbmctMFxudmFyIFJFUExBQ0VfS0VFUFNfJDAgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL3ByZWZlci1lc2NhcGUtcmVwbGFjZW1lbnQtZG9sbGFyLWNoYXIgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuICdhJy5yZXBsYWNlKC8uLywgJyQwJykgPT09ICckMCc7XG59KSgpO1xuXG4vLyBTYWZhcmkgPD0gMTMuMC4zKD8pIHN1YnN0aXR1dGVzIG50aCBjYXB0dXJlIHdoZXJlIG4+bSB3aXRoIGFuIGVtcHR5IHN0cmluZ1xudmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKC8uL1tSRVBMQUNFXSkge1xuICAgIHJldHVybiAvLi9bUkVQTEFDRV0oJ2EnLCAnJDAnKSA9PT0gJyc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkoKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tdXNlbGVzcy1kb2xsYXItcmVwbGFjZW1lbnRzIC0tIGZhbHNlIHBvc2l0aXZlXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygncmVwbGFjZScsIGZ1bmN0aW9uIChfLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIFVOU0FGRV9TVUJTVElUVVRFID0gUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPyAnJCcgOiAnJDAnO1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IGlzTnVsbE9yVW5kZWZpbmVkJDEoc2VhcmNoVmFsdWUpID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kJDEoc2VhcmNoVmFsdWUsIFJFUExBQ0UpO1xuICAgICAgcmV0dXJuIHJlcGxhY2VyXG4gICAgICAgID8gY2FsbCQzKHJlcGxhY2VyLCBzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IGNhbGwkMyhuYXRpdmVSZXBsYWNlLCB0b1N0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG4gICAgZnVuY3Rpb24gKHN0cmluZywgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCQyKHRoaXMpO1xuICAgICAgdmFyIFMgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiByZXBsYWNlVmFsdWUgPT0gJ3N0cmluZycgJiZcbiAgICAgICAgc3RyaW5nSW5kZXhPZihyZXBsYWNlVmFsdWUsIFVOU0FGRV9TVUJTVElUVVRFKSA9PT0gLTEgJiZcbiAgICAgICAgc3RyaW5nSW5kZXhPZihyZXBsYWNlVmFsdWUsICckPCcpID09PSAtMVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcngsIFMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gaXNDYWxsYWJsZSQzKHJlcGxhY2VWYWx1ZSk7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSB0b1N0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcHVzaCQxKHJlc3VsdHMsIHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSB0b1N0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgkMyhyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICB2YXIgbWF0Y2hlZCA9IHRvU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heCQxKG1pbih0b0ludGVnZXJPckluZmluaXR5JDMocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgcHVzaCQxKGNhcHR1cmVzLCBtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBjb25jYXQoW21hdGNoZWRdLCBjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHB1c2gkMShyZXBsYWNlckFyZ3MsIG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHRvU3RyaW5nKGFwcGx5KHJlcGxhY2VWYWx1ZSwgdW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IHN0cmluZ1NsaWNlKFMsIG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgc3RyaW5nU2xpY2UoUywgbmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG59LCAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgfHwgIVJFUExBQ0VfS0VFUFNfJDAgfHwgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUpO1xuXG52YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDUoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1IkMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG52YXIgYXJyYXlCdWZmZXJCYXNpY0RldGVjdGlvbiA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGF0YVZpZXcgIT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxudmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZSQyKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDMoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cblxudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRjO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzJDQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JDEoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIkMSA9IGFycmF5QnVmZmVyQmFzaWNEZXRlY3Rpb247XG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJGk7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRrO1xudmFyIGlzT2JqZWN0JDUgPSBpc09iamVjdCRlO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBjbGFzc29mJDQgPSBjbGFzc29mJGE7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBkZWZpbmVCdWlsdEluJDEgPSBkZWZpbmVCdWlsdEluJDc7XG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBnZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMyA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgdWlkID0gdWlkJDM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0O1xudmFyIEludDhBcnJheSQyID0gZ2xvYmFsJDQuSW50OEFycmF5O1xudmFyIEludDhBcnJheVByb3RvdHlwZSA9IEludDhBcnJheSQyICYmIEludDhBcnJheSQyLnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSQxID0gZ2xvYmFsJDQuVWludDhDbGFtcGVkQXJyYXk7XG52YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSQxICYmIFVpbnQ4Q2xhbXBlZEFycmF5JDEucHJvdG90eXBlO1xudmFyIFR5cGVkQXJyYXkkMSA9IEludDhBcnJheSQyICYmIGdldFByb3RvdHlwZU9mJDEoSW50OEFycmF5JDIpO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUkMyA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZiQxKEludDhBcnJheVByb3RvdHlwZSk7XG52YXIgT2JqZWN0UHJvdG90eXBlJDEgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDQuVHlwZUVycm9yO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQ0KCd0b1N0cmluZ1RhZycpO1xudmFyIFRZUEVEX0FSUkFZX1RBRyQxID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiA9ICdUeXBlZEFycmF5Q29uc3RydWN0b3InO1xuLy8gRml4aW5nIG5hdGl2ZSB0eXBlZCBhcnJheXMgaW4gT3BlcmEgUHJlc3RvIGNyYXNoZXMgdGhlIGJyb3dzZXIsIHNlZSAjNTk1XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyID0gTkFUSVZFX0FSUkFZX0JVRkZFUiQxICYmICEhc2V0UHJvdG90eXBlT2YkMyAmJiBjbGFzc29mJDQoZ2xvYmFsJDQub3BlcmEpICE9PSAnT3BlcmEnO1xudmFyIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IGZhbHNlO1xudmFyIE5BTUUsIENvbnN0cnVjdG9yLCBQcm90b3R5cGU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgQmlnSW50NjRBcnJheTogOCxcbiAgQmlnVWludDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgaWYgKCFpc09iamVjdCQ1KGl0KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2xhc3MgPSBjbGFzc29mJDQoaXQpO1xuICByZXR1cm4ga2xhc3MgPT09ICdEYXRhVmlldydcbiAgICB8fCBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duJDEoQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mJDEoaXQpO1xuICBpZiAoIWlzT2JqZWN0JDUocHJvdG8pKSByZXR1cm47XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMihwcm90byk7XG4gIHJldHVybiAoc3RhdGUgJiYgaGFzT3duJDEoc3RhdGUsIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SKSkgPyBzdGF0ZVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IocHJvdG8pO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QkNShpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZiQ0KGl0KTtcbiAgcmV0dXJuIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24kMShCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNUeXBlZEFycmF5JDIoaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvciQxKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDMgPSBmdW5jdGlvbiAoQykge1xuICBpZiAoaXNDYWxsYWJsZSQxKEMpICYmICghc2V0UHJvdG90eXBlT2YkMyB8fCBpc1Byb3RvdHlwZU9mJDIoVHlwZWRBcnJheSQxLCBDKSkpIHJldHVybiBDO1xuICB0aHJvdyBUeXBlRXJyb3IkMSh0cnlUb1N0cmluZyQxKEMpICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkLCBvcHRpb25zKSB7XG4gIGlmICghREVTQ1JJUFRPUlMkMykgcmV0dXJuO1xuICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkNFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB0cnkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gb2xkIFdlYktpdCBidWcgLSBzb21lIG1ldGhvZHMgYXJlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlJDNbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICBkZWZpbmVCdWlsdEluJDEoVHlwZWRBcnJheVByb3RvdHlwZSQzLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBJbnQ4QXJyYXlQcm90b3R5cGVbS0VZXSB8fCBwcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDIgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gIHZhciBBUlJBWSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICBpZiAoIURFU0NSSVBUT1JTJDMpIHJldHVybjtcbiAgaWYgKHNldFByb3RvdHlwZU9mJDMpIHtcbiAgICBpZiAoZm9yY2VkKSBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkNFtBUlJBWV07XG4gICAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZKSkgdHJ5IHtcbiAgICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH1cbiAgICBpZiAoIVR5cGVkQXJyYXkkMVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVCdWlsdEluJDEoVHlwZWRBcnJheSQxLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5IDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyICYmIFR5cGVkQXJyYXkkMVtLRVldIHx8IHByb3BlcnR5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG4gIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkNFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldIHx8IGZvcmNlZCkpIHtcbiAgICAgIGRlZmluZUJ1aWx0SW4kMShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsJDRbTkFNRV07XG4gIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yICYmIENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaWYgKFByb3RvdHlwZSkgZW5mb3JjZUludGVybmFsU3RhdGUkMShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xuICBlbHNlIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiA9IGZhbHNlO1xufVxuXG5mb3IgKE5BTUUgaW4gQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsJDRbTkFNRV07XG4gIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yICYmIENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaWYgKFByb3RvdHlwZSkgZW5mb3JjZUludGVybmFsU3RhdGUkMShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xufVxuXG4vLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgfHwgIWlzQ2FsbGFibGUkMShUeXBlZEFycmF5JDEpIHx8IFR5cGVkQXJyYXkkMSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3cgLS0gc2FmZVxuICBUeXBlZEFycmF5JDEgPSBmdW5jdGlvbiBUeXBlZEFycmF5KCkge1xuICAgIHRocm93IFR5cGVFcnJvciQxKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9O1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsJDRbTkFNRV0pIHNldFByb3RvdHlwZU9mJDMoZ2xvYmFsJDRbTkFNRV0sIFR5cGVkQXJyYXkkMSk7XG4gIH1cbn1cblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUkMyB8fCBUeXBlZEFycmF5UHJvdG90eXBlJDMgPT09IE9iamVjdFByb3RvdHlwZSQxKSB7XG4gIFR5cGVkQXJyYXlQcm90b3R5cGUkMyA9IFR5cGVkQXJyYXkkMS5wcm90b3R5cGU7XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWwkNFtOQU1FXSkgc2V0UHJvdG90eXBlT2YkMyhnbG9iYWwkNFtOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUkMyk7XG4gIH1cbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIG9uZSBtb3JlIG9iamVjdCBpbiBVaW50OENsYW1wZWRBcnJheSBwcm90b3R5cGUgY2hhaW5cbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgJiYgZ2V0UHJvdG90eXBlT2YkMShVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUkMykge1xuICBzZXRQcm90b3R5cGVPZiQzKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlJDMpO1xufVxuXG5pZiAoREVTQ1JJUFRPUlMkMyAmJiAhaGFzT3duJDEoVHlwZWRBcnJheVByb3RvdHlwZSQzLCBUT19TVFJJTkdfVEFHKSkge1xuICBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSB0cnVlO1xuICBkZWZpbmVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlQcm90b3R5cGUkMywgVE9fU1RSSU5HX1RBRywgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QkNSh0aGlzKSA/IHRoaXNbVFlQRURfQVJSQVlfVEFHJDFdIDogdW5kZWZpbmVkO1xuICB9IH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWwkNFtOQU1FXSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKGdsb2JhbCQ0W05BTUVdLCBUWVBFRF9BUlJBWV9UQUckMSwgTkFNRSk7XG4gIH1cbn1cblxudmFyIGFycmF5QnVmZmVyVmlld0NvcmUgPSB7XG4gIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMixcbiAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgJiYgVFlQRURfQVJSQVlfVEFHJDEsXG4gIGFUeXBlZEFycmF5OiBhVHlwZWRBcnJheSxcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQzLFxuICBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kLFxuICBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kOiBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDIsXG4gIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBpc1ZpZXc6IGlzVmlldyxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXkkMixcbiAgVHlwZWRBcnJheTogVHlwZWRBcnJheSQxLFxuICBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlJDNcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkaTtcbnZhciBmYWlscyQxID0gZmFpbHMkaztcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMTtcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG5cbnZhciBBcnJheUJ1ZmZlciQyID0gZ2xvYmFsJDMuQXJyYXlCdWZmZXI7XG52YXIgSW50OEFycmF5JDEgPSBnbG9iYWwkMy5JbnQ4QXJyYXk7XG5cbnZhciB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzID0gIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSB8fCAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSQxKDEpO1xufSkgfHwgIWZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICBuZXcgSW50OEFycmF5JDEoLTEpO1xufSkgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgbmV3IEludDhBcnJheSQxKCk7XG4gIG5ldyBJbnQ4QXJyYXkkMShudWxsKTtcbiAgbmV3IEludDhBcnJheSQxKDEuNSk7XG4gIG5ldyBJbnQ4QXJyYXkkMShpdGVyYWJsZSk7XG59LCB0cnVlKSB8fCBmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgLy8gU2FmYXJpICgxMSspIGJ1ZyAtIGEgcmVhc29uIHdoeSBldmVuIFNhZmFyaSAxMyBzaG91bGQgbG9hZCBhIHR5cGVkIGFycmF5IHBvbHlmaWxsXG4gIHJldHVybiBuZXcgSW50OEFycmF5JDEobmV3IEFycmF5QnVmZmVyJDIoMiksIDEsIHVuZGVmaW5lZCkubGVuZ3RoICE9PSAxO1xufSk7XG5cbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiQ3O1xuXG52YXIgZGVmaW5lQnVpbHRJbnMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMiA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDEoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvciQyKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNztcbnZhciB0b0xlbmd0aCQyID0gdG9MZW5ndGgkNjtcblxudmFyICRSYW5nZUVycm9yJDIgPSBSYW5nZUVycm9yO1xuXG4vLyBgVG9JbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0luZGV4JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoJDIobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyAkUmFuZ2VFcnJvciQyKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgJEFycmF5JDIgPSBBcnJheTtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxudmFyIHBhY2sgPSBmdW5jdGlvbiAobnVtYmVyLCBtYW50aXNzYUxlbmd0aCwgYnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9ICRBcnJheSQyKGJ5dGVzKTtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbWFudGlzc2FMZW5ndGggPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBzaWduID0gbnVtYmVyIDwgMCB8fCBudW1iZXIgPT09IDAgJiYgMSAvIG51bWJlciA8IDAgPyAxIDogMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgYztcbiAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIGlmIChudW1iZXIgIT0gbnVtYmVyIHx8IG51bWJlciA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIG1hbnRpc3NhID0gbnVtYmVyICE9IG51bWJlciA/IDEgOiAwO1xuICAgIGV4cG9uZW50ID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBleHBvbmVudCA9IGZsb29yJDEobG9nKG51bWJlcikgLyBMTjIpO1xuICAgIGMgPSBwb3coMiwgLWV4cG9uZW50KTtcbiAgICBpZiAobnVtYmVyICogYyA8IDEpIHtcbiAgICAgIGV4cG9uZW50LS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG51bWJlciArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlciArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyICogYyA+PSAyKSB7XG4gICAgICBleHBvbmVudCsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtYW50aXNzYSA9IDA7XG4gICAgICBleHBvbmVudCA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG1hbnRpc3NhID0gKG51bWJlciAqIGMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hbnRpc3NhID0gbnVtYmVyICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgICAgZXhwb25lbnQgPSAwO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobWFudGlzc2FMZW5ndGggPj0gOCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IG1hbnRpc3NhICYgMjU1O1xuICAgIG1hbnRpc3NhIC89IDI1NjtcbiAgICBtYW50aXNzYUxlbmd0aCAtPSA4O1xuICB9XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgPDwgbWFudGlzc2FMZW5ndGggfCBtYW50aXNzYTtcbiAgZXhwb25lbnRMZW5ndGggKz0gbWFudGlzc2FMZW5ndGg7XG4gIHdoaWxlIChleHBvbmVudExlbmd0aCA+IDApIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBleHBvbmVudCAmIDI1NTtcbiAgICBleHBvbmVudCAvPSAyNTY7XG4gICAgZXhwb25lbnRMZW5ndGggLT0gODtcbiAgfVxuICBidWZmZXJbLS1pbmRleF0gfD0gc2lnbiAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbnZhciB1bnBhY2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYW50aXNzYUxlbmd0aCkge1xuICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBleHBvbmVudExlbmd0aCAtIDc7XG4gIHZhciBpbmRleCA9IGJ5dGVzIC0gMTtcbiAgdmFyIHNpZ24gPSBidWZmZXJbaW5kZXgtLV07XG4gIHZhciBleHBvbmVudCA9IHNpZ24gJiAxMjc7XG4gIHZhciBtYW50aXNzYTtcbiAgc2lnbiA+Pj0gNztcbiAgd2hpbGUgKG5CaXRzID4gMCkge1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKiAyNTYgKyBidWZmZXJbaW5kZXgtLV07XG4gICAgbkJpdHMgLT0gODtcbiAgfVxuICBtYW50aXNzYSA9IGV4cG9uZW50ICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGV4cG9uZW50ID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1hbnRpc3NhTGVuZ3RoO1xuICB3aGlsZSAobkJpdHMgPiAwKSB7XG4gICAgbWFudGlzc2EgPSBtYW50aXNzYSAqIDI1NiArIGJ1ZmZlcltpbmRleC0tXTtcbiAgICBuQml0cyAtPSA4O1xuICB9XG4gIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgIGV4cG9uZW50ID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGV4cG9uZW50ID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG1hbnRpc3NhID8gTmFOIDogc2lnbiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSBlQmlhcztcbiAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG59O1xuXG52YXIgaWVlZTc1NCA9IHtcbiAgcGFjazogcGFjayxcbiAgdW5wYWNrOiB1bnBhY2tcbn07XG5cbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkNjtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQzO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxudmFyIGFycmF5RmlsbCQxID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0JDIodGhpcyk7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDEoYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleCQxKGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkMShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDM7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDU7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBjcmVhdGVQcm9wZXJ0eSQxO1xuXG52YXIgJEFycmF5JDEgPSBBcnJheTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSAkQXJyYXkkMShtYXgoZmluIC0gaywgMCkpO1xuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGk7XG52YXIgdW5jdXJyeVRoaXMkMyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBhcnJheUJ1ZmZlckJhc2ljRGV0ZWN0aW9uO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGRlZmluZUJ1aWx0SW5zID0gZGVmaW5lQnVpbHRJbnMkMTtcbnZhciBmYWlscyA9IGZhaWxzJGs7XG52YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQyO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNztcbnZhciB0b0xlbmd0aCQxID0gdG9MZW5ndGgkNjtcbnZhciB0b0luZGV4JDEgPSB0b0luZGV4JDI7XG52YXIgSUVFRTc1NCA9IGllZWU3NTQ7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQyID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBhcnJheUZpbGwgPSBhcnJheUZpbGwkMTtcbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHNldFRvU3RyaW5nVGFnJDI7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQxID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuc2V0O1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEgkMSA9ICdXcm9uZyBsZW5ndGgnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4JztcbnZhciBOYXRpdmVBcnJheUJ1ZmZlciA9IGdsb2JhbCQyW0FSUkFZX0JVRkZFUl07XG52YXIgJEFycmF5QnVmZmVyID0gTmF0aXZlQXJyYXlCdWZmZXI7XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSA9ICRBcnJheUJ1ZmZlciAmJiAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWwkMltEQVRBX1ZJRVddO1xudmFyIERhdGFWaWV3UHJvdG90eXBlID0gJERhdGFWaWV3ICYmICREYXRhVmlld1tQUk9UT1RZUEVdO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgQXJyYXkkMSA9IGdsb2JhbCQyLkFycmF5O1xudmFyIFJhbmdlRXJyb3IkMiA9IGdsb2JhbCQyLlJhbmdlRXJyb3I7XG52YXIgZmlsbCA9IHVuY3VycnlUaGlzJDMoYXJyYXlGaWxsKTtcbnZhciByZXZlcnNlID0gdW5jdXJyeVRoaXMkMyhbXS5yZXZlcnNlKTtcblxudmFyIHBhY2tJRUVFNzU0ID0gSUVFRTc1NC5wYWNrO1xudmFyIHVucGFja0lFRUU3NTQgPSBJRUVFNzU0LnVucGFjaztcblxudmFyIHBhY2tJbnQ4ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkZdO1xufTtcblxudmFyIHBhY2tJbnQxNiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGLCBudW1iZXIgPj4gOCAmIDB4RkZdO1xufTtcblxudmFyIHBhY2tJbnQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGLCBudW1iZXIgPj4gOCAmIDB4RkYsIG51bWJlciA+PiAxNiAmIDB4RkYsIG51bWJlciA+PiAyNCAmIDB4RkZdO1xufTtcblxudmFyIHVucGFja0ludDMyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyWzNdIDw8IDI0IHwgYnVmZmVyWzJdIDw8IDE2IHwgYnVmZmVyWzFdIDw8IDggfCBidWZmZXJbMF07XG59O1xuXG52YXIgcGFja0Zsb2F0MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDIzLCA0KTtcbn07XG5cbnZhciBwYWNrRmxvYXQ2NCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgNTIsIDgpO1xufTtcblxudmFyIGFkZEdldHRlciQxID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBrZXkpIHtcbiAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3JbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpW2tleV07IH0gfSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleCQxKGluZGV4KTtcbiAgdmFyIHN0b3JlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUkMShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gYXJyYXlTbGljZShieXRlcywgc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcmV2ZXJzZShwYWNrKTtcbn07XG5cbnZhciBzZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleCQxKGluZGV4KTtcbiAgdmFyIHN0b3JlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUkMShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIGJ5dGVzW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGNvdW50IC0gaSAtIDFdO1xufTtcblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBBcnJheUJ1ZmZlclByb3RvdHlwZSQxKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgkMShsZW5ndGgpO1xuICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICBieXRlczogZmlsbChBcnJheSQxKGJ5dGVMZW5ndGgpLCAwKSxcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGhcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTJDIpIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdO1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBEYXRhVmlld1Byb3RvdHlwZSk7XG4gICAgYW5JbnN0YW5jZSQxKGJ1ZmZlciwgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUkMShidWZmZXIpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMignV3Jvbmcgb2Zmc2V0Jyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoJDEoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19MRU5HVEgkMSk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMkMikge1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfTtcblxuICBEYXRhVmlld1Byb3RvdHlwZSA9ICREYXRhVmlld1tQUk9UT1RZUEVdO1xuXG4gIGlmIChERVNDUklQVE9SUyQyKSB7XG4gICAgYWRkR2V0dGVyJDEoJEFycmF5QnVmZmVyLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIkMSgkRGF0YVZpZXcsICdieXRlT2Zmc2V0Jyk7XG4gIH1cblxuICBkZWZpbmVCdWlsdElucyhEYXRhVmlld1Byb3RvdHlwZSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDIzKTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSwgNTIpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJbnQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQ2NCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgdmFyIElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIE5hdGl2ZUFycmF5QnVmZmVyLm5hbWUgIT09IEFSUkFZX0JVRkZFUjtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigtMSk7XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoKTtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoMS41KTtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoTmFOKTtcbiAgICByZXR1cm4gTmF0aXZlQXJyYXlCdWZmZXIubGVuZ3RoICE9IDEgfHwgSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FICYmICFDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRTtcbiAgfSkpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSQxKHRoaXMsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgICAgcmV0dXJuIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcih0b0luZGV4JDEobGVuZ3RoKSk7XG4gICAgfTtcblxuICAgICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQXJyYXlCdWZmZXJQcm90b3R5cGUkMTtcblxuICAgIGZvciAodmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEoTmF0aXZlQXJyYXlCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBcnJheUJ1ZmZlclByb3RvdHlwZSQxLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9IGVsc2UgaWYgKElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKE5hdGl2ZUFycmF5QnVmZmVyLCAnbmFtZScsIEFSUkFZX0JVRkZFUik7XG4gIH1cblxuICAvLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcbiAgaWYgKHNldFByb3RvdHlwZU9mJDIgJiYgZ2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUpICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBzZXRQcm90b3R5cGVPZiQyKERhdGFWaWV3UHJvdG90eXBlLCBPYmplY3RQcm90b3R5cGUpO1xuICB9XG5cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB0ZXN0VmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9IHVuY3VycnlUaGlzJDMoRGF0YVZpZXdQcm90b3R5cGUuc2V0SW50OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh0ZXN0Vmlldy5nZXRJbnQ4KDApIHx8ICF0ZXN0Vmlldy5nZXRJbnQ4KDEpKSBkZWZpbmVCdWlsdElucyhEYXRhVmlld1Byb3RvdHlwZSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4KHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDgodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG59XG5cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcblxudmFyIGFycmF5QnVmZmVyID0ge1xuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyLFxuICBEYXRhVmlldzogJERhdGFWaWV3XG59O1xuXG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JGU7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBJc0ludGVncmFsTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNpbnRlZ3JhbG51bWJlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW51bWJlci1pc2ludGVnZXIgLS0gc2FmZVxudmFyIGlzSW50ZWdyYWxOdW1iZXIkMSA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QkNChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNztcblxudmFyICRSYW5nZUVycm9yJDEgPSBSYW5nZUVycm9yO1xuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpdCk7XG4gIGlmIChyZXN1bHQgPCAwKSB0aHJvdyAkUmFuZ2VFcnJvciQxKFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRvUG9zaXRpdmVJbnRlZ2VyID0gdG9Qb3NpdGl2ZUludGVnZXIkMTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxudmFyIHRvT2Zmc2V0JDEgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gIHZhciBvZmZzZXQgPSB0b1Bvc2l0aXZlSW50ZWdlcihpdCk7XG4gIGlmIChvZmZzZXQgJSBCWVRFUykgdGhyb3cgJFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCcpO1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzQ2xhdXNlO1xudmFyIGFDYWxsYWJsZSQxID0gYUNhbGxhYmxlJDQ7XG52YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBiaW5kJDIgPSB1bmN1cnJ5VGhpcyQyKHVuY3VycnlUaGlzJDIuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGZ1bmN0aW9uQmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlJDEoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQkMihmbiwgdGhhdCkgOiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIGNsYXNzb2YkMyA9IGNsYXNzb2YkYTtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkNDtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkJDY7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkMygnaXRlcmF0b3InKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdCkpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SJDEpXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzJDFbY2xhc3NvZiQzKGl0KV07XG59O1xuXG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ0O1xudmFyIGFuT2JqZWN0ID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG5cbnZhciAkVHlwZUVycm9yJDEgPSBUeXBlRXJyb3I7XG5cbnZhciBnZXRJdGVyYXRvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QkMShhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0KGNhbGwkMihpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkZztcbnZhciBJdGVyYXRvcnMgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCQyKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiRhO1xuXG52YXIgaXNCaWdJbnRBcnJheSQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YkMihpdCk7XG4gIHJldHVybiBrbGFzcyA9PSAnQmlnSW50NjRBcnJheScgfHwga2xhc3MgPT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn07XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDI7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgVG9CaWdJbnRgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2JpZ2ludFxudmFyIHRvQmlnSW50JDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIHByaW0gPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICBpZiAodHlwZW9mIHByaW0gPT0gJ251bWJlcicpIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG51bWJlciB0byBiaWdpbnRcIik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1iaWdpbnQgLS0gc2FmZVxuICByZXR1cm4gQmlnSW50KHByaW0pO1xufTtcblxudmFyIGJpbmQkMSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCQ2O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDE7XG52YXIgaXNCaWdJbnRBcnJheSA9IGlzQmlnSW50QXJyYXkkMTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDIgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgdG9CaWdJbnQgPSB0b0JpZ0ludCQxO1xuXG52YXIgdHlwZWRBcnJheUZyb20kMiA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgdmFyIEMgPSBhQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBPID0gdG9PYmplY3QkMShzb3VyY2UpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGksIGxlbmd0aCwgcmVzdWx0LCB0aGlzSXNCaWdJbnRBcnJheSwgdmFsdWUsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0O1xuICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgIWlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpIHtcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKE8sIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICBPID0gW107XG4gICAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkMShuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgIE8ucHVzaChzdGVwLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hcHBpbmcgJiYgYXJndW1lbnRzTGVuZ3RoID4gMikge1xuICAgIG1hcGZuID0gYmluZCQxKG1hcGZuLCBhcmd1bWVudHNbMl0pO1xuICB9XG4gIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoTyk7XG4gIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyKEMpKShsZW5ndGgpO1xuICB0aGlzSXNCaWdJbnRBcnJheSA9IGlzQmlnSW50QXJyYXkocmVzdWx0KTtcbiAgZm9yIChpID0gMDsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIC8vIEZGMzAtIHR5cGVkIGFycmF5cyBkb2Vzbid0IHByb3Blcmx5IGNvbnZlcnQgb2JqZWN0cyB0byB0eXBlZCBhcnJheSB2YWx1ZXNcbiAgICByZXN1bHRbaV0gPSB0aGlzSXNCaWdJbnRBcnJheSA/IHRvQmlnSW50KHZhbHVlKSA6ICt2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNsYXNzb2YkMSA9IGNsYXNzb2ZSYXckMjtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mJDEoYXJndW1lbnQpID09ICdBcnJheSc7XG59O1xuXG52YXIgaXNBcnJheSA9IGlzQXJyYXkkMTtcbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCRlO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkMSgnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKEMpICYmIChDID09PSAkQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0JDMoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVMkMV07XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xuXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDY7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IGFycmF5U3BlY2llc0NyZWF0ZSQxO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzJDEoW10ucHVzaCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxufTtcblxudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDY7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCRnO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMSA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMkMSAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRrO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCRlO1xudmFyIHNldFByb3RvdHlwZU9mJDEgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xudmFyIGluaGVyaXRJZlJlcXVpcmVkJDEgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mJDEgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgaXNDYWxsYWJsZShOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdCQyKE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mJDEoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkMSA9IGdsb2JhbCRpO1xudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTJDIgPSB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUkMSA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgQXJyYXlCdWZmZXJNb2R1bGUgPSBhcnJheUJ1ZmZlcjtcbnZhciBhbkluc3RhbmNlID0gYW5JbnN0YW5jZSQyO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGlzSW50ZWdyYWxOdW1iZXIgPSBpc0ludGVncmFsTnVtYmVyJDE7XG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQ2O1xudmFyIHRvSW5kZXggPSB0b0luZGV4JDI7XG52YXIgdG9PZmZzZXQgPSB0b09mZnNldCQxO1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBjbGFzc29mID0gY2xhc3NvZiRhO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCRlO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMztcbnZhciBjcmVhdGUgPSBvYmplY3RDcmVhdGU7XG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xudmFyIHR5cGVkQXJyYXlGcm9tJDEgPSB0eXBlZEFycmF5RnJvbSQyO1xudmFyIGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBpbmhlcml0SWZSZXF1aXJlZCQxO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIFJhbmdlRXJyb3IkMSA9IGdsb2JhbCQxLlJhbmdlRXJyb3I7XG52YXIgQXJyYXlCdWZmZXIkMSA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gQXJyYXlCdWZmZXIkMS5wcm90b3R5cGU7XG52YXIgRGF0YVZpZXckMSA9IEFycmF5QnVmZmVyTW9kdWxlLkRhdGFWaWV3O1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuVFlQRURfQVJSQVlfVEFHO1xudmFyIFR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuVHlwZWRBcnJheTtcbnZhciBUeXBlZEFycmF5UHJvdG90eXBlJDIgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuVHlwZWRBcnJheVByb3RvdHlwZTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBpc1R5cGVkQXJyYXkkMSA9IEFycmF5QnVmZmVyVmlld0NvcmUkMS5pc1R5cGVkQXJyYXk7XG52YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGgnO1xuXG52YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEoQyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldO1xuICB9IH0pO1xufTtcblxudmFyIGlzQXJyYXlCdWZmZXIkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIga2xhc3M7XG4gIHJldHVybiBpc1Byb3RvdHlwZU9mKEFycmF5QnVmZmVyUHJvdG90eXBlLCBpdCkgfHwgKGtsYXNzID0gY2xhc3NvZihpdCkpID09ICdBcnJheUJ1ZmZlcicgfHwga2xhc3MgPT0gJ1NoYXJlZEFycmF5QnVmZmVyJztcbn07XG5cbnZhciBpc1R5cGVkQXJyYXlJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5JDEodGFyZ2V0KVxuICAgICYmICFpc1N5bWJvbChrZXkpXG4gICAgJiYga2V5IGluIHRhcmdldFxuICAgICYmIGlzSW50ZWdyYWxOdW1iZXIoK2tleSlcbiAgICAmJiBrZXkgPj0gMDtcbn07XG5cbnZhciB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgcmV0dXJuIGlzVHlwZWRBcnJheUluZGV4KHRhcmdldCwga2V5KVxuICAgID8gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDIsIHRhcmdldFtrZXldKVxuICAgIDogbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbn07XG5cbnZhciB3cmFwcGVkRGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSlcbiAgICAmJiBpc09iamVjdCQxKGRlc2NyaXB0b3IpXG4gICAgJiYgaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpXG4gICAgJiYgIWhhc093bihkZXNjcmlwdG9yLCAnZ2V0JylcbiAgICAmJiAhaGFzT3duKGRlc2NyaXB0b3IsICdzZXQnKVxuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgJiYgKCFoYXNPd24oZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAmJiAoIWhhc093bihkZXNjcmlwdG9yLCAnZW51bWVyYWJsZScpIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSlcbiAgKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbn07XG5cbmlmIChERVNDUklQVE9SUykge1xuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9IHdyYXBwZWREZWZpbmVQcm9wZXJ0eTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSQyLCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUkMiwgJ2J5dGVPZmZzZXQnKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSQyLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlJDIsICdsZW5ndGgnKTtcbiAgfVxuXG4gICQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXBwZWREZWZpbmVQcm9wZXJ0eVxuICB9KTtcblxuICB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgdmFyIEJZVEVTID0gVFlQRS5tYXRjaCgvXFxkKyQvKVswXSAvIDg7XG4gICAgdmFyIENPTlNUUlVDVE9SX05BTUUgPSBUWVBFICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcbiAgICB2YXIgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDFbQ09OU1RSVUNUT1JfTkFNRV07XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICByZXR1cm4gZGF0YS52aWV3W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSByb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4RkYgPyAweEZGIDogdmFsdWUgJiAweEZGO1xuICAgICAgZGF0YS52aWV3W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCBvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aDtcbiAgICAgICAgaWYgKCFpc09iamVjdCQxKGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyJDEoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlciQxKGRhdGEpKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gdG9PZmZzZXQob2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvciQxKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IkMShXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgYnl0ZU9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IkMShXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5JDEoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2FsbCh0eXBlZEFycmF5RnJvbSQxLCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgICAgIGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXQsXG4gICAgICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICB2aWV3OiBuZXcgRGF0YVZpZXckMShidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShUeXBlZEFycmF5UHJvdG90eXBlJDIpO1xuICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQyKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5oZXJpdElmUmVxdWlyZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNPYmplY3QkMShkYXRhKSkgcmV0dXJuIG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IodG9JbmRleChkYXRhKSk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIkMShkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0KHR5cGVkQXJyYXlPZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogdHlwZWRBcnJheU9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhKTtcbiAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5JDEoZGF0YSkpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiBjYWxsKHR5cGVkQXJyYXlGcm9tJDEsIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0oKSwgZHVtbXksIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgZm9yRWFjaChnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBrZXksIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUuY29uc3RydWN0b3IgIT09IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpLlR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgIGlmIChUWVBFRF9BUlJBWV9UQUcpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIFRZUEVEX0FSUkFZX1RBRywgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgfVxuXG4gICAgdmFyIEZPUkNFRCA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAhPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbiAgICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgICQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfSwgZXhwb3J0ZWQpO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH07XG59IGVsc2UgdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkOCA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgRmxvYXQzMkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbmNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQ4KCdGbG9hdDMyJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNyA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgRmxvYXQ2NEFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbmNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQ3KCdGbG9hdDY0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNiA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgSW50OEFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbmNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQ2KCdJbnQ4JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNSA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgSW50MTZBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNSgnSW50MTYnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNCA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgSW50MzJBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkNCgnSW50MzInLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkMyA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgVWludDhBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkMygnVWludDgnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkMiA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgVWludDhDbGFtcGVkQXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xuY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yJDIoJ1VpbnQ4JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcblxudmFyIGNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQxID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHM7XG5cbi8vIGBVaW50MTZBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IkMSgnVWludDE2JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxudmFyIGNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzO1xuXG4vLyBgVWludDMyQXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xuY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50MzInLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG52YXIgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQxID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yc1JlcXVpcmVXcmFwcGVycztcbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q7XG52YXIgdHlwZWRBcnJheUZyb20gPSB0eXBlZEFycmF5RnJvbSQyO1xuXG4vLyBgJVR5cGVkQXJyYXklLmZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUuZnJvbVxuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCQxKCdmcm9tJywgdHlwZWRBcnJheUZyb20sIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMkMSk7XG5cbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yc1JlcXVpcmVXcmFwcGVycztcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZDtcblxuLy8gYCVUeXBlZEFycmF5JS5vZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5vZlxuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCgnb2YnLCBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0aGlzKSkobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICByZXR1cm4gcmVzdWx0O1xufSwgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyk7XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBxdW90ZS1wcm9wcyAqL1xuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MgKi9cblxuLy8gQWRkIGdsb2JhbCBjb25zdGFudHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb21tb25qc0dsb2JhbCwge1xuICAnT1NfQU5EUk9JRCc6IHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gICdPU19JT1MnOiB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIE9TX1ZFUlNJT05fTUFKT1I6IHtcbiAgICB2YWx1ZTogVGkuUGxhdGZvcm0udmVyc2lvbk1ham9yLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPU19WRVJTSU9OX01JTk9SOiB7XG4gICAgdmFsdWU6IFRpLlBsYXRmb3JtLnZlcnNpb25NaW5vcixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1NfVkVSU0lPTl9QQVRDSDoge1xuICAgIHZhbHVlOiBUaS5QbGF0Zm9ybS52ZXJzaW9uUGF0Y2gsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH1cbn0pO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCBrTm9kZU1vZHVsZXNSRSA9IC9eKC4qKVtcXFxcL11ub2RlX21vZHVsZXNbXFxcXC9dLztcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpO1xuY29uc3QgaXNCdWZmZXIgPSBTeW1ib2wuZm9yKCd0aXRhbml1bS5idWZmZXIuaXNCdWZmZXInKTtcbmNvbnN0IGNvbG9yUmVnRXhwID0gL1xcdTAwMWJcXFtcXGRcXGQ/bS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuZnVuY3Rpb24gcmVtb3ZlQ29sb3JzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY29sb3JSZWdFeHAsICcnKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAvLyBBbiBlcnJvciBjb3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB3aGlsZSBub3QgYmVpbmcgYSBuYXRpdmUgZXJyb3JcbiAgLy8gb3IgY291bGQgYmUgZnJvbSBhIGRpZmZlcmVudCByZWFsbSBhbmQgbm90IGJlIGluc3RhbmNlIG9mIEVycm9yIGJ1dCBzdGlsbFxuICAvLyBiZSBhIG5hdGl2ZSBlcnJvci5cbiAgcmV0dXJuIGlzTmF0aXZlRXJyb3IoZSkgfHwgZSBpbnN0YW5jZW9mIEVycm9yO1xufVxubGV0IGdldFN0cnVjdHVyZWRTdGFjaztcbmNsYXNzIFN0YWNrVHJhY2VFcnJvciBleHRlbmRzIEVycm9yIHt9XG5TdGFja1RyYWNlRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoZXJyLCB0cmFjZSkgPT4gdHJhY2U7XG5TdGFja1RyYWNlRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gSW5maW5pdHk7XG5mdW5jdGlvbiBpc0luc2lkZU5vZGVNb2R1bGVzKCkge1xuICBpZiAoZ2V0U3RydWN0dXJlZFN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICBnZXRTdHJ1Y3R1cmVkU3RhY2sgPSAoKSA9PiBuZXcgU3RhY2tUcmFjZUVycm9yKCkuc3RhY2s7XG4gIH1cbiAgbGV0IHN0YWNrID0gZ2V0U3RydWN0dXJlZFN0YWNrKCk7XG5cbiAgLy8gc3RhY2sgaXMgb25seSBhbiBhcnJheSBvbiB2OCwgdHJ5IHRvIGNvbnZlcnQgbWFudWFsbHkgaWYgc3RyaW5nXG4gIGlmICh0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc3RhY2tGcmFtZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KC9cXG4vKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IGxpbmVJbmZvID0gbGluZS5tYXRjaCgvKC4qKUAoLiopOihcXGQrKTooXFxkKykvKTtcbiAgICAgIGlmIChsaW5lSW5mbykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGxpbmVJbmZvWzJdLnJlcGxhY2UoJ2ZpbGU6Ly8nLCAnJyk7XG4gICAgICAgIHN0YWNrRnJhbWVzLnB1c2goe1xuICAgICAgICAgIGdldEZpbGVOYW1lOiAoKSA9PiBmaWxlbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sgPSBzdGFja0ZyYW1lcztcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgc3RhY2sgZnJhbWVzIGFuZCBsb29rIGZvciB0aGUgZmlyc3Qgb25lIG5vdCBjb21pbmdcbiAgLy8gZnJvbSBpbnNpZGUgTm9kZS5qcyBpdHNlbGY6XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIGZvciAoY29uc3QgZnJhbWUgb2Ygc3RhY2spIHtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gZnJhbWUuZ2V0RmlsZU5hbWUoKTtcbiAgICAgIC8vIElmIGEgZmlsZW5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCAvIG9yIGNvbnRhaW4gXFwsXG4gICAgICAvLyBpdCdzIGxpa2VseSBmcm9tIE5vZGUuanMgY29yZS5cbiAgICAgIGlmICghL15cXC98XFxcXC8udGVzdChmaWxlbmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4ga05vZGVNb2R1bGVzUkUudGVzdChmaWxlbmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGpvaW4kMShvdXRwdXQsIHNlcGFyYXRvcikge1xuICBsZXQgc3RyID0gJyc7XG4gIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgLy8gSXQgaXMgZmFzdGVyIG5vdCB0byB1c2UgYSB0ZW1wbGF0ZSBzdHJpbmcgaGVyZVxuICAgICAgc3RyICs9IG91dHB1dFtpXTtcbiAgICAgIHN0ciArPSBzZXBhcmF0b3I7XG4gICAgfVxuICAgIHN0ciArPSBvdXRwdXRbbGFzdEluZGV4XTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmNvbnN0IEFMTF9QUk9QRVJUSUVTJDIgPSAwO1xuY29uc3QgT05MWV9FTlVNRVJBQkxFJDIgPSAyO1xuY29uc3QgcHJvcGVydHlGaWx0ZXIgPSB7XG4gIEFMTF9QUk9QRVJUSUVTOiBBTExfUFJPUEVSVElFUyQyLFxuICBPTkxZX0VOVU1FUkFCTEU6IE9OTFlfRU5VTUVSQUJMRSQyXG59O1xuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKG9iaiwgZmlsdGVyKSB7XG4gIGNvbnN0IHByb3BzID0gW107XG4gIGNvbnN0IGtleXMgPSBmaWx0ZXIgPT09IE9OTFlfRU5VTUVSQUJMRSQyID8gT2JqZWN0LmtleXMob2JqKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFpc0FsbERpZ2l0cyhrZXkpKSB7XG4gICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGlzQWxsRGlnaXRzKHMpIHtcbiAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSk7XG5jb25zdCBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcgPSB1bmN1cnJ5VGhpcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgU3ltYm9sLnRvU3RyaW5nVGFnKS5nZXQpO1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgbmFtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYFtvYmplY3QgJHtuYW1lfV1gO1xufVxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0FyZ3VtZW50c09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXJndW1lbnRzJyk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdBcnJheUJ1ZmZlcicpO1xufVxuXG4vLyBDYWNoZWQgdG8gbWFrZSBzdXJlIG5vIHVzZXJsYW5kIGNvZGUgY2FuIHRhbXBlciB3aXRoIGl0LlxuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXN5bmNGdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdCb29sZWFuJyk7XG59XG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc051bWJlck9iamVjdCh2YWx1ZSkgfHwgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8IGlzQm9vbGVhbk9iamVjdCh2YWx1ZSlcbiAgLy8gfHwgaXNCaWdJbnRPYmplY3QodmFsdWUpXG4gIHx8IGlzU3ltYm9sT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0RhdGFWaWV3Jyk7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0RhdGUnKTtcbn1cblxuLy8gQHRvZG8gaXNFeHRlcm5hbFxuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0dlbmVyYXRvckZ1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnR2VuZXJhdG9yJyk7XG59XG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ01hcCcpO1xufVxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTWFwIEl0ZXJhdG9yJztcbn1cblxuLy8gQHRvZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcblxuZnVuY3Rpb24gaXNOYXRpdmVFcnJvcih2YWx1ZSkge1xuICAvLyBpZiBub3QgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IsIGRlZmluaXRlbHkgbm90IGEgbmF0aXZlIGVycm9yXG4gIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdmFsdWUgfHwgIXZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBbJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdSYW5nZUVycm9yJywgJ1JlZmVyZW5jZUVycm9yJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvciddLmluY2x1ZGVzKHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ051bWJlcicpO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdQcm9taXNlJyk7XG59XG5cbi8vIEB0b2RvIGlzUHJveHlcblxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1JlZ0V4cCcpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NldCcpO1xufVxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnU2V0IEl0ZXJhdG9yJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKCFnbG9iYWwuU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NoYXJlZEFycmF5QnVmZmVyJyk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3ltYm9sJyk7XG59XG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgY29uc3QgaXNCdWlsdEluVHlwZWRBcnJheSA9IFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgIT09IHVuZGVmaW5lZDtcbiAgaWYgKGlzQnVpbHRJblR5cGVkQXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWVbaXNCdWZmZXJdID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1dlYWtNYXAnKTtcbn1cbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnV2Vha1NldCcpO1xufVxuXG4vLyBAdG9kbyBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGVcblxudmFyIHR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGlzQW55QXJyYXlCdWZmZXI6IGlzQW55QXJyYXlCdWZmZXIsXG5cdGlzQXJndW1lbnRzT2JqZWN0OiBpc0FyZ3VtZW50c09iamVjdCxcblx0aXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcblx0aXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuXHRpc0FzeW5jRnVuY3Rpb246IGlzQXN5bmNGdW5jdGlvbixcblx0aXNCaWdJbnQ2NEFycmF5OiBpc0JpZ0ludDY0QXJyYXksXG5cdGlzQmlnVWludDY0QXJyYXk6IGlzQmlnVWludDY0QXJyYXksXG5cdGlzQm9vbGVhbk9iamVjdDogaXNCb29sZWFuT2JqZWN0LFxuXHRpc0JveGVkUHJpbWl0aXZlOiBpc0JveGVkUHJpbWl0aXZlLFxuXHRpc0RhdGFWaWV3OiBpc0RhdGFWaWV3LFxuXHRpc0RhdGU6IGlzRGF0ZSxcblx0aXNGbG9hdDMyQXJyYXk6IGlzRmxvYXQzMkFycmF5LFxuXHRpc0Zsb2F0NjRBcnJheTogaXNGbG9hdDY0QXJyYXksXG5cdGlzR2VuZXJhdG9yRnVuY3Rpb246IGlzR2VuZXJhdG9yRnVuY3Rpb24sXG5cdGlzR2VuZXJhdG9yT2JqZWN0OiBpc0dlbmVyYXRvck9iamVjdCxcblx0aXNJbnQ4QXJyYXk6IGlzSW50OEFycmF5LFxuXHRpc0ludDE2QXJyYXk6IGlzSW50MTZBcnJheSxcblx0aXNJbnQzMkFycmF5OiBpc0ludDMyQXJyYXksXG5cdGlzTWFwOiBpc01hcCxcblx0aXNNYXBJdGVyYXRvcjogaXNNYXBJdGVyYXRvcixcblx0aXNOYXRpdmVFcnJvcjogaXNOYXRpdmVFcnJvcixcblx0aXNOdW1iZXJPYmplY3Q6IGlzTnVtYmVyT2JqZWN0LFxuXHRpc1Byb21pc2U6IGlzUHJvbWlzZSxcblx0aXNSZWdFeHA6IGlzUmVnRXhwLFxuXHRpc1NldDogaXNTZXQsXG5cdGlzU2V0SXRlcmF0b3I6IGlzU2V0SXRlcmF0b3IsXG5cdGlzU2hhcmVkQXJyYXlCdWZmZXI6IGlzU2hhcmVkQXJyYXlCdWZmZXIsXG5cdGlzU3RyaW5nT2JqZWN0OiBpc1N0cmluZ09iamVjdCxcblx0aXNTeW1ib2xPYmplY3Q6IGlzU3ltYm9sT2JqZWN0LFxuXHRpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcblx0aXNVaW50OEFycmF5OiBpc1VpbnQ4QXJyYXksXG5cdGlzVWludDhDbGFtcGVkQXJyYXk6IGlzVWludDhDbGFtcGVkQXJyYXksXG5cdGlzVWludDE2QXJyYXk6IGlzVWludDE2QXJyYXksXG5cdGlzVWludDMyQXJyYXk6IGlzVWludDMyQXJyYXksXG5cdGlzV2Vha01hcDogaXNXZWFrTWFwLFxuXHRpc1dlYWtTZXQ6IGlzV2Vha1NldFxufSk7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmxldCBlcnJvcjtcbmZ1bmN0aW9uIGxhenlFcnJvcigpIHtcbiAgaWYgKCFlcnJvcikge1xuICAgIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gICAgLy8gZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLmNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT047XG4gICAgZXJyb3IgPSBjb2Rlcy5FUlJfSU5URVJOQUxfQVNTRVJUSU9OO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGFzc2VydCQxKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBjb25zdCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OID0gbGF6eUVycm9yKCk7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04obWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICBjb25zdCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OID0gbGF6eUVycm9yKCk7XG4gIHRocm93IG5ldyBFUlJfSU5URVJOQUxfQVNTRVJUSU9OKG1lc3NhZ2UpO1xufVxuYXNzZXJ0JDEuZmFpbCA9IGZhaWw7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IG1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuY29uc3QgY29kZXMgPSB7fTtcblxuLy8gQHRvZG8gaW1wbGVtZW50IHRoaXMgb25jZSBuZWVkZWRcbmNsYXNzIFN5c3RlbUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLlxuZnVuY3Rpb24gRShzeW0sIHZhbCwgZGVmKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgU3lzdGVtRXJyb3IgdGhhdCBmb3JtYXRzIHRoZSBlcnJvciBtZXNzYWdlIGRpZmZlcmVudGx5XG4gIC8vIFRoZSBTeXN0ZW1FcnJvcnMgb25seSBoYXZlIFN5c3RlbUVycm9yIGFzIHRoZWlyIGJhc2UgY2xhc3Nlcy5cbiAgbWVzc2FnZXMuc2V0KHN5bSwgdmFsKTtcbiAgaWYgKGRlZiA9PT0gU3lzdGVtRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgY29tcGF0aWJsZSBTeXN0ZW1FcnJvciBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICB9IGVsc2Uge1xuICAgIGRlZiA9IG1ha2VOb2RlRXJyb3JXaXRoQ29kZShkZWYsIHN5bSk7XG4gIH1cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG90aGVyQ2xhc3NlcyA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgb3RoZXJDbGFzc2VzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAob3RoZXJDbGFzc2VzLmxlbmd0aCAhPT0gMCkge1xuICAgIG90aGVyQ2xhc3Nlcy5mb3JFYWNoKGNsYXp6ID0+IHtcbiAgICAgIGRlZltjbGF6ei5uYW1lXSA9IG1ha2VOb2RlRXJyb3JXaXRoQ29kZShjbGF6eiwgc3ltKTtcbiAgICB9KTtcbiAgfVxuICBjb2Rlc1tzeW1dID0gZGVmO1xufVxuZnVuY3Rpb24gbWFrZU5vZGVFcnJvcldpdGhDb2RlKEJhc2UsIGtleSkge1xuICByZXR1cm4gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlKGtleSwgYXJncywgdGhpcyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRDb2RlVG9OYW1lKHRoaXMsIHN1cGVyLm5hbWUsIGtleSk7XG4gICAgfVxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc2V0IGNvZGUodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2tleX1dOiAke3RoaXMubWVzc2FnZX1gO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoa2V5LCBhcmdzLCBzZWxmKSB7XG4gIGNvbnN0IG1zZyA9IG1lc3NhZ2VzLmdldChrZXkpO1xuXG4gIC8qXG4gIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkge1xuICBcdGFzc2VydCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXNzZXJ0Jyk7XG4gIH1cbiAgKi9cblxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2VydCQxKG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zIGRvIG5vdCBjb3VudC5cbiAgICBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IGAgKyBgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7bXNnLmxlbmd0aH0pLmApO1xuICAgIHJldHVybiBtc2cuYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGFzc2VydCQxKGV4cGVjdGVkTGVuZ3RoID09PSBhcmdzLmxlbmd0aCwgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBgICsgYG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke2V4cGVjdGVkTGVuZ3RofSkuYCk7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtc2c7XG4gIH1cbiAgYXJncy51bnNoaWZ0KG1zZyk7XG4gIHJldHVybiBmb3JtYXQkMS5hcHBseShudWxsLCBhcmdzKTtcbiAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgLy8gcmV0dXJuIGxhenlJbnRlcm5hbFV0aWxJbnNwZWN0KCkuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhZGRDb2RlVG9OYW1lKGVyciwgbmFtZSwgY29kZSkge1xuICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gIGVyci5uYW1lID0gYCR7bmFtZX0gWyR7Y29kZX1dYDtcbiAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgLy8gQGZpeG1lOiBUaGlzIG9ubHkgd29ya3Mgb24gVjgvQW5kcm9pZCwgaU9TL0pTQyBoYXMgYSBkaWZmZXJlbnQgRXJyb3Igc3RydWN0dXJlLlxuICAvLyBzaG91bGQgd2UgdHJ5IHRvIG1ha2UgZXJyb3JzIGJlaGF2ZSB0aGUgc2FtZSBhY3Jvc3MgcGxhdGZvcm1zP1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIGVyci5zdGFjaztcbiAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICBpZiAobmFtZSA9PT0gJ1N5c3RlbUVycm9yJykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICduYW1lJywge1xuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGVyci5uYW1lO1xuICB9XG59XG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuLy8gVXNpbmcgYSBkZWZhdWx0IGFyZ3VtZW50IGhlcmUgaXMgaW1wb3J0YW50IHNvIHRoZSBhcmd1bWVudCBpcyBub3QgY291bnRlZFxuLy8gdG93YXJkcyBgRnVuY3Rpb24jbGVuZ3RoYC5cbmZ1bmN0aW9uICgpIHtcbiAgbGV0IG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgaWYgKG5hbWUpIHtcbiAgICByZXR1cm4gYFwiJHtuYW1lfVwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7XG4gIH1cbiAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJztcbn0sIFJhbmdlRXJyb3IpO1xuRSgnRVJSX0lOVEVSTkFMX0FTU0VSVElPTicsIG1lc3NhZ2UgPT4ge1xuICBjb25zdCBzdWZmaXggPSAnVGhpcyBpcyBjYXVzZWQgYnkgZWl0aGVyIGEgYnVnIGluIFRpdGFuaXVtICcgKyAnb3IgaW5jb3JyZWN0IHVzYWdlIG9mIFRpdGFuaXVtIGludGVybmFscy5cXG4nICsgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIHdpdGggdGhpcyBzdGFjayB0cmFjZSBhdCAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS90aWRldi90aXRhbml1bS1zZGsvaXNzdWVzXFxuJztcbiAgcmV0dXJuIG1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/IHN1ZmZpeCA6IGAke21lc3NhZ2V9XFxuJHtzdWZmaXh9YDtcbn0sIEVycm9yKTtcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpID0+IHtcbiAgYXNzZXJ0JDEodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnXFwnbmFtZVxcJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgbGV0IGRldGVybWluZXI7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIGV4cGVjdGVkLnN0YXJ0c1dpdGgoJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuICBsZXQgbXNnO1xuICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gIH1cblxuICAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuICBtc2cgKz0gYC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YDtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5sZXQgbWF4U3RhY2tfRXJyb3JOYW1lO1xubGV0IG1heFN0YWNrX0Vycm9yTWVzc2FnZTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBlcnIubmFtZWAgYW5kIGBlcnIubWVzc2FnZWAgYXJlIGVxdWFsIHRvIGVuZ2luZS1zcGVjaWZpY1xuICogdmFsdWVzIGluZGljYXRpbmcgbWF4IGNhbGwgc3RhY2sgc2l6ZSBoYXMgYmVlbiBleGNlZWRlZC5cbiAqIFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiBpbiBWOC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSB7XG4gIGlmIChtYXhTdGFja19FcnJvck1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICBmdW5jdGlvbiBvdmVyZmxvd1N0YWNrKCkge1xuICAgICAgICBvdmVyZmxvd1N0YWNrKCk7XG4gICAgICB9XG4gICAgICBvdmVyZmxvd1N0YWNrKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbWF4U3RhY2tfRXJyb3JNZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgbWF4U3RhY2tfRXJyb3JOYW1lID0gZS5uYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyLm5hbWUgPT09IG1heFN0YWNrX0Vycm9yTmFtZSAmJiBlcnIubWVzc2FnZSA9PT0gbWF4U3RhY2tfRXJyb3JNZXNzYWdlO1xufVxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGFzc2VydCQxKHR5cGVvZiB0aGluZyA9PT0gJ3N0cmluZycsICdgdGhpbmdgIGhhcyB0byBiZSBvZiB0eXBlIHN0cmluZycpO1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICBjb25zdCBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgYXNzZXJ0JDEobGVuID4gMCwgJ0F0IGxlYXN0IG9uZSBleHBlY3RlZCB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChpID0+IFN0cmluZyhpKSk7XG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKX0sIG9yIGAgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX0gb3IgJHtleHBlY3RlZFsxXX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke1N0cmluZyhleHBlY3RlZCl9YDtcbiAgfVxufVxuXG5jbGFzcyBGYXN0QnVmZmVyIGV4dGVuZHMgVWludDhBcnJheSB7fVxuXG4vKipcbiAqIGxvb3Agb3ZlciBpbnB1dCwgZXZlcnkgMiBjaGFyYWN0ZXJzLCBwYXJzZSBhcyBhbiBpbnRcbiAqIGJhc2ljYWxseSBlYWNoIHR3byBjaGFyYWN0ZXJzIGFyZSBhIFwiYnl0ZVwiIG9yIGFuIDgtYml0IHVpbnRcbiAqIHdlIGFwcGVuZCB0aGVtIGFsbCB0b2dldGhlciB0byBmb3JtIGEgc2luZ2xlIGJ1ZmZlciBob2xkaW5nIGFsbCB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgc3RyaW5nIHdlJ3JlIGVuY29kaW5nIGluIGhleFxuICogQHJldHVybnMge2ludGVnZXJbXX0gYXJyYXkgb2YgZW5jb2RlZCBieXRlc1xuICovXG5mdW5jdGlvbiBzdHJpbmdUb0hleEJ5dGVzKHZhbHVlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aCAvIDI7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbnVtZXJpY1ZhbHVlID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKG51bWVyaWNWYWx1ZSkpIHtcbiAgICAgIC8vIGRyb3AgYmFkIGhleCBjaGFyYWN0ZXJzXG4gICAgICBieXRlQXJyYXkucHVzaChudW1lcmljVmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG4vLyBVc2UgYSBQcm94eSB0byBoYWNrIGFycmF5IHN0eWxlIGluZGV4IGFjY2Vzc29yc1xuY29uc3QgYXJyYXlJbmRleEhhbmRsZXIgPSB7XG4gIGdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbnVtID0gTnVtYmVyKHByb3BLZXkpO1xuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gaXNCdWZmZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wS2V5LCByZWNlaXZlcik7XG4gIH0sXG4gIHNldCh0YXJnZXQsIHByb3BLZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgcHJvcEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihwcm9wS2V5KTtcbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BLZXksIHZhbHVlLCByZWNlaXZlcik7XG4gIH0sXG4gIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbnVtID0gTnVtYmVyKGtleSk7XG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICAvLyBlbnN1cmUgaXQncyBhIHBvc2l0aXZlIFwic2FmZVwiIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgYnVmZmVyXG4gICAgICAgIHJldHVybiBudW0gPj0gMCAmJiBudW0gPCB0YXJnZXQuX3RpQnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleSBpbiB0YXJnZXQ7XG4gIH1cbn07XG5cbi8vIFRoaXMgaXMgYSBzcGVjaWFsIEJ1ZmZlciB0aGF0IHdyYXBzIFRpLkJ1ZmZlclxuLy8gYXMgYSByZXN1bHQgaXQgaXMgKm11Y2gqIHNsb3dlciB0byByZWFkL3dyaXRlIHZhbHVlc1xuLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGdvIGFjcm9zcyB0aGUgSlMvTmF0aXZlIGJvdW5kYXJ5IHBlci1ieXRlIVxuLy8gV2UgYWxzbyBuZWVkIHRvIHVzZSBhIFByb3h5IHRvIGhhbmRsZSBpbnRlcmNlcHRpbmcgc2V0L2dldCBvZiBpbmRpY2VzIHRvIHJlZGlyZWN0IHRvIHRoZSB1bmRlcmx5aW5nIFRpLkJ1ZmZlclxuY2xhc3MgU2xvd0J1ZmZlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlci5cbiAgICpcbiAgICogUHJpbWFyaWx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGlzIG1vZHVsZSB0b2dldGhlciB3aXRoIGBuZXdCdWZmZXJgIHRvXG4gICAqIGNyZWF0ZSBhIG5ldyBCdWZmZXIgaW5zdGFuY2Ugd3JhcHBpbmcgYSBUaS5CdWZmZXIuXG4gICAqXG4gICAqIEFsc28gc3VwcG9ydHMgdGhlIGRlcHJlY2F0ZWQgQnVmZmVyKCkgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBzYWZlXG4gICAqIHRvIHVzZSBvdXRzaWRlIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gdGlCdWZmZXIgdGhlIHVuZGVybHlpbmcgZGF0YS9ieXRlc1xuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBzdGFydCBvZmZzZXQgb2YgYXJyYXkvYnVmZmVyXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5L2J1ZmZlciB0byB3cmFwXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aUJ1ZmZlcikge1xuICAgIGxldCBzdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBsZXQgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aUJ1ZmZlci5sZW5ndGggLSBzdGFydDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBieXRlT2Zmc2V0OiB7XG4gICAgICAgIHZhbHVlOiBzdGFydFxuICAgICAgfSxcbiAgICAgIGxlbmd0aDoge1xuICAgICAgICB2YWx1ZTogbGVuZ3RoXG4gICAgICB9LFxuICAgICAgX3RpQnVmZmVyOiB7XG4gICAgICAgIHZhbHVlOiB0aUJ1ZmZlclxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGNyZWF0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlIGluc2lkZSBhIFByb3h5IHNvIHdlIGNhbiBoYW5kbGUgYXJyYXkgaW5kZXggYWNjZXNzXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAgICogQHJldHVybnMge0J1ZmZlcn0gd3JhcHBlZCBpbnNpZGUgYSBQcm94eVxuICAgKi9cbiAgc3RhdGljIGZyb21UaUJ1ZmZlcih0aUJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUHJveHkobmV3IFNsb3dCdWZmZXIodGlCdWZmZXIsIHN0YXJ0LCBsZW5ndGgpLCBhcnJheUluZGV4SGFuZGxlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5ldy1idWZmZXJcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cbiAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgY29uc3QgYmxvYiA9IFRpLlV0aWxzLmJhc2U2NGRlY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBibG9iU3RyZWFtID0gVGkuU3RyZWFtLmNyZWF0ZVN0cmVhbSh7XG4gICAgICAgIHNvdXJjZTogYmxvYixcbiAgICAgICAgbW9kZTogVGkuU3RyZWFtLk1PREVfUkVBRFxuICAgICAgfSk7XG4gICAgICBjb25zdCBidWZmZXIgPSBUaS5TdHJlYW0ucmVhZEFsbChibG9iU3RyZWFtKTtcbiAgICAgIGJsb2JTdHJlYW0uY2xvc2UoKTtcbiAgICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICBjb25zdCBieXRlcyA9IHN0cmluZ1RvSGV4Qnl0ZXModmFsdWUpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aUJ1ZmZlcltpXSA9IGJ5dGVzW2ldICYgMHhGRjsgLy8gbWFzayB0byBvbmUgYnl0ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGlCdWZmZXIpO1xuICAgIH1cbiAgICBjb25zdCB0aUJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB0eXBlOiBnZXRUaUNvZGVjQ2hhcnNldChlbmNvZGluZylcbiAgICB9KTtcbiAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGlCdWZmZXIpO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBhIG1ldGhvZCB3ZSBzaG91bGQgZ2V0IGJ5IGV4dGVuZGluZyBVaW50OEFycmF5LCBzbyByZWFsbHkgc2hvdWxkIG9ubHkgYmUgb3ZlcnJpZGVuIG9uIGEgXCJTbG93QnVmZmVyXCIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAvLyBHZXQgdGhlIHNsaWNlIG9mIHRoZSBhcnJheSBmcm9tIGJ5dGVPZmZzZXQgdG8gbGVuZ3RoXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0aGlzKS5idWZmZXI7XG4gIH1cbiAgX3NsaWNlKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHRoaXMuX3RpQnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgX2ZpbGwodmFsdWUsIG9mZnNldCwgZW5kLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgYnVmVG9GaWxsV2l0aCA9IFNsb3dCdWZmZXIuZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuICAgICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB2YWxpZCBmaWxsIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBidWZmZXIgbGVuZ3RoID09PSAxLCB3ZSBjYW4ganVzdCBkbyB0aGlzLl90aUJ1ZmZlci5maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCk7XG4gICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl90aUJ1ZmZlci5maWxsKGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyWzBdLCBvZmZzZXQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBtdWx0aXBsZSBieXRlIGZpbGwhXG4gICAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlIChvbiBgdGhpc2AsIG5vdCBvbiB0aGUgYnVmZmVyIHdlIGp1c3QgY3JlYXRlZCk/XG4gICAgICAgIGNvbnN0IGZpbGxDaGFyID0gYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbaSAlIGZpbGxCdWZMZW5ndGhdO1xuICAgICAgICB0aGlzLl90aUJ1ZmZlcltpICsgb2Zmc2V0XSA9IGZpbGxDaGFyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyIChvciBhIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGJ5dGUpIHdlIGNhbiB1c2UgdGlCdWZmZXIuZmlsbCgpO1xuICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfVxuICBnZXRBZGp1c3RlZEluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGhpcywgaW5kZXgpO1xuICB9XG4gIHNldEFkanVzdGVkSW5kZXgoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHNldEFkanVzdGVkSW5kZXgodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgYSBtZXRob2Qgd2Ugc2hvdWxkIGdldCBieSBleHRlbmRpbmcgVWludDhBcnJheSwgc28gcmVhbGx5IHNob3VsZCBvbmx5IGJlIG92ZXJyaWRlbiBvbiBhIFwiU2xvd0J1ZmZlclwiIHRoYXQgd3JhcHMgVGkuQnVmZmVyXG4gIHNldChzcmMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIGNvbnN0IG51bUJ5dGVzID0gc3JjLmxlbmd0aDtcbiAgICAvLyBjaGVjayBzcmMubGVuZ3RoICsgb2Zmc2V0IGRvZXNuJ3QgZ28gYmV5b25kIG91ciBsZW5ndGghXG4gICAgLy8gRklYTUU6IFJlLWVuYWJsZVxuICAgIC8vIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgbnVtQnl0ZXMpO1xuICAgIC8vIGNvcHkgc3JjIHZhbHVlcyBpbnRvIHRoaXMgYnVmZmVyIHN0YXJ0aW5nIGF0IG9mZnNldFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQnl0ZXM7IGkrKykge1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgb2Zmc2V0LCBzcmNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gbWV0aG9kIGZvciBpbnRlcmFjdGluZyB3aXRoIFRpIEFQSXMgdGhhdCByZXF1aXJlIGEgVGkuQnVmZmVyXG4gICAqIEByZXR1cm5zIHtUaS5CdWZmZXJ9IHRoZSB1bmRlcmx5aW5nIFRpLkJ1ZmZlciBiYWNraW5nIHRoaXMgQnVmZmVyIGluc3RhbmNlXG4gICAqL1xuICB0b1RpQnVmZmVyKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gdGhpcy5fdGlCdWZmZXIubGVuZ3RoICYmIHRoaXMuYnl0ZU9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGlCdWZmZXIuY2xvbmUodGhpcy5ieXRlT2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBXcmFwcGluZyBUaS5CdWZmZXI/XG4gIGlmIChidWYuX3RpQnVmZmVyKSB7XG4gICAgaWYgKGluZGV4ID49IGJ1Zi5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYnVmLl90aUJ1ZmZlcltpbmRleCArIGJ1Zi5ieXRlT2Zmc2V0XTtcbiAgfVxuICAvLyBSYXcgVHlwZWRBcnJheS9BcnJheUJ1ZmZlclxuICAvLyBGSVhNRTogZG8gd2UgbmVlZCB0byBhY2NvdW50IGZvciBieXRlT2Zmc2V0IGhlcmU/XG4gIHJldHVybiBidWZbaW5kZXhdO1xufVxuZnVuY3Rpb24gc2V0QWRqdXN0ZWRJbmRleChidWYsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFdyYXBwaW5nIFRpLkJ1ZmZlcj9cbiAgaWYgKGJ1Zi5fdGlCdWZmZXIpIHtcbiAgICBpZiAoaW5kZXggPCBidWYuX3RpQnVmZmVyLmxlbmd0aCkge1xuICAgICAgYnVmLl90aUJ1ZmZlcltpbmRleCArIGJ1Zi5ieXRlT2Zmc2V0XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gUmF3IFR5cGVkQXJyYXkvQXJyYXlCdWZmZXJcbiAgLy8gRklYTUU6IGRvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlP1xuICBidWZbaW5kZXhdID0gdmFsdWU7XG59XG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWwjYnVmZmVyX2J1ZmZlcnNfYW5kX2NoYXJhY3Rlcl9lbmNvZGluZ3NcbmNvbnN0IFRJX0NPREVDX01BUCA9IG5ldyBNYXAoKTtcblRJX0NPREVDX01BUC5zZXQoJ3V0Zi04JywgVGkuQ29kZWMuQ0hBUlNFVF9VVEY4KTtcblRJX0NPREVDX01BUC5zZXQoJ3V0ZjgnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjgpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmLTE2bGUnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmMTZsZScsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1Y3MyJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3Vjcy0yJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ2xhdGluMScsIFRpLkNvZGVjLkNIQVJTRVRfSVNPX0xBVElOXzEpO1xuVElfQ09ERUNfTUFQLnNldCgnYmluYXJ5JywgVGkuQ29kZWMuQ0hBUlNFVF9JU09fTEFUSU5fMSk7XG5USV9DT0RFQ19NQVAuc2V0KCdhc2NpaScsIFRpLkNvZGVjLkNIQVJTRVRfQVNDSUkpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgZGVzaXJlZCBlbmNvZGluZyBuYW1lXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gVGkuQ29kZWMgY29uc3RhbnQgdGhhdCBtYXBzIHRvIHRoZSBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiBnZXRUaUNvZGVjQ2hhcnNldChlbmNvZGluZykge1xuICByZXR1cm4gVElfQ09ERUNfTUFQLmdldChlbmNvZGluZyk7XG59XG5cbi8qKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBCdWZmZXIgdXNlcyBhIFRpLkJ1ZmZlciBpbnRlcm5hbGx5IHRvIGJhY2sgaXQuXG4gKiBUaGlzIGlzIGxpa2xleSBhbiBvcmRlciBvZiBtYWduaXR1ZGUgc2xvd2VyIHRoYW4gdXNpbmcgYSB2YXJpYW50IHRoYXQgZXh0ZW5kcyBVaW50OEFycmF5IVxuICogSSB0aGluayBpZiB3ZSdyZSBub3QgYWxyZWFkeSB3cmFwcGluZyBhIFRpLkJ1ZmZlciwgaXQgbWF5IGJlIGJldHRlciB0byBoYXZlIHR3byBpbXBsZW1lbnRhdGlvbnNcbiAqIGFuZCwgbGlrZSBicm93c2VyaWZ5LCBqdXN0IGV4dGVuZCBVaW50OEFycmF5IGZvciBhbnkgQnVmZmVycyB3ZSBuZWVkIHRvIHJlYWQvd3JpdGUgYSBsb3RcbiAqIGFuZCB0aGVuIGFkZCBhIHNpbXBsZSBjb252ZXJzaW9uIG1ldGhvZCB0byB0dXJuIGl0IGludG8gYSBUaS5CdWZmZXIgd2hlbiBuZWVkZWQuXG4gKlxuICogVGhlIFRpLkJ1ZmZlciBpbXBsIGhhcyB0byBnbyB0aHJvdWdoIHRoZSBiaW5kaW5nIGxheWVyIGZvciByZWFkaW5nL3dyaXRpbmcgZXZlcnkgYnl0ZS5cbiAqIElmIHdlIGFudGljaXBhdGUgdGhlIEJ1ZmZlciBzdGF5aW5nIG9uIHRoZSBKUyBzaWRlLCBJJ20gd2lsbGluZyB0byBiZXQgdGhhdCB0aGUgVWludDhBcnJheVxuICogdGhlIEpTIGVuZ2luZSBwcm92aWRlcyB3b3VsZCBiZSAqd2F5KiBmYXN0ZXIuXG4gKlxuICogQWxzbyBub3RlIHRoYXQgYm90aCBUaS5CdWZmZXIgYW5kIE5vZGUncyBCdWZmZXIgd2VyZSBjcmVhdGVkIGJlZm9yZSB0aGUgSlMgZW5naW5lcyBoYWQgdHlwZWQgYXJyYXlzXG4gKiAoYW5kIFVpbnQ4QXJyYXkgaW4gcGFydGljdWxhcikgYXMgYSBtZWFucyBvZiBlbmNhcHN1bGF0aW5nIGEgYnl0ZSBhcnJheS4gV2Ugc2hvdWxkIGNvbnNpZGVyIGFjY2VwdGluZ1xuICogYSBVaW50OEFycmF5IGluIGFueSBvZiBvdXIgQVBJcyB0aGF0IHRha2UgYSBUaS5CdWZmZXIgYW5kIGV2ZW50dWFsbHkgZGVwcmVjYXRpbmcvcmVtb3ZpbmcgVGkuQnVmZmVyLlxuICovXG5jb25zdCB7XG4gIEFMTF9QUk9QRVJUSUVTOiBBTExfUFJPUEVSVElFUyQxLFxuICBPTkxZX0VOVU1FUkFCTEU6IE9OTFlfRU5VTUVSQUJMRSQxXG59ID0gcHJvcGVydHlGaWx0ZXI7XG5jb25zdCBWQUxJRF9FTkNPRElOR1MgPSBbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2xhdGluMScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZSddO1xuXG4vLyBVc2VkIHRvIGNoZWF0IGZvciByZWFkL3dyaXRlcyBvZiBkb3VibGVzXG5jb25zdCBkb3VibGVBcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkoMSk7XG5jb25zdCB1aW50OERvdWJsZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZG91YmxlQXJyYXkuYnVmZmVyKTtcblxuLy8gVXNlZCB0byBjaGVhdCB0byByZWFkL3dyaXRlIGZsb2F0c1xuY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCB1aW50OEZsb2F0QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdEFycmF5LmJ1ZmZlcik7XG5cbi8vIE5vZGUuanMgZG9lcyBzb21lIHZlcnkgd2VpcmQgc3R1ZmYgaGVyZVxuRmFzdEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCdWZmZXIkMTsgLy8gbmV3IEZhc3RCdWZmZXIoKSBjYWxscyBCdWZmZXIgZnVuY3Rpb24/XG5CdWZmZXIkMS5wcm90b3R5cGUgPSBGYXN0QnVmZmVyLnByb3RvdHlwZTsgLy8gVGhlbiBpdCBoaWphY2tzIEJ1ZmZlcidzIHByb3RvdHlwZSB0byBwb2ludCBhdCBGYXN0QnVmZmVyJ3M/IVxuLy8gRG9lcyB0aGlzIGVmZmVjdGl2ZWx5IG1lYW4gQnVmZmVyIGV4dGVuZHMgVWludDhBcnJheSwgYmVjYXVzZSBGYXN0QnVmZmVyIGRpZD8gVGhpcyBmYWlscyBmb3IgbWVcbi8vIEhvdyB0aGUgaGVsbCBjYW4gd2UgbWFrZSBpdCBoYXBweT8gV2UgcmVhbGx5IHdhbnQgdG8gZXh0ZW5kIFVpbnQ4QXJyYXkgaWYgd2UgY2FuXG4vLyBhZGRCdWZmZXJQcm90b3R5cGVNZXRob2RzKEJ1ZmZlci5wcm90b3R5cGUpOyAvLyBIZXJlJ3Mgd2hlcmUgaXQgaGFuZ3Mgc29tZSBvZiB0aGUgbWV0aG9kc1xuXG5CdWZmZXIkMS5wb29sU2l6ZSA9IDgxOTI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIuXG4gKlxuICogUHJpbWFyaWx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGlzIG1vZHVsZSB0b2dldGhlciB3aXRoIGBuZXdCdWZmZXJgIHRvXG4gKiBjcmVhdGUgYSBuZXcgQnVmZmVyIGluc3RhbmNlIHdyYXBwaW5nIGEgVGkuQnVmZmVyLlxuICpcbiAqIEFsc28gc3VwcG9ydHMgdGhlIGRlcHJlY2F0ZWQgQnVmZmVyKCkgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBzYWZlXG4gKiB0byB1c2Ugb3V0c2lkZSBvZiB0aGlzIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJbXXxCdWZmZXJ8aW50ZWdlcnxzdHJpbmd8VGkuQnVmZmVyfSBhcmcgdGhlIHVuZGVybHlpbmcgZGF0YS9ieXRlc1xuICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gZW5jb2RpbmdPck9mZnNldCBlbmNvZGluZyBvZiB0aGUgc3RyaW5nLCBvciBzdGFydCBvZmZzZXQgb2YgYXJyYXkvYnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciQxKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmFwaU5hbWUgIT09ICdUaS5CdWZmZXInKSB7XG4gICAgc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgXCJzdHJpbmdcIi4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhcmd9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVmZmVyJDEuYWxsb2MoYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlciQxLmZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgLy8gVGhlIHNsb3cgY2FzZSAtIHdlJ3JlIHdyYXBwaW5nIGEgVGkuQnVmZmVyXG4gIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyW118QnVmZmVyfHN0cmluZ30gdmFsdWUgdmFsdWUgd2UncmUgd3JhcHBpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IGVuY29kaW5nT3JPZmZzZXQgZW5jb2Rpbmcgb2YgdGhlIHN0cmluZywgb3Igc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5L2J1ZmZlciB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5CdWZmZXIkMS5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZyb21CdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICAvLyBXZSB3YW50IHRvIGxpbWl0IHRoZSB1c2Ugb2YgU2xvd0J1ZmZlcnMgdG8gb25seSB3aGVuIHdlJ3JlIHdyYXBwaW5nIGEgVGkuQnVmZmVyLCBob3BlZnVsbHkhXG4gICAgaWYgKHZhbHVlLmFwaU5hbWUgJiYgdmFsdWUuYXBpTmFtZSA9PT0gJ1RpLkJ1ZmZlcicpIHtcbiAgICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcXCd2YWx1ZVxcJyBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlOiBcXCdzdHJpbmdcXCcsIFxcJ0FycmF5XFwnLCBcXCdCdWZmZXJcXCcsIFxcJ1RpLkJ1ZmZlclxcJycpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBvYmogQXJyYXlCdWZmZXIgdG8gd3JhcFxuICogQHBhcmFtIHtudW1iZXJ9IFtieXRlT2Zmc2V0PTBdIGJ5dGUgb2Zmc3RlIHRvIGJlZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gbGVuZ3RoIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb252ZXJ0IGJ5dGVPZmZzZXQgdG8gaW50ZWdlclxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0O1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhMZW5ndGggPSBvYmouYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygnb2Zmc2V0Jyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnZlcnQgbGVuZ3RoIHRvIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygnbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlIHRvIHdyYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBjaGFyYWN0ZXIgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgbGV0IGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndXRmOCc7XG4gIGlmICghQnVmZmVyJDEuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICB9XG4gIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIGNvbnN0IGJsb2IgPSBUaS5VdGlscy5iYXNlNjRkZWNvZGUodmFsdWUpO1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihibG9iLnRvQXJyYXlCdWZmZXIoKSk7XG4gIH1cbiAgaWYgKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHJldHVybiBmcm9tQXJyYXkoc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkpO1xuICB9XG4gIC8vIENvbnZlcnQgdGhlIFNsb3dCdWZmZXIgdG8gYSBmYXN0IGJ1ZmZlciBieSBqdXN0IGNvcHlpbmcgYnl0ZXMgcmVjdXJzaXZlbHkgaGVyZVxuICByZXR1cm4gZnJvbUJ1ZmZlcihTbG93QnVmZmVyLmZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyW118VWludDhBcnJheXxhcnJheX0gdmFsdWUgdmFsdWVzIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoKTtcbiAgfVxuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodmFsdWUpO1xufVxuXG4vKipcbiAqIElkZWFsbHkgdGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gd2UncmUgY29weWluZyBhIFNsb3dCdWZmZXIgaW50byBhIG5ldyBGYXN0QnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgYnVmZmVyIHRvIGNvcHlcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGZyb21CdWZmZXIodmFsdWUpIHtcbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKCk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFsdWUuY29weShidWZmZXIsIDAsIDAsIGxlbmd0aCk7XG4gIHJldHVybiBidWZmZXI7XG59XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyJDEsIFVpbnQ4QXJyYXkpOyAvLyBXaGF0IGlzIHRoaXMgZG9pbmc/ISBNYWtpbmcgQnVmZmVyLnByb3RvdHlwZSBwb2ludCBhdCBVaW50OEFycmF5IG5vd1xuXG4vKipcbiAqIDAgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIGJ1ZlxuICogMSBpcyByZXR1cm5lZCBpZiB0YXJnZXQgc2hvdWxkIGNvbWUgYmVmb3JlIGJ1ZiB3aGVuIHNvcnRlZC5cbiAqIC0xIGlzIHJldHVybmVkIGlmIHRhcmdldCBzaG91bGQgY29tZSBhZnRlciBidWYgd2hlbiBzb3J0ZWQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0IEJ1ZmZlciB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldFN0YXJ0PTBdIGluZGV4IHRvIHN0YXJ0IGluIHRhcmdldFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0RW5kPXRhcmdldC5sZW5ndGhdIGluZGV4IHRvIGVuZCBpbiB0YXJnZXRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZVN0YXJ0PTBdIGluZGV4IHRvIHN0YXJ0IGluIHRoaXMgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VFbmQ9dGhpcy5sZW5ndGhdIGluZGV4IHRvIGVuZCBpbiB0aGlzIEJ1ZmZlclxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHRhcmdldEVuZCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICBpZiAoIUJ1ZmZlciQxLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGJ1ZjF9YCk7XG4gIH1cbiAgaWYgKHRhcmdldFN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0YXJnZXRTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHNvdXJjZVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRhcmdldEVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGFyZ2V0RW5kID0gdGFyZ2V0Lmxlbmd0aDtcbiAgfVxuICBpZiAoc291cmNlRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIC8vIEVSUl9PVVRfT0ZfUkFOR0UgaXMgdGhyb3duIGlmIHRhcmdldFN0YXJ0IDwgMCwgc291cmNlU3RhcnQgPCAwLCB0YXJnZXRFbmQgPiB0YXJnZXQuYnl0ZUxlbmd0aCwgb3Igc291cmNlRW5kID4gc291cmNlLmJ5dGVMZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCB8fCBzb3VyY2VTdGFydCA8IDAgfHwgdGFyZ2V0RW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCBzb3VyY2VFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTsgLy8gRklYTUU6IHNldCBcImNvZGVcIiB0byBFUlJfSU5ERVhfT1VUX09GX1JBTkdFXG4gIH1cblxuICAvLyBVc2Ugc2xpY2VzIHRvIG1ha2UgdGhlIGxvb3AgZWFzaWVyXG4gIGNvbnN0IHNvdXJjZSA9IHRoaXMuc2xpY2Uoc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG4gIGNvbnN0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gIGNvbnN0IGRlc3QgPSB0YXJnZXQuc2xpY2UodGFyZ2V0U3RhcnQsIHRhcmdldEVuZCk7XG4gIGNvbnN0IGRlc3RMZW5ndGggPSBkZXN0Lmxlbmd0aDtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oc291cmNlTGVuZ3RoLCBkZXN0TGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZGVzdC5nZXRBZGp1c3RlZEluZGV4KGkpO1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgaWYgKHRhcmdldFZhbHVlICE9PSBzb3VyY2VWYWx1ZSkge1xuICAgICAgLy8gTm8gbWF0Y2ghIFJldHVybiAxIG9yIC0xIGJhc2VkIG9uIHdoYXQgaXMgZ3JlYXRlciFcbiAgICAgIGlmIChzb3VyY2VWYWx1ZSA8IHRhcmdldFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNvcnQgYmFzZWQgb24gbGVuZ3RoIVxuICBpZiAoc291cmNlTGVuZ3RoIDwgZGVzdExlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoc291cmNlTGVuZ3RoID4gZGVzdExlbmd0aCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgZnJvbSB0aGlzIHRvIHRhcmdldFxuICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldCBkZXN0aW5hdGlvbiB3ZSdyZSBjb3B5aW5nIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldFN0YXJ0PTBdIHN0YXJ0IGluZGV4IHRvIGNvcHkgaW50byBpbiBkZXN0aW5hdGlvbiBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZVN0YXJ0PTBdIHN0YXJ0IGluZGV4IHRvIGNvcHkgZnJvbSB3aXRoaW4gYHRoaXNgXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VFbmQ9dGhpcy5sZW5ndGhdIGVuZCBpbmRleCB0byBjb3B5IGZyb20gd2l0aGluIGB0aGlzYFxuICogQHJldHVybnMge2ludGVnZXJ9IG51bWJlciBvZiBieXRlcyBjb3BpZWRcbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICBpZiAodGFyZ2V0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldFN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoc291cmNlU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoc291cmNlRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuICBpZiAoc291cmNlU3RhcnQgPT09IHNvdXJjZUVuZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gVE9ETzogY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG4gIGxldCBsZW5ndGggPSBzb3VyY2VFbmQgLSBzb3VyY2VTdGFydDtcbiAgLy8gQ2FwIGxlbmd0aCB0byByZW1haW5pbmcgYnl0ZXMgaW4gdGFyZ2V0IVxuICBjb25zdCByZW1haW5pbmcgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQ7XG4gIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBzb3VyY2VFbmQgPSBzb3VyY2VTdGFydCArIHJlbWFpbmluZztcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH1cbiAgLy8gRGV0ZXJtaW5lIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd2UnbGwgY29weSwgY29uc3RyYWluIGJ5IHNvdXJjZSBidWZmZXIgbGVuZ3RoIGFzIHdlbGwgYXMgdGFyZ2V0IChhYm92ZSlcbiAgbGV0IG51bUJ5dGVzID0gbGVuZ3RoO1xuICBjb25zdCBzb3VyY2VMZW4gPSB0aGlzLmxlbmd0aCAtIHNvdXJjZVN0YXJ0O1xuICBpZiAobnVtQnl0ZXMgPiBzb3VyY2VMZW4pIHtcbiAgICBudW1CeXRlcyA9IHNvdXJjZUxlbjtcbiAgfVxuXG4gIC8vIFRPRE86IGhhbmRsZSBvdmVybGFwIHdoZW4gdGFyZ2V0ID09PSB0aGlzIVxuICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIHRha2UgdGFyZ2V0IGJ5dGVPZmZzZXQgaW50byBhY2NvdW50IGhlcmU/XG4gIGxldCBzb3VyY2UgPSB0aGlzO1xuICBpZiAoc291cmNlU3RhcnQgIT09IDAgfHwgc291cmNlRW5kIDwgc291cmNlLmxlbmd0aCkge1xuICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyBzb3VyY2VTdGFydCwgbnVtQnl0ZXMpO1xuICB9XG4gIHRhcmdldC5zZXQoc291cmNlLCB0YXJnZXRTdGFydCk7XG4gIHJldHVybiBudW1CeXRlcztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBvZiBbaW5kZXgsIGJ5dGVdIHBhaXJzIGZyb20gdGhlIGNvbnRlbnRzIG9mIGJ1Zi5cbiAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAqL1xuLy8gVE9ETzogSXMgdGhpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgU2xvd0J1ZmZlcj9cbkJ1ZmZlciQxLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBidWZmZXIgPSB0aGlzO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGNvbnN0IGVudHJ5SXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IFtuZXh0SW5kZXgsIGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KG5leHRJbmRleCldLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeUl0ZXJhdG9yO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXJCdWZmZXIpIHtcbiAgaWYgKCFCdWZmZXIkMS5pc0J1ZmZlcihvdGhlckJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gIH1cbiAgaWYgKG90aGVyQnVmZmVyID09PSB0aGlzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlckJ1ZmZlcikgPT09IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVSW50OEFycmF5fGludGVnZXJ9IHZhbHVlIFRoZSB2YWx1ZSB3aXRoIHdoaWNoIHRvIGZpbGwgYGJ1ZmAuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIGZpbGwgYGJ1ZmBcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZF0gV2hlcmUgdG8gc3RvcCBmaWxsaW5nIGJ1ZiAobm90IGluY2x1c2l2ZSkuIGBidWYubGVuZ3RoYCBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGVuY29kaW5nIGZvciBgdmFsdWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7dGhpc31cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgZW5kLCBlbmNvZGluZykge1xuICBjb25zdCBvZmZzZXRUeXBlID0gdHlwZW9mIG9mZnNldDtcbiAgaWYgKG9mZnNldFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gdmFsdWUgc3VwcGxpZWRcbiAgICBvZmZzZXQgPSAwO1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9IGVsc2UgaWYgKG9mZnNldFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgIC8vIHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cbiAgdGhpcy5fZmlsbCh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSk7XG5jb25zdCBUeXBlZEFycmF5UHJvdG9fYnl0ZUxlbmd0aCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKS5nZXQ7XG5jb25zdCBUeXBlZEFycmF5RmlsbCA9IFR5cGVkQXJyYXlQcm90b3R5cGUuZmlsbDtcbkJ1ZmZlciQxLnByb3RvdHlwZS5fZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gT09CIGNoZWNrXG4gICAgY29uc3QgYnl0ZUxlbiA9IFR5cGVkQXJyYXlQcm90b19ieXRlTGVuZ3RoLmNhbGwodGhpcyk7XG4gICAgY29uc3QgZmlsbExlbmd0aCA9IGVuZCAtIG9mZnNldDtcbiAgICBpZiAob2Zmc2V0ID4gZW5kIHx8IGZpbGxMZW5ndGggKyBvZmZzZXQgPiBieXRlTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgY29kZXMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCk7XG4gICAgfVxuICAgIFR5cGVkQXJyYXlGaWxsLmNhbGwodGhpcywgdmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBidWZUb0ZpbGxXaXRoID0gU2xvd0J1ZmZlci5mcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuICAgIGlmIChmaWxsQnVmTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHZhbGlkIGZpbGwgZGF0YScpO1xuICAgIH1cbiAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMSkge1xuICAgICAgVHlwZWRBcnJheUZpbGwuY2FsbCh0aGlzLCBidWZUb0ZpbGxXaXRoLl90aUJ1ZmZlclswXSwgb2Zmc2V0LCBlbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gbXVsdGlwbGUgYnl0ZSBmaWxsIVxuICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIG9mZnNldDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZSAob24gYHRoaXNgLCBub3Qgb24gdGhlIGJ1ZmZlciB3ZSBqdXN0IGNyZWF0ZWQpP1xuICAgICAgY29uc3QgZmlsbENoYXIgPSBidWZUb0ZpbGxXaXRoLl90aUJ1ZmZlcltpICUgZmlsbEJ1Zkxlbmd0aF07XG4gICAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIG9mZnNldCwgZmlsbENoYXIpO1xuICAgIH1cbiAgfVxufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uICh2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfGludGVnZXJ9IHZhbHVlIFdoYXQgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbYnl0ZU9mZnNldD0wXSBXaGVyZSB0byBiZWdpbiBzZWFyY2hpbmcgaW4gYnVmLiBJZiBuZWdhdGl2ZSwgdGhlbiBvZmZzZXQgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBlbmQgb2YgYnVmXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gSWYgdmFsdWUgaXMgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQgZm9yIGluIGJ1ZlxuICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB2YWx1ZSBpbiBidWYsIG9yIC0xIGlmIGJ1ZiBkb2VzIG5vdCBjb250YWluIHZhbHVlLlxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZW1wdHkgYnVmZmVyPyBjYW4ndCBmaW5kIGFueXRoaW5nIVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIGlmIGJ5dGVPZmZzZXQgaXMgdW5kZWZpbmVkLCBtYWtlIGl0IDBcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlmIGl0J3MgYSBzdHJpbmcsIHRoYXQncyBhY3R1YWxseSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfVxuXG4gIC8vIGlmIHdlIGRvbid0IGhhdmUgYW4gZW5jb2RpbmcgeWV0LCB1c2UgdXRmOFxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG4gIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlc1xuICAgIGJ5dGVPZmZzZXQgPSB0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICAvLyBzdGlsbCBuZWdhdGl2ZT8gc3RhcnQgYXQgMFxuICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7IC8vIGNhbid0IGZpbmQgcGFzdCBlbmQgb2YgYnVmZmVyIVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWx1ZSAmPSAweEZGOyAvLyBjbGFtcCB0byAyNTVcbiAgICAvLyBUaGlzIGlzIGEgc2ltcGxlciBjYXNlLCB3ZSBoYXZlIGEgc2luZ2xlIGJ5dGUgd2UgbmVlZCB0byBzZWFyY2ggZm9yXG4gICAgLy8gc28ganVzdCBsb29wIHRocm91Z2ggYW5kIHRyeSB0byBmaW5kIGl0XG4gICAgcmV0dXJuIGluZGV4T2YodGhpcywgdmFsdWUsIGJ5dGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gY29lcmNlIGEgc3RyaW5nIHRvIGEgQnVmZmVyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyB2YWx1ZSBpcyBub3cgYSBCdWZmZXIuLi5cbiAgY29uc3QgbWF0Y2hMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIGlmIChtYXRjaExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTsgLy8gbmV2ZXIgZmluZCBlbXB0eSB2YWx1ZSFcbiAgfVxuXG4gIGlmIChtYXRjaExlbmd0aCA9PT0gMSkge1xuICAgIC8vIHNpbXBsZSBjYXNlLCBtYXRjaCBvbmUgYnl0ZSFcbiAgICByZXR1cm4gaW5kZXhPZih0aGlzLCB2YWx1ZVswXSwgYnl0ZU9mZnNldCk7XG4gIH1cbiAgbGV0IGN1cnJlbnRJbmRleCA9IGJ5dGVPZmZzZXQ7XG4gIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgaWYgKG1hdGNoTGVuZ3RoID4gdGhpc0xlbmd0aCkge1xuICAgIHJldHVybiAtMTsgLy8gY2FuJ3QgbWF0Y2ggaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoaXMgQnVmZmVyIVxuICB9XG5cbiAgLy8gRklYTUU6IENhbiB3ZSByZXdyaXRlIHRoaXMgaW4gYSBsZXNzIGZ1bmt5IHdheT9cbiAgLy8gRklYTUU6IENhbiBzdG9wIGVhcmxpZXIgYmFzZWQgb24gbWF0Y2hMZW5ndGghXG4gIGZpcnN0TWF0Y2g6IHdoaWxlIChjdXJyZW50SW5kZXggPCB0aGlzTGVuZ3RoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAvLyBtYXRjaCBmaXJzdCBieXRlIVxuICAgIGxldCBmaXJzdEJ5dGVNYXRjaCA9IGluZGV4T2YodGhpcywgdmFsdWVbMF0sIGN1cnJlbnRJbmRleCk7XG4gICAgaWYgKGZpcnN0Qnl0ZU1hdGNoID09PSAtMSkge1xuICAgICAgLy8gY291bGRuJ3QgZXZlbiBtYXRjaCB0aGUgdmVyeSBmaXJzdCBieXRlLCBzbyBubyBtYXRjaCBvdmVyYWxsIVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIG9rLCB3ZSBmb3VuZCB0aGUgZmlyc3QgYnl0ZSwgbm93IHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBuZXh0IGNvbnNlY3V0aXZlIGJ5dGVzIG1hdGNoIVxuICAgIGZvciAobGV0IHggPSAxOyB4IDwgbWF0Y2hMZW5ndGg7IHgrKykge1xuICAgICAgaWYgKGZpcnN0Qnl0ZU1hdGNoICsgeCA+PSB0aGlzTGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGZpcnN0Qnl0ZU1hdGNoICsgMTsgLy8gbW92ZSBwYXN0IG91ciBmaXJzdCBtYXRjaFxuICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tmaXJzdEJ5dGVNYXRjaCArIHhdICE9PSB2YWx1ZVt4XSkge1xuICAgICAgICAvLyBkaWRuJ3QgbWF0Y2ghXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGZpcnN0Qnl0ZU1hdGNoICsgMTsgLy8gbW92ZSBwYXN0IG91ciBmaXJzdCBtYXRjaFxuICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaXJzdEJ5dGVNYXRjaDsgLy8gdGhlIHJlc3QgbWF0Y2hlZCwgaHVycmF5IVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGNvbnN0IG15SXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IG5leHRJbmRleCxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXlJdGVyYXRvcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDhcbiAqIEByZXR1cm5zIHtkb3VibGV9IFJlYWRzIGEgNjQtYml0IGRvdWJsZSBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCB3aXRoIHNwZWNpZmllZCBlbmRpYW4gZm9ybWF0XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG5cbiAgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDY0QXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0NjRBcnJheVxuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcbiAgdWludDhEb3VibGVBcnJheVs3XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzZdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs0XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDhcbiAqIEByZXR1cm5zIHtkb3VibGV9IFJlYWRzIGEgNjQtYml0IGRvdWJsZSBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCB3aXRoIHNwZWNpZmllZCBlbmRpYW4gZm9ybWF0XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG5cbiAgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDY0QXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0NjRBcnJheVxuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcbiAgdWludDhEb3VibGVBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzRdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs2XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzddID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAqIEByZXR1cm5zIHtmbG9hdH0gUmVhZHMgYSAzMi1iaXQgZmxvYXQgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG5cbiAgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDMyQXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0MzJBcnJheVxuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcbiAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBmbG9hdEFycmF5WzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNFxuICogQHJldHVybnMge2Zsb2F0fSBSZWFkcyBhIDMyLWJpdCBmbG9hdCBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCB3aXRoIHNwZWNpZmllZCBlbmRpYW4gZm9ybWF0XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcblxuICAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0MzJBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQzMkFycmF5XG4gIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuICB1aW50OEZsb2F0QXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQ4KG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDE2TEUob2Zmc2V0KTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgYW5kIGludGVycHJldHMgdGhlIHJlc3VsdCBhcyBhIHR3bydzIGNvbXBsZW1lbnQgc2lnbmVkIHZhbHVlLiBTdXBwb3J0cyB1cCB0byA0OCBiaXRzIG9mIGFjY3VyYWN5LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCB1bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIGJ5dGVMZW5ndGgpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCBhbmQgaW50ZXJwcmV0cyB0aGUgcmVzdWx0IGFzIGEgdHdvJ3MgY29tcGxlbWVudCBzaWduZWQgdmFsdWUuIFN1cHBvcnRzIHVwIHRvIDQ4IGJpdHMgb2YgYWNjdXJhY3kuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIHVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIHJldHVybiB0aGlzW29mZnNldF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIC8vIGZpcnN0IGJ5dGUgc2hpZnRlZCBhbmQgT1InZCB3aXRoIHNlY29uZCBieXRlXG4gIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIC8vIGZpcnN0IGJ5dGUgT1InZCB3aXRoIHNlY29uZCBieXRlIHNoaWZ0ZWRcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCArICh0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXSk7XG4gIC8vIHJhdGhlciB0aGFuIHNoaWZ0aW5nIGJ5IDw8IDI0LCBtdWx0aXBseSB0aGUgZmlyc3QgYnl0ZSBhbmQgYWRkIGl0IGluIHNvIHdlIGRvbid0IHJldGFpbiB0aGUgXCJzaWduIGJpdFwiXG4gIC8vIChiZWNhdXNlIGJpdC13aXNlIG9wZXJhdG9ycyBhc3N1bWUgYSAzMi1iaXQgbnVtYmVyKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMDtcbiAgLy8gcmF0aGVyIHRoYW4gc2hpZnRpbmcgYnkgPDwgMjQsIG11bHRpcGx5IHRoZSBsYXN0IGJ5dGUgYW5kIGFkZCBpdCBpbiBzbyB3ZSBkb24ndCByZXRhaW4gdGhlIFwic2lnbiBiaXRcIlxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IG11bHRpcGxpZXIgPSAxOyAvLyB3ZSB1c2UgYSBtdWx0aXBsZXIgZm9yIGVhY2ggYnl0ZVxuICAvLyB3ZSdyZSBkb2luZyB0aGUgc2FtZSBsb29wIGFzICNyZWFkVUludExFLCBqdXN0IGJhY2t3YXJkcyFcbiAgZm9yIChsZXQgaSA9IGJ5dGVMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHJlc3VsdCArPSB0aGlzLmdldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSkgKiBtdWx0aXBsaWVyO1xuICAgIG11bHRpcGxpZXIgKj0gMHgxMDA7IC8vIG1vdmUgbXVsdGlwbGllciB0byBuZXh0IGJ5dGVcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGxldCByZXN1bHQgPSAwO1xuICBsZXQgbXVsdGlwbGllciA9IDE7IC8vIHdlIHVzZSBhIG11bHRpcGxlciBmb3IgZWFjaCBieXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpKSAqIG11bHRpcGxpZXI7XG4gICAgbXVsdGlwbGllciAqPSAweDEwMDsgLy8gbW92ZSBtdWx0aXBsaWVyIHRvIG5leHQgYnl0ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kPXRoaXMubGVuZ3RoXSBXaGVyZSB0aGUgbmV3IEJ1ZmZlciB3aWxsIGVuZCAobm90IGluY2x1c2l2ZSkuIERlZmF1bHQ6IGBidWYubGVuZ3RoYC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzTGVuZ3RoICsgc3RhcnQ7XG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgLy8gaWYgdGhpcyBpcyBzdGlsbCBuZWdhdGl2ZSwgdXNlIDAgKHRoYXQgbWF0Y2hlcyBOb2RlKVxuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoICsgZW5kO1xuICB9XG4gIC8vIFNwZWNpZnlpbmcgZW5kIGdyZWF0ZXIgdGhhbiBidWYubGVuZ3RoIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGF0IG9mIGVuZCBlcXVhbCB0byBidWYubGVuZ3RoLlxuICBpZiAoZW5kID4gdGhpc0xlbmd0aCkge1xuICAgIGVuZCA9IHRoaXNMZW5ndGg7XG4gIH1cbiAgLy8gV2hhdCBpZiBlbmQgaXMgbGVzcyB0aGFuIHN0YXJ0P1xuICBsZXQgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChsZW5ndGggPD0gMCkge1xuICAgIGxlbmd0aCA9IDA7IC8vIHJldHVybiBlbXB0eSB2aWV3IG9mIEJ1ZmZlciEgcmV0YWluIGJ5dGUgb2Zmc2V0LCBzZXQgbGVuZ3RoIHRvIDBcbiAgfVxuICAvLyBXcmFwIHRoZSBzYW1lIEFycmF5QnVmZmVyIG9iamVjdCBidXQgc3BlY2lmeSB0aGUgc3RhcnQvZW5kIHRvIFwiY3JvcFwiIHdpdGhcbiAgcmV0dXJuIHRoaXMuX3NsaWNlKHRoaXMuYnl0ZU9mZnNldCArIHN0YXJ0LCBsZW5ndGgpO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS5fc2xpY2UgPSBmdW5jdGlvbiAob2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRoaXMuYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIFdoZXJlIHRoZSBuZXcgYEJ1ZmZlcmAgd2lsbCBzdGFydC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZD10aGlzLmxlbmd0aF0gV2hlcmUgdGhlIG5ldyBCdWZmZXIgd2lsbCBlbmQgKG5vdCBpbmNsdXNpdmUpLiBEZWZhdWx0OiBgYnVmLmxlbmd0aGAuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUuc3ViYXJyYXkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgMTYtYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDIuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIGZpcnN0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgMzItYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICBjb25zdCB0aGlyZCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMik7XG4gICAgY29uc3QgZm91cnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAzKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgZm91cnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIHRoaXJkKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDIsIHNlY29uZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAzLCBmaXJzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gKiBUaHJvd3MgRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUgaWYgYnVmLmxlbmd0aCBpcyBub3QgYSBtdWx0aXBsZSBvZiA4LlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gOCkge1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpO1xuICAgIGNvbnN0IHNlY29uZCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMSk7XG4gICAgY29uc3QgdGhpcmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDIpO1xuICAgIGNvbnN0IGZvdXJ0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMyk7XG4gICAgY29uc3QgZmlmdGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDQpO1xuICAgIGNvbnN0IHNpeHRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyA1KTtcbiAgICBjb25zdCBzZXZlbnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyA2KTtcbiAgICBjb25zdCBlaWdodGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDcpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpLCBlaWdodGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMSwgc2V2ZW50aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAyLCBzaXh0aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAzLCBmaWZ0aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA0LCBmb3VydGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgNSwgdGhpcmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgNiwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDcsIGZpcnN0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICAvLyBUYWtlIGFkdmFudGFnZSBvZiBzbGljZSB3b3JraW5nIG9uIFwiQXJyYXktbGlrZVwiIG9iamVjdHMgKGp1c3QgbGlrZSBgYXJndW1lbnRzYClcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zbGljZSNBcnJheS1saWtlX29iamVjdHNcbiAgICBkYXRhOiBbXS5zbGljZS5jYWxsKHRoaXMpXG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gVGhlIGJ5dGUgb2Zmc2V0IHRvIHN0YXJ0IGRlY29kaW5nIGF0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFRoZSBieXRlIG9mZnNldCB0byBzdG9wIGRlY29kaW5nIGF0IChub3QgaW5jbHVzaXZlKS4gYGJ1Zi5sZW5ndGhgIGRlZmF1bHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAvLyBmYXN0IGNhc2Ugb2Ygbm8gYXJnc1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLnRvVGlCdWZmZXIoKS50b1N0cmluZygpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICBpZiAoc3RhcnQgPj0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnOyAvLyBzdGFydCBpcyBwYXN0IGVuZCBvZiBidWZmZXIsIHJldHVybiBlbXB0eSBzdHJpbmdcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgdHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoZW5kID4gbGVuZ3RoIHx8IHR5cGVvZiBlbmQgIT09ICdudW1iZXInKSB7XG4gICAgLy8gbm8gZW5kIHNwZWNpZmllZCwgb3IgcGFzdCBlbmQgb2YgYnVmZmVyLCB1c2UgbGVuZ3RoIG9mIGJ1ZmZlclxuICAgIGVuZCA9IGxlbmd0aDtcbiAgfSAvLyBlbHNlIGtlZXAgZW5kIGFzIHBhc3NlZCBpblxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7IC8vIGlmIGVuZCBpcyBiZWZvcmUgc3RhcnQgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICB9XG5cbiAgLy8gSWYgc3RhcnQgIT09IDAgYW5kIGVuZCAhPT0gbGVuZ3RoLCBtYXliZSB3ZSBzaG91bGQgZG8gYSBCdWZmZXIuc3ViYXJyYXkvc2xpY2Ugb3ZlciB0aGUgcmFuZ2UgYW5kIGNhbGwgdG9TdHJpbmcoKSBvbiB0aGF0P1xuICBpZiAoc3RhcnQgIT09IDAgfHwgZW5kICE9PSBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZyk7XG4gIH1cblxuICAvLyBiYXNlIGNhc2UsIHN0YXJ0IGlzIDAsIGVuZCBpcyBsZW5ndGhcbiAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gVGhyb3cgaWYgYmFkIGVuY29kaW5nIVxuICAgIGlmICghQnVmZmVyJDEuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gICAgfVxuICB9XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHRoaXMudG9UaUJ1ZmZlcigpLnRvU3RyaW5nKCk7IC8vIHdlIHJldHVybiB1dGYtOCBieSBkZWZhdWx0IG5hdGl2ZWx5XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIFRpLlV0aWxzLmJhc2U2NGVuY29kZSh0aGlzLnRvVGlCdWZmZXIoKS50b0Jsb2IoKSkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHRoaXMuaGV4U2xpY2UoMCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAoZW5jb2RpbmcgPT09ICdsYXRpbjEnIHx8IGVuY29kaW5nID09PSAnYmluYXJ5Jykge1xuICAgIGxldCBsYXRpbjFTdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlYWNoIG9uZSBpcyBhIFwiYnl0ZVwiXG4gICAgICBsYXRpbjFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldEFkanVzdGVkSW5kZXgoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGF0aW4xU3RyaW5nO1xuICB9XG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIGxldCBhc2NpaSA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHdlIHN0b3JlIGJ5dGVzICg4LWJpdCksIGJ1dCBhc2NpaSBpcyA3LWJpdC4gTm9kZSBcIm1hc2tzXCIgdGhlIGxhc3QgYml0IG9mZiwgc28gbGV0J3MgZG8gdGhlIHNhbWVcbiAgICAgIGFzY2lpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpICYgMHg3Rik7XG4gICAgfVxuICAgIHJldHVybiBhc2NpaTtcbiAgfVxuXG4gIC8vIFVDUzIvVVRGMTZcbiAgcmV0dXJuIHRoaXMudWNzMlNsaWNlKDAsIGxlbmd0aCk7XG59O1xuQnVmZmVyJDEucHJvdG90eXBlLmdldEFkanVzdGVkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXNbaW5kZXhdO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS5zZXRBZGp1c3RlZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICByZXR1cm4gdGhpc1tpbmRleF0gPSB2YWx1ZTtcbn07XG5CdWZmZXIkMS5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBsZXQgaGV4U3RyID0gJyc7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgLy8gZWFjaCBvbmUgaXMgYSBcImJ5dGVcIlxuICAgIGxldCBoZXggPSAodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpICYgMHhmZikudG9TdHJpbmcoMTYpO1xuICAgIGhleCA9IGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgaGV4U3RyICs9IGhleDtcbiAgfVxuICByZXR1cm4gaGV4U3RyO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS51Y3MyU2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBpID0gc3RhcnQ7XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgLy8gdXRmLTE2L3Vjcy0yIGlzIDItYnl0ZXMgcGVyIGNoYXJhY3RlclxuICAgIGNvbnN0IGJ5dGUxID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkrKyk7XG4gICAgY29uc3QgYnl0ZTIgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSsrKTtcbiAgICBjb25zdCBjb2RlX3VuaXQgPSAoYnl0ZTIgPDwgOCkgKyBieXRlMTsgLy8gd2UgbWFzaCB0b2dldGhlciB0aGUgdHdvIGJ5dGVzXG4gICAgb3V0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVfdW5pdCk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG1ldGhvZCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBUaSBBUElzIHRoYXQgcmVxdWlyZSBhIFRpLkJ1ZmZlclxuICogQHJldHVybnMge1RpLkJ1ZmZlcn0gdGhlIHVuZGVybHlpbmcgVGkuQnVmZmVyIGJhY2tpbmcgdGhpcyBCdWZmZXIgaW5zdGFuY2VcbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnRvVGlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHRpQnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICBsZW5ndGg6IHRoaXMubGVuZ3RoXG4gIH0pO1xuICBjb3B5QnVmZmVyKHRoaXMsIHRpQnVmZmVyLCAwLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aUJ1ZmZlcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNyYyBzb3VyY2UgQnVmZmVyIHdlJ3JlIGNvcHlpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5CdWZmZXJ9IGRlc3QgZGVzdGluYXRpb24gVGkuQnVmZmVyIHdlJ3JlIGNvcHlpbmcgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgc3RhcnQgb2Zmc2V0IHdlJ3JlIGNvcHlpbmcgdG8gaW4gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIG51bWJlciBvZiBieXRlcyB0byBjb3B5XG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gYWN0dWFsIG51bWJlciBvZiBieXRlcyBjb3BpZWRcbiAqL1xuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIGRlc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGNvbnN0IGRlc3RMZW5ndGggPSBkZXN0Lmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGVzdEluZGV4ID0gaSArIG9mZnNldDtcbiAgICAvLyBhcmUgd2UgdHJ5aW5nIHRvIHdyaXRlIHBhc3QgZW5kIG9mIGRlc3RpbmF0aW9uPyBPciByZWFkIHBhc3QgZW5kIG9mIHNvdXJjZT8gU3RvcCFcbiAgICBpZiAoZGVzdEluZGV4ID49IGRlc3RMZW5ndGggfHwgaSA+PSBzcmNMZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZXN0W2Rlc3RJbmRleF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBmb3IgYnVmIHZhbHVlcyAoYnl0ZXMpXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbi8vIFRPRE86IE1vdmUgdG8gU2xvd0J1ZmZlcj9cbkJ1ZmZlciQxLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IHRoaXM7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgY29uc3QgbXlJdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobmV4dEluZGV4IDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICB2YWx1ZTogYnVmZmVyLmdldEFkanVzdGVkSW5kZXgobmV4dEluZGV4KSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXlJdGVyYXRvcjtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYnVmZmVyIGlzIHVzZWQgaW4gYSBmb3IuLm9mIGxvb3AuIERlbGVnYXRlcyB0byAjdmFsdWVzKClcbiAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAqL1xuLy8gVE9ETzogTW92ZSB0byBTbG93QnVmZmVyP1xuQnVmZmVyJDEucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlcygpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgc3RyaW5nIHRvIGJ1ZiBhdCBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgaW4gZW5jb2RpbmcuXG4gKiBUaGUgbGVuZ3RoIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBJZiBidWYgZGlkIG5vdCBjb250YWluIGVub3VnaCBzcGFjZSB0b1xuICogZml0IHRoZSBlbnRpcmUgc3RyaW5nLCBvbmx5IHBhcnQgb2Ygc3RyaW5nIHdpbGwgYmUgd3JpdHRlbi4gSG93ZXZlciwgcGFydGlhbGx5IGVuY29kZWRcbiAqIGNoYXJhY3RlcnMgd2lsbCBub3QgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHdyaXRlIHRvIGBidWZgLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZSBzdHJpbmdcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aD1idWYubGVuZ3RoIC0gb2Zmc2V0XSBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIHN0cmluZ1xuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSAwO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2UgY2FwIGBsZW5ndGhgIGF0IHRoZSBsZW5ndGggb2Ygb3VyIGJ1ZmZlclxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG4gIC8vIHNvIHdlIG5lZWQgdG8gY29udmVydCBgcmVtYWluaW5nYCBieXRlcyBvZiBvdXIgc3RyaW5nIGludG8gYSBieXRlIGFycmF5L2J1ZmZlclxuICBjb25zdCBzcmMgPSBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpOyAvLyBGSVhNRTogQ2FuIHdlIGxldCBpdCBrbm93IHRvIG9ubHkgY29udmVydCBgcmVtYWluaW5nYCBieXRlcz9cblxuICAvLyB0aGVuIHN0aWNrIHRoYXQgaW50byBvdXIgYnVmZmVyIHN0YXJ0aW5nIGF0IGBvZmZzZXRgIVxuICByZXR1cm4gc3JjLmNvcHkodGhpcywgb2Zmc2V0LCAwLCBsZW5ndGgpO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgZmxvYXRBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgZmxvYXRBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzFdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMTI4LCAxMjcpO1xuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIC8vIGp1c3Qgd3JpdGUgaXQgbm9ybWFsbHlcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29udmVydCBmcm9tIHNpZ25lZCB0byAyJ3MgY29tcGxlbWVudCBiaXRzXG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgMHhGRiArIHZhbHVlICsgMSk7IC8vIG1heCB2YWx1ZSwgcGx1cyB0aGUgbmVnYXRpdmUgbnVtYmVyLCBhZGQgb25lXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgMTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgPj4+IDgpOyAvLyBqdXN0IHNoaWZ0IG92ZXIgYSBieXRlXG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSAmIDB4RkYpOyAvLyBtYXNrIHRvIGZpcnN0IGJ5dGVcblxuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweEZGKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlICYgMHhGRik7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGxldCBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweEZGKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiAxNik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAzLCB2YWx1ZSA+Pj4gMjQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjb25zdCBtaW5NYXhCYXNlID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLW1pbk1heEJhc2UsIG1pbk1heEJhc2UgLSAxKTtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHZhbHVlID0gbWluTWF4QmFzZSAqIDIgKyB2YWx1ZTtcbiAgfVxuICBsZXQgbXVsdGlwbGllciA9IDE7XG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGNvbnN0IG1pbk1heEJhc2UgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtbWluTWF4QmFzZSwgbWluTWF4QmFzZSAtIDEpO1xuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgdmFsdWUgPSBtaW5NYXhCYXNlICogMiArIHZhbHVlO1xuICB9XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCAyNTUpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSk7XG4gIHJldHVybiBvZmZzZXQgKyAxO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhmZik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA0Mjk0OTY3Mjk1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgPj4+IDI0KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiAxNik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gOCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAzLCB2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgbGV0IG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNDI5NDk2NzI5NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhmZik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMywgdmFsdWUgPj4+IDI0KTtcbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDEpO1xuICBsZXQgbXVsdGlwbGllciA9IDE7XG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxKTtcbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgIGxldCBieXRlVmFsdWUgPSB2YWx1ZSAvIG11bHRpcGxpZXIgJiAweEZGO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgIG11bHRpcGxpZXIgKj0gMFgxMDA7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuXG4vLyBUT0RPOiBJbXBsZW1lbnQgcmVtYWluaW5nIGluc3RhbmNlIG1ldGhvZHM6XG4vLyBidWYubGFzdEluZGV4T2YodmFsdWVbLCBieXRlT2Zmc2V0XVssIGVuY29kaW5nXSlcbi8vIGJ1Zi5yZWFkQmlnSW50NjRCRShbb2Zmc2V0XSlcbi8vIGJ1Zi5yZWFkQmlnSW50NjRMRShbb2Zmc2V0XSlcbi8vIGJ1Zi5yZWFkQmlnVUludDY0QkUoW29mZnNldF0pXG4vLyBidWYucmVhZEJpZ1VJbnQ2NExFKFtvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnSW50NjRCRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBidWYud3JpdGVCaWdJbnQ2NExFKHZhbHVlWywgb2Zmc2V0XSlcbi8vIGJ1Zi53cml0ZUJpZ1VJbnQ2NEJFKHZhbHVlWywgb2Zmc2V0XSlcbi8vIGJ1Zi53cml0ZUJpZ1VJbnQ2NExFKHZhbHVlWywgb2Zmc2V0XSlcblxuLy8gRklYTUU6IFdlIG5lZWQgdG8gbWluaW1pemUgdXNpbmcgYSBiYWNraW5nIFRpLkJ1ZmZlciB3aGVuZXZlciBwb3NzaWJsZSwgYmVjYXVzZVxuLy8gZ29pbmcgYmFjayBhbmQgZm9ydGggYWNyb3NzIHRoZSBicmlkZ2UgZm9yIGV2ZXJ5IGJ5dGUgaXMgKnZlcnkqIGV4cGVuc2l2ZVxuLy8gSWRlYWxseSB3ZSBzaG91bGQgaGF2ZSBhIFwiU2xvd0J1ZmZlclwiIHRoYXQgaXMgdXNlZCB3aGVuIHdlIGV4cGxpY2l0bHkgd3JhcCBhIFRpLkJ1ZmZlclxuLy8gU28gdGhhdCB3cml0ZXMgYXJlIHBhc3NlZCB0aHJvdWdoLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGF2b2lkIHVzaW5nIG9uZSBhdCBhbGwgY29zdHNcbi8vIGkuZS4gd2hlbiB3ZSBkbyBCdWZmZXIuY29uY2F0IGFuZCBhcmUgb25seSBkb2luZyByZWFkcyAtIHdoeSBkbyB3ZSBuZWVkIGEgVGkuQnVmZmVyP1xuLy8gQ2FuIHdlIGhhdmUgVGkuQnVmZmVyIHJlYWxseSBqdXN0IHdyYXAgYSBVaW50OEFycmF5IGFuZCBhZGQgaXQncyBvd24gbWV0aG9kcz9cbkJ1ZmZlciQxLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIobGVuZ3RoKTtcbn07XG5CdWZmZXIkMS5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIkMS5hbGxvY1Vuc2FmZShsZW5ndGgpO1xufTtcbkJ1ZmZlciQxLmFsbG9jID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICBsZXQgZmlsbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgbGV0IGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndXRmOCc7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIGlmIChmaWxsICE9PSAwKSB7XG4gICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fEFycmF5QnVmZmVyfFNoYXJlZEFycmF5QnVmZmVyfSBzdHJpbmcgb3JpZ2luYWwgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZW5jb2Rpbmcgd2hvc2UgYnl0ZSBsZW5ndGggd2UgbmVlZCB0byBncmFiXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgbGV0IGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndXRmOCc7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGlmIChCdWZmZXIkMS5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDsgLy8gcmV0dXJuIEJ1ZmZlcidzIGxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDsgLy8gVHlwZWRBcnJheSwgQXJyYXlCdWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyLCBEYXRhVmlld1xuICB9XG5cbiAgbGV0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHN3aXRjaCAoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpO1xuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYxNi1sZSc6XG4gICAgICByZXR1cm4gMiAqIGxlbmd0aDtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIGxlbmd0aCAvIDI7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFN1YnRyYWN0IHVwIHRvIHR3byBwYWRkaW5nIGNoYXJzIGZyb20gZW5kIG9mIHN0cmluZyFcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQobGVuZ3RoIC0gMSkgPT09ICc9Jykge1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQobGVuZ3RoIC0gMSkgPT09ICc9Jykge1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGxlbmd0aCAqIDMgLyA0KTtcbiAgICAvLyBkcm9wIGZyYWN0aW9uYWwgdmFsdWVcbiAgfVxuXG4gIHJldHVybiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpO1xufTtcbkJ1ZmZlciQxLmNvbXBhcmUgPSBmdW5jdGlvbiAoYnVmMSwgYnVmMikge1xuICBpZiAoIUJ1ZmZlciQxLmlzQnVmZmVyKGJ1ZjEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiYnVmMVwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYnVmMX1gKTtcbiAgfVxuICAvLyBUT0RPOiBXcmFwIFVJbnQ4QXJyYXkgYXJncyBpbiBidWZmZXJzP1xuICByZXR1cm4gYnVmMS5jb21wYXJlKGJ1ZjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfFVJbnQ4QXJyYXlbXX0gbGlzdCBsaXN0IG9mIEJ1ZmZlcnMgdG8gY29uY2F0ZW5hdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3RvdGFsTGVuZ3RoXSBUb3RhbCBsZW5ndGggb2YgdGhlIEJ1ZmZlciBpbnN0YW5jZXMgaW4gbGlzdCB3aGVuIGNvbmNhdGVuYXRlZC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbkJ1ZmZlciQxLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXknKTtcbiAgfVxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoKTsgLy8gb25lIGVtcHR5IEJ1ZmZlciFcbiAgfVxuICAvLyBhbGxvY2F0ZSBvbmUgQnVmZmVyIG9mIGB0b3RhbExlbmd0aGA/IENhcCBhdCB0b3RhbExlbmd0aD9cbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgLy8gZ2VuZXJhdGUgdGhlIHRvdGFsIGxlbmd0aCBmcm9tIGVhY2ggYnVmZmVyJ3MgbGVuZ3RoP1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IHBvc2l0aW9uID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICBidWYuY29weShyZXN1bHQsIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBidWYubGVuZ3RoO1xuICAgIGlmIChwb3NpdGlvbiA+PSB0b3RhbExlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBwb3NzaWJsZSBlbmNvZGluZyBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQnVmZmVyJDEuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gVkFMSURfRU5DT0RJTkdTLmluY2x1ZGVzKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iaiBwb3NzaWJsZSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5CdWZmZXIkMS5pc0J1ZmZlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IHVuZGVmaW5lZCAmJiAob2JqIGluc3RhbmNlb2YgQnVmZmVyJDEgfHwgb2JqW2lzQnVmZmVyXSA9PT0gdHJ1ZSk7XG59O1xubGV0IElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG4vLyBPdmVycmlkZSBob3cgYnVmZmVycyBhcmUgcHJlc2VudGVkIGJ5IHV0aWwuaW5zcGVjdCgpLlxuQnVmZmVyJDEucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gZnVuY3Rpb24gKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gIGNvbnN0IG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBjb25zdCBhY3R1YWxNYXggPSBNYXRoLm1pbihtYXgsIHRoaXMubGVuZ3RoKTtcbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBtYXg7XG4gIGxldCBzdHIgPSB0aGlzLnNsaWNlKDAsIGFjdHVhbE1heCkudG9TdHJpbmcoJ2hleCcpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpO1xuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIHN0ciArPSBgIC4uLiAke3JlbWFpbmluZ30gbW9yZSBieXRlJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfVxuICAvLyBJbnNwZWN0IHNwZWNpYWwgcHJvcGVydGllcyBhcyB3ZWxsLCBpZiBwb3NzaWJsZS5cbiAgaWYgKGN0eCkge1xuICAgIGxldCBleHRyYXMgPSBmYWxzZTtcbiAgICBjb25zdCBmaWx0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IEFMTF9QUk9QRVJUSUVTJDEgOiBPTkxZX0VOVU1FUkFCTEUkMTtcbiAgICBjb25zdCBvYmogPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModGhpcywgZmlsdGVyKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICBleHRyYXMgPSB0cnVlO1xuICAgICAgb2JqW2tleV0gPSB0aGlzW2tleV07XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH1cbiAgICAgIC8vICdbT2JqZWN0OiBudWxsIHByb3RvdHlwZV0geycubGVuZ3RoID09PSAyNlxuICAgICAgLy8gVGhpcyBpcyBndWFyZGVkIHdpdGggYSB0ZXN0LlxuICAgICAgc3RyICs9IGluc3BlY3Qob2JqLCB7XG4gICAgICAgIC4uLmN0eCxcbiAgICAgICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICBjb21wYWN0OiB0cnVlXG4gICAgICB9KS5zbGljZSgyNywgLTIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYDwke3RoaXMuY29uc3RydWN0b3IubmFtZX0gJHtzdHJ9PmA7XG59O1xuQnVmZmVyJDEucHJvdG90eXBlLmluc3BlY3QgPSBCdWZmZXIkMS5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF07XG5cbi8vIEhBQ0s6IEFycmF5QnVmZmVyLmlzVmlldyByZXR1cm5zIHRydWUgZm9yIE5vZGUgQnVmZmVyLCBidXQgZmFsc2UgZm9yIHVzLiBVbnRpbCB3ZSBjYW4gZXh0ZW5kIFVpbnQ4QXJyYXksIHdlIG5lZWQgdG8gaGFjayB0aGlzIHNuaWZmaW5nIG1ldGhvZFxuY29uc3QgQXJyYXlCdWZmZXJJc1ZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5BcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAodGhpbmcpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVySXNWaWV3KHRoaW5nKSB8fCB0aGluZyBpbnN0YW5jZW9mIEJ1ZmZlciQxO1xufTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihTbG93QnVmZmVyLnByb3RvdHlwZSwgQnVmZmVyJDEucHJvdG90eXBlKTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihTbG93QnVmZmVyLCBCdWZmZXIkMSk7XG52YXIgQnVmZmVyTW9kdWxlID0ge1xuICBCdWZmZXI6IEJ1ZmZlciQxLFxuICAvLyBUT0RPOiBJbXBsZW1lbnQgdHJhbnNjb2RlKCkhXG4gIHRyYW5zY29kZTogKF9zb3VyY2UsIF9mcm9tRW5jb2RpbmcsIF90b0VuY29kaW5nKSA9PiB7fSxcbiAgSU5TUEVDVF9NQVhfQllURVM6IDUwLFxuICBrTWF4TGVuZ3RoOiAyMTQ3NDgzNjQ3LFxuICBrU3RyaW5nTWF4TGVuZ3RoOiAxMDczNzQxNzk5LFxuICBjb25zdGFudHM6IHtcbiAgICBNQVhfTEVOR1RIOiAyMTQ3NDgzNjQ3LFxuICAgIE1BWF9TVFJJTkdfTEVOR1RIOiAxMDczNzQxNzk5XG4gIH1cbn07XG5cbi8qKlxuICogU2VhcmNoZXMgYSBCdWZmZXIgZm9yIHRoZSBpbmRleCBvZiBhIHNpbmdsZSBieXRlLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBidWZmZXIgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHNpbmdsZUJ5dGUgYnl0ZSB3ZSdyZSBsb29raW5nIGZvclxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgc3RhcnQgb2Zmc2V0IHdlIHNlYXJjaCBhdFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYnVmZmVyLCBzaW5nbGVCeXRlLCBvZmZzZXQpIHtcbiAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KGkpID09PSBzaW5nbGVCeXRlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSBhdm9pZHMgYml0d2lzZSBvcGVyYXRpb25zIGJlY2F1c2UgSlMgYXNzdW1lcyAzMi1iaXQgc2VxdWVuY2VzIGZvciB0aG9zZS5cbiAqIEl0J3MgcG9zc2libGUgd2UgbWF5IGJlIGFibGUgdG8gdXNlIHRoZW0gd2hlbiBieXRlTGVuZ3RoIDwgNCBpZiB0aGF0J3MgZmFzdGVyLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdW5zaWduZWRWYWx1ZSB2YWx1ZSBiZWZvcmUgY29udmVydGluZyBiYWNrIHRvIHNpZ25lZFxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlc1xuICogQHJldHVybnMge2ludGVnZXJ9IHRoZSBzaWduZWQgdmFsdWUgdGhhdCBpcyByZXByZXNlbnRlZCBieSB0aGUgdW5zaWduZWQgdmFsdWUncyBieXRlc1xuICovXG5mdW5jdGlvbiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgY29uc3QgYml0TGVuZ3RoID0gYnl0ZUxlbmd0aCAqIDg7XG4gIGNvbnN0IG1heFBvc2l0aXZlVmFsdWUgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKTtcbiAgaWYgKHVuc2lnbmVkVmFsdWUgPCBtYXhQb3NpdGl2ZVZhbHVlKSB7XG4gICAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG4gIH1cbiAgY29uc3QgbWF4VW5zaWduZWRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gIHVuc2lnbmVkVmFsdWUgLT0gbWF4VW5zaWduZWRWYWx1ZTtcbiAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB1dGYtOCBzdHJpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5mdW5jdGlvbiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpIHtcbiAgLy8gSnVzdCBjb252ZXJ0IHRvIGEgVGkuQnVmZmVyIGFuZCBsZXQgaXQgdGVsbCB1cyB0aGUgbGVuZ3RoXG4gIGNvbnN0IGJ1ZiA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICB0eXBlOiBUaS5Db2RlYy5DSEFSU0VUX1VURjhcbiAgfSk7XG4gIGNvbnN0IGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gIGJ1Zi5yZWxlYXNlKCk7IC8vIHJlbGVhc2UgdGhlIGJ1ZmZlciBzaW5jZSB3ZSBqdXN0IG5lZWRlZCB0aGUgbGVuZ3RoXG4gIHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgUmFuZ2VFcnJvciBpZiBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kc1xuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBidWZmZXIgd2UncmUgb3BlcmF0aW5nIG9uXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCB1c2VyIHN1cHBsaWVkIG9mZnNldFxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBuZWVkZWQgaW4gcmFuZ2VcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0KGJ1ZmZlciwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IGVuZE9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSBieXRlTGVuZ3RoO1xuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBlbmRPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIHZhbHVlIG9mIFwib2Zmc2V0XCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlID49IDAgYW5kIDw9ICR7ZW5kT2Zmc2V0fS4gUmVjZWl2ZWQgJHtvZmZzZXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIHVzZXItc3VwcGxpZWQgdmFsdWVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbWluIG1pbmltdW0gdmFsaWQgdmFsdWVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbWF4IG1heGltdW0gdmFsaWQgdmFsdWVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgdmFsdWUgb2YgXCJ2YWx1ZVwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSA+PSAke21pbn0gYW5kIDw9ICR7bWF4fS4gUmVjZWl2ZWQgJHt2YWx1ZX1gKTtcbiAgfVxufVxubGV0IGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCA9IGZhbHNlO1xubGV0IG5vZGVNb2R1bGVzQ2hlY2tDb3VudGVyID0gMDtcbmNvbnN0IGJ1ZmZlcldhcm5pbmcgPSAnQnVmZmVyKCkgaXMgZGVwcmVjYXRlZCBkdWUgdG8gc2VjdXJpdHkgYW5kIHVzYWJpbGl0eSAnICsgJ2lzc3Vlcy4gUGxlYXNlIHVzZSB0aGUgQnVmZmVyLmFsbG9jKCksICcgKyAnQnVmZmVyLmFsbG9jVW5zYWZlKCksIG9yIEJ1ZmZlci5mcm9tKCkgbWV0aG9kcyBpbnN0ZWFkLic7XG5mdW5jdGlvbiBzaG93RmxhZ2dlZERlcHJlY2F0aW9uKCkge1xuICBpZiAoYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkIHx8ICsrbm9kZU1vZHVsZXNDaGVja0NvdW50ZXIgPiAxMDAwMCB8fCBpc0luc2lkZU5vZGVNb2R1bGVzKCkpIHtcbiAgICAvLyBXZSBkb24ndCBlbWl0IGEgd2FybmluZywgYmVjYXVzZSB3ZSBlaXRoZXI6XG4gICAgLy8gLSBBbHJlYWR5IGRpZCBzbywgb3JcbiAgICAvLyAtIEFscmVhZHkgY2hlY2tlZCB0b28gbWFueSB0aW1lcyB3aGV0aGVyIGEgY2FsbCBpcyBjb21pbmdcbiAgICAvLyAgIGZyb20gbm9kZV9tb2R1bGVzIGFuZCB3YW50IHRvIHN0b3Agc2xvd2luZyBkb3duIHRoaW5ncywgb3JcbiAgICAvLyAtIFRoZSBjb2RlIGlzIGluc2lkZSBgbm9kZV9tb2R1bGVzYC5cbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhidWZmZXJXYXJuaW5nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwMDUnKTtcbiAgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbn1cblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29uc3Qge1xuICBBTExfUFJPUEVSVElFUyxcbiAgT05MWV9FTlVNRVJBQkxFXG59ID0gcHJvcGVydHlGaWx0ZXI7XG5jb25zdCBCb29sZWFuUHJvdG90eXBlID0gQm9vbGVhbi5wcm90b3R5cGU7XG5jb25zdCBEYXRlUHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG5jb25zdCBFcnJvclByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmNvbnN0IE51bWJlclByb3RvdHlwZSA9IE51bWJlci5wcm90b3R5cGU7XG5jb25zdCBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuY29uc3QgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbmNvbnN0IFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG5jb25zdCBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuY29uc3QgU3ltYm9sUHJvdG90eXBlID0gU3ltYm9sLnByb3RvdHlwZTtcbmNvbnN0IGlzSW9zID0gWydpcGFkJywgJ2lwaG9uZSddLmluY2x1ZGVzKFRpLlBsYXRmb3JtLm9zbmFtZSk7XG5jb25zdCB7XG4gIEVSUl9JTlZBTElEX0FSR19UWVBFXG59ID0gY29kZXM7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuY29uc3QgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbmxldCBoZXhTbGljZSA9IHVuY3VycnlUaGlzKEJ1ZmZlck1vZHVsZS5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlKTtcbmNvbnN0IGJ1aWx0SW5PYmplY3RzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnbG9iYWwpLmZpbHRlcihlID0+IC9eKFtBLVpdW2Etel0rKSskLy50ZXN0KGUpKSk7XG5jb25zdCBpbnNwZWN0RGVmYXVsdE9wdGlvbnMgPSBPYmplY3Quc2VhbCh7XG4gIHNob3dIaWRkZW46IGZhbHNlLFxuICBkZXB0aDogMixcbiAgY29sb3JzOiBmYWxzZSxcbiAgY3VzdG9tSW5zcGVjdDogdHJ1ZSxcbiAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgbWF4QXJyYXlMZW5ndGg6IDEwMCxcbiAgYnJlYWtMZW5ndGg6IDgwLFxuICBjb21wYWN0OiAzLFxuICBzb3J0ZWQ6IGZhbHNlLFxuICBnZXR0ZXJzOiBmYWxzZVxufSk7XG5jb25zdCBrT2JqZWN0VHlwZSA9IDA7XG5jb25zdCBrQXJyYXlUeXBlID0gMTtcbmNvbnN0IGtBcnJheUV4dHJhc1R5cGUgPSAyO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vZztcbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSA9IC9bXFx4MDAtXFx4MWZcXHg1Y10vO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGUgPSAvW1xceDAwLVxceDFmXFx4NWNdL2c7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuY29uc3Qga2V5U3RyUmVnRXhwID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC87XG5jb25zdCBudW1iZXJSZWdFeHAgPSAvXigwfFsxLTldWzAtOV0qKSQvO1xuY29uc3Qgbm9kZU1vZHVsZXNSZWdFeHAgPSAvWy9cXFxcXW5vZGVfbW9kdWxlc1svXFxcXF0oLis/KSg/PVsvXFxcXF0pL2c7XG5jb25zdCBrTWluTGluZUxlbmd0aCA9IDE2O1xuXG4vLyBDb25zdGFudHMgdG8gbWFwIHRoZSBpdGVyYXRvciBzdGF0ZS5cbmNvbnN0IGtXZWFrID0gMDtcbmNvbnN0IGtJdGVyYXRvciA9IDE7XG5jb25zdCBrTWFwRW50cmllcyA9IDI7XG5cbi8vIEVzY2FwZWQgc3BlY2lhbCBjaGFyYWN0ZXJzLiBVc2UgZW1wdHkgc3RyaW5ncyB0byBmaWxsIHVwIHVudXNlZCBlbnRyaWVzLlxuLyogZXNsaW50LWRpc2FibGUgcXVvdGVzICovXG5jb25zdCBtZXRhID0gWydcXFxcdTAwMDAnLCAnXFxcXHUwMDAxJywgJ1xcXFx1MDAwMicsICdcXFxcdTAwMDMnLCAnXFxcXHUwMDA0JywgJ1xcXFx1MDAwNScsICdcXFxcdTAwMDYnLCAnXFxcXHUwMDA3JywgJ1xcXFxiJywgJ1xcXFx0JywgJ1xcXFxuJywgJ1xcXFx1MDAwYicsICdcXFxcZicsICdcXFxccicsICdcXFxcdTAwMGUnLCAnXFxcXHUwMDBmJywgJ1xcXFx1MDAxMCcsICdcXFxcdTAwMTEnLCAnXFxcXHUwMDEyJywgJ1xcXFx1MDAxMycsICdcXFxcdTAwMTQnLCAnXFxcXHUwMDE1JywgJ1xcXFx1MDAxNicsICdcXFxcdTAwMTcnLCAnXFxcXHUwMDE4JywgJ1xcXFx1MDAxOScsICdcXFxcdTAwMWEnLCAnXFxcXHUwMDFiJywgJ1xcXFx1MDAxYycsICdcXFxcdTAwMWQnLCAnXFxcXHUwMDFlJywgJ1xcXFx1MDAxZicsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCBcIlxcXFwnXCIsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnXFxcXFxcXFwnXTtcbi8qIGVzbGludC1lbmFibGUgcXVvdGVzICovXG5cbmZ1bmN0aW9uIGdldFVzZXJPcHRpb25zKGN0eCkge1xuICBjb25zdCBvYmogPSB7XG4gICAgc3R5bGl6ZTogY3R4LnN0eWxpemVcbiAgfTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5zcGVjdERlZmF1bHRPcHRpb25zKSkge1xuICAgIG9ialtrZXldID0gY3R4W2tleV07XG4gIH1cbiAgaWYgKGN0eC51c2VyT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm9iaixcbiAgICAuLi5jdHgudXNlck9wdGlvbnNcbiAgfTtcbn1cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYW55IGlucHV0LiBUcmllcyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHZhbHVlYFxuICovXG5mdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBvcHRzKSB7XG4gIC8vIERlZmF1bHQgb3B0aW9uc1xuICBjb25zdCBjdHggPSB7XG4gICAgYnVkZ2V0OiB7fSxcbiAgICBpbmRlbnRhdGlvbkx2bDogMCxcbiAgICBzZWVuOiBbXSxcbiAgICBjdXJyZW50RGVwdGg6IDAsXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IsXG4gICAgc2hvd0hpZGRlbjogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNob3dIaWRkZW4sXG4gICAgZGVwdGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5kZXB0aCxcbiAgICBjb2xvcnM6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jb2xvcnMsXG4gICAgY3VzdG9tSW5zcGVjdDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmN1c3RvbUluc3BlY3QsXG4gICAgc2hvd1Byb3h5OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc2hvd1Byb3h5LFxuICAgIG1heEFycmF5TGVuZ3RoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMubWF4QXJyYXlMZW5ndGgsXG4gICAgYnJlYWtMZW5ndGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5icmVha0xlbmd0aCxcbiAgICBjb21wYWN0OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY29tcGFjdCxcbiAgICBzb3J0ZWQ6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zb3J0ZWQsXG4gICAgZ2V0dGVyczogaW5zcGVjdERlZmF1bHRPcHRpb25zLmdldHRlcnNcbiAgfTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgLy8gTGVnYWN5Li4uXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFNldCB1c2VyLXNwZWNpZmllZCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAgIGNvbnN0IG9wdEtleXMgPSBPYmplY3Qua2V5cyhvcHRzKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIG9wdEtleXMpIHtcbiAgICAgICAgLy8gVE9ETyhCcmlkZ2VBUik6IEZpbmQgYSBzb2x1dGlvbiB3aGF0IHRvIGRvIGFib3V0IHN0eWxpemUuIEVpdGhlciBtYWtlXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gcHVibGljIG9yIGFkZCBhIG5ldyBBUEkgd2l0aCBhIHNpbWlsYXIgb3IgYmV0dGVyXG4gICAgICAgIC8vIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShpbnNwZWN0RGVmYXVsdE9wdGlvbnMsIGtleSkgfHwga2V5ID09PSAnc3R5bGl6ZScpIHtcbiAgICAgICAgICBjdHhba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChjdHgudXNlck9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gcGFzcyB0aHJvdWdoIHRoZSBhY3R1YWwgdXNlciBpbnB1dC5cbiAgICAgICAgICBjdHgudXNlck9wdGlvbnMgPSBvcHRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjdHguY29sb3JzKSB7XG4gICAgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICB9XG4gIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPT09IG51bGwpIHtcbiAgICBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgMCk7XG59XG5pbnNwZWN0LmN1c3RvbSA9IGN1c3RvbUluc3BlY3RTeW1ib2w7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zcGVjdCwgJ2RlZmF1bHRPcHRpb25zJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGluc3BlY3REZWZhdWx0T3B0aW9ucztcbiAgfSxcbiAgc2V0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihpbnNwZWN0RGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59KTtcblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBib2xkOiBbMSwgMjJdLFxuICBpdGFsaWM6IFszLCAyM10sXG4gIHVuZGVybGluZTogWzQsIDI0XSxcbiAgaW52ZXJzZTogWzcsIDI3XSxcbiAgd2hpdGU6IFszNywgMzldLFxuICBncmV5OiBbOTAsIDM5XSxcbiAgYmxhY2s6IFszMCwgMzldLFxuICBibHVlOiBbMzQsIDM5XSxcbiAgY3lhbjogWzM2LCAzOV0sXG4gIGdyZWVuOiBbMzIsIDM5XSxcbiAgbWFnZW50YTogWzM1LCAzOV0sXG4gIHJlZDogWzMxLCAzOV0sXG4gIHllbGxvdzogWzMzLCAzOV1cbn0pO1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIHNwZWNpYWw6ICdjeWFuJyxcbiAgbnVtYmVyOiAneWVsbG93JyxcbiAgYmlnaW50OiAneWVsbG93JyxcbiAgYm9vbGVhbjogJ3llbGxvdycsXG4gIHVuZGVmaW5lZDogJ2dyZXknLFxuICBudWxsOiAnYm9sZCcsXG4gIHN0cmluZzogJ2dyZWVuJyxcbiAgc3ltYm9sOiAnZ3JlZW4nLFxuICBkYXRlOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gIHJlZ2V4cDogJ3JlZCcsXG4gIG1vZHVsZTogJ3VuZGVybGluZSdcbn0pO1xuZnVuY3Rpb24gYWRkUXVvdGVzKHN0ciwgcXVvdGVzKSB7XG4gIGlmIChxdW90ZXMgPT09IC0xKSB7XG4gICAgcmV0dXJuIGBcIiR7c3RyfVwiYDtcbiAgfVxuICBpZiAocXVvdGVzID09PSAtMikge1xuICAgIHJldHVybiBgXFxgJHtzdHJ9XFxgYDtcbiAgfVxuICByZXR1cm4gYCcke3N0cn0nYDtcbn1cbmNvbnN0IGVzY2FwZUZuID0gc3RyID0+IG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xuXG4vLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzLCBzaW5nbGUgcXVvdGVzIGFuZCB0aGUgYmFja3NsYXNoLlxuLy8gVGhpcyBpcyBzaW1pbGFyIHRvIEpTT04gc3RyaW5naWZ5IGVzY2FwaW5nLlxuZnVuY3Rpb24gc3RyRXNjYXBlKHN0cikge1xuICBsZXQgZXNjYXBlVGVzdCA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cDtcbiAgbGV0IGVzY2FwZVJlcGxhY2UgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlcjtcbiAgbGV0IHNpbmdsZVF1b3RlID0gMzk7XG5cbiAgLy8gQ2hlY2sgZm9yIGRvdWJsZSBxdW90ZXMuIElmIG5vdCBwcmVzZW50LCBkbyBub3QgZXNjYXBlIHNpbmdsZSBxdW90ZXMgYW5kXG4gIC8vIGluc3RlYWQgd3JhcCB0aGUgdGV4dCBpbiBkb3VibGUgcXVvdGVzLiBJZiBkb3VibGUgcXVvdGVzIGV4aXN0LCBjaGVjayBmb3JcbiAgLy8gYmFja3RpY2tzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgdXNlIHRob3NlIGFzIGZhbGxiYWNrIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRvdWJsZSBxdW90ZXMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZXNcbiAgaWYgKHN0ci5pbmNsdWRlcyhcIidcIikpIHtcbiAgICAvLyBUaGlzIGludmFsaWRhdGVzIHRoZSBjaGFyQ29kZSBhbmQgdGhlcmVmb3JlIGNhbiBub3QgYmUgbWF0Y2hlZCBmb3JcbiAgICAvLyBhbnltb3JlLlxuICAgIGlmICghc3RyLmluY2x1ZGVzKCdcIicpKSB7XG4gICAgICBzaW5nbGVRdW90ZSA9IC0xO1xuICAgIH0gZWxzZSBpZiAoIXN0ci5pbmNsdWRlcygnYCcpICYmICFzdHIuaW5jbHVkZXMoJyR7JykpIHtcbiAgICAgIHNpbmdsZVF1b3RlID0gLTI7XG4gICAgfVxuICAgIGlmIChzaW5nbGVRdW90ZSAhPT0gMzkpIHtcbiAgICAgIGVzY2FwZVRlc3QgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHBTaW5nbGU7XG4gICAgICBlc2NhcGVSZXBsYWNlID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGU7XG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBtYWdpYyBudW1iZXJzIHRoYXQgd29ya2VkIG91dCBmaW5lIHdoaWxlIGJlbmNobWFya2luZyB3aXRoIHY4IDYuMFxuICBpZiAoc3RyLmxlbmd0aCA8IDUwMDAgJiYgIWVzY2FwZVRlc3QudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGFkZFF1b3RlcyhzdHIsIHNpbmdsZVF1b3RlKTtcbiAgfVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGVzY2FwZUZuKTtcbiAgICByZXR1cm4gYWRkUXVvdGVzKHN0ciwgc2luZ2xlUXVvdGUpO1xuICB9XG4gIGxldCByZXN1bHQgPSAnJztcbiAgbGV0IGxhc3QgPSAwO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAocG9pbnQgPT09IHNpbmdsZVF1b3RlIHx8IHBvaW50ID09PSA5MiB8fCBwb2ludCA8IDMyKSB7XG4gICAgICBpZiAobGFzdCA9PT0gaSkge1xuICAgICAgICByZXN1bHQgKz0gbWV0YVtwb2ludF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gYCR7c3RyLnNsaWNlKGxhc3QsIGkpfSR7bWV0YVtwb2ludF19YDtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBpICsgMTtcbiAgICB9XG4gIH1cbiAgaWYgKGxhc3QgIT09IGxhc3RJbmRleCkge1xuICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdCk7XG4gIH1cbiAgcmV0dXJuIGFkZFF1b3RlcyhyZXN1bHQsIHNpbmdsZVF1b3RlKTtcbn1cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgY29uc3Qgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbG9yID0gaW5zcGVjdC5jb2xvcnNbc3R5bGVdO1xuICAgIHJldHVybiBgXFx1MDAxYlske2NvbG9yWzBdfW0ke3N0cn1cXHUwMDFiWyR7Y29sb3JbMV19bWA7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0cikge1xuICByZXR1cm4gc3RyO1xufVxuXG4vLyBSZXR1cm4gYSBuZXcgZW1wdHkgYXJyYXkgdG8gcHVzaCBpbiB0aGUgcmVzdWx0cyBvZiB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIuXG5mdW5jdGlvbiBnZXRFbXB0eUZvcm1hdEFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUob2JqLCBfY3R4KSB7XG4gIGxldCBmaXJzdFByb3RvO1xuICAvLyBjb25zdCB0bXAgPSBvYmo7XG4gIHdoaWxlIChvYmopIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosICdjb25zdHJ1Y3RvcicpO1xuICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicgJiYgZGVzY3JpcHRvci52YWx1ZS5uYW1lICE9PSAnJykge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWUubmFtZTtcbiAgICB9XG4gICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgaWYgKGZpcnN0UHJvdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlyc3RQcm90byA9IG9iajtcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0UHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qXG4gICBAdG9kbyB0aGlzIGNhbGxzIGludG8gbmF0aXZlLCBjYW4gd2UgcmVwbGFjZSB0aGlzIHNvbWVob3c/XG4gIHJldHVybiBgJHtpbnRlcm5hbEdldENvbnN0cnVjdG9yTmFtZSh0bXApfSA8JHtpbnNwZWN0KGZpcnN0UHJvdG8sIHtcbiAgXHQuLi5jdHgsXG4gIFx0Y3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgfSl9PmA7XG4gICovXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmFsbGJhY2spIHtcbiAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgIHJldHVybiBgWyR7ZmFsbGJhY2t9OiBudWxsIHByb3RvdHlwZV0gWyR7dGFnfV0gYDtcbiAgICB9XG4gICAgcmV0dXJuIGBbJHtmYWxsYmFja306IG51bGwgcHJvdG90eXBlXSBgO1xuICB9XG4gIGlmICh0YWcgIT09ICcnICYmIGNvbnN0cnVjdG9yICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYCR7Y29uc3RydWN0b3J9IFske3RhZ31dIGA7XG4gIH1cbiAgcmV0dXJuIGAke2NvbnN0cnVjdG9yfSBgO1xufVxuXG4vLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG5mdW5jdGlvbiBnZXRLZXlzKHZhbHVlLCBzaG93SGlkZGVuKSB7XG4gIGxldCBrZXlzO1xuICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG4gIGlmIChzaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICBpZiAoc3ltYm9scy5sZW5ndGggIT09IDApIHtcbiAgICAgIGtleXMucHVzaCguLi5zeW1ib2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBtaWdodCB0aHJvdyBpZiBgdmFsdWVgIGlzIGEgTW9kdWxlIE5hbWVzcGFjZSBPYmplY3QgZnJvbSBhblxuICAgIC8vIHVuZXZhbHVhdGVkIG1vZHVsZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gcGVyZm9ybSB0aGUgYWN0dWFsIHR5cGVcbiAgICAvLyBjaGVjayBiZWNhdXNlIGl0J3MgZXhwZW5zaXZlLlxuICAgIC8vIFRPRE8oZGV2c25layk6IHRyYWNrIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWEyNjIvaXNzdWVzLzEyMDlcbiAgICAvLyBhbmQgbW9kaWZ5IHRoaXMgbG9naWMgYXMgbmVlZGVkLlxuICAgIHRyeSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gQGZpeG1lIGhvdyB0byBkdSBpc01vZHVsZU5hbWVzcGFjZU9iamVjdD9cbiAgICAgIC8qXG4gICAgICBhc3NlcnQoaXNOYXRpdmVFcnJvcihlcnIpICYmIGVyci5uYW1lID09PSAnUmVmZXJlbmNlRXJyb3InICYmXG4gICAgICBcdFx0XHQgaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QodmFsdWUpKTtcbiAgICAgICovXG4gICAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc3ltYm9scy5sZW5ndGggIT09IDApIHtcbiAgICAgIGtleXMucHVzaCguLi5zeW1ib2xzLmZpbHRlcihrZXkgPT4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsdWUsIGtleSkpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykge1xuICBsZXQgZmFsbGJhY2sgPSAnJztcbiAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgZmFsbGJhY2sgPSAnT2JqZWN0JztcbiAgfVxuICByZXR1cm4gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKSB7XG4gIGZvciAoY29uc3QgW2NoZWNrLCBjbGF6el0gb2YgW1tpc1VpbnQ4QXJyYXksIFVpbnQ4QXJyYXldLCBbaXNVaW50OENsYW1wZWRBcnJheSwgVWludDhDbGFtcGVkQXJyYXldLCBbaXNVaW50MTZBcnJheSwgVWludDE2QXJyYXldLCBbaXNVaW50MzJBcnJheSwgVWludDMyQXJyYXldLCBbaXNJbnQ4QXJyYXksIEludDhBcnJheV0sIFtpc0ludDE2QXJyYXksIEludDE2QXJyYXldLCBbaXNJbnQzMkFycmF5LCBJbnQzMkFycmF5XSwgW2lzRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXldLCBbaXNGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheV1dKSB7XG4gICAgaWYgKGNoZWNrKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsYXp6O1xuICAgIH1cbiAgfVxufVxubGV0IGxhenlOdWxsUHJvdG90eXBlQ2FjaGU7XG4vLyBDcmVhdGVzIGEgc3ViY2xhc3MgYW5kIG5hbWVcbi8vIHRoZSBjb25zdHJ1Y3RvciBhcyBgJHtjbGF6en0gOiBudWxsIHByb3RvdHlwZWBcbmZ1bmN0aW9uIGNsYXp6V2l0aE51bGxQcm90b3R5cGUoY2xhenosIG5hbWUpIHtcbiAgaWYgKGxhenlOdWxsUHJvdG90eXBlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGxhenlOdWxsUHJvdG90eXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FjaGVkQ2xhc3MgPSBsYXp5TnVsbFByb3RvdHlwZUNhY2hlLmdldChjbGF6eik7XG4gICAgaWYgKGNhY2hlZENsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRDbGFzcztcbiAgICB9XG4gIH1cbiAgY2xhc3MgTnVsbFByb3RvdHlwZSBleHRlbmRzIGNsYXp6IHtcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdWxsUHJvdG90eXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgJ25hbWUnLCB7XG4gICAgdmFsdWU6IGBbJHtuYW1lfTogbnVsbCBwcm90b3R5cGVdYFxuICB9KTtcbiAgbGF6eU51bGxQcm90b3R5cGVDYWNoZS5zZXQoY2xhenosIE51bGxQcm90b3R5cGUpO1xuICByZXR1cm4gTnVsbFByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIG5vUHJvdG90eXBlSXRlcmF0b3IoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGxldCBuZXdWYWw7XG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoU2V0LCAnU2V0Jyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KFNldFByb3RvdHlwZS52YWx1ZXModmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoTWFwLCAnTWFwJyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KE1hcFByb3RvdHlwZS5lbnRyaWVzKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoQXJyYXksICdBcnJheScpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eih2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKTtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoY29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eih2YWx1ZSk7XG4gIH1cbiAgaWYgKG5ld1ZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobmV3VmFsLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh2YWx1ZSkpO1xuICAgIHJldHVybiBmb3JtYXRSYXcoY3R4LCBuZXdWYWwsIHJlY3Vyc2VUaW1lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSkge1xuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllcy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZvcm1hdFByaW1pdGl2ZShjdHguc3R5bGl6ZSwgdmFsdWUsIGN0eCk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxuICAvLyBNZW1vcml6ZSB0aGUgY29udGV4dCBmb3IgY3VzdG9tIGluc3BlY3Rpb24gb24gcHJveGllcy5cbiAgY29uc3QgY29udGV4dCA9IHZhbHVlO1xuICAvKlxuICBAZml4bWUgY2hlY2sgZm9yIHByb3hpZXNcbiAgLy8gQWx3YXlzIGNoZWNrIGZvciBwcm94aWVzIHRvIHByZXZlbnQgc2lkZSBlZmZlY3RzIGFuZCB0byBwcmV2ZW50IHRyaWdnZXJpbmdcbiAgLy8gYW55IHByb3h5IGhhbmRsZXJzLlxuICBjb25zdCBwcm94eSA9IGdldFByb3h5RGV0YWlscyh2YWx1ZSk7XG4gIGlmIChwcm94eSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0aWYgKGN0eC5zaG93UHJveHkpIHtcbiAgXHRcdHJldHVybiBmb3JtYXRQcm94eShjdHgsIHByb3h5LCByZWN1cnNlVGltZXMpO1xuICBcdH1cbiAgXHR2YWx1ZSA9IHByb3h5WzBdO1xuICB9XG4gICovXG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0LlxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QpIHtcbiAgICBjb25zdCBtYXliZUN1c3RvbSA9IHZhbHVlW2N1c3RvbUluc3BlY3RTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDdXN0b20gPT09ICdmdW5jdGlvbidcbiAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXRzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbC5cbiAgICAmJiBtYXliZUN1c3RvbSAhPT0gaW5zcGVjdFxuICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICYmICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGUgcmVjdXJzZVRpbWVzIGFyZSByZXBvcnRlZCBhcyBiZWZvcmUgd2hpbGUgdXNpbmdcbiAgICAgIC8vIGEgY291bnRlciBpbnRlcm5hbGx5LlxuICAgICAgY29uc3QgZGVwdGggPSBjdHguZGVwdGggPT09IG51bGwgPyBudWxsIDogY3R4LmRlcHRoIC0gcmVjdXJzZVRpbWVzO1xuICAgICAgY29uc3QgcmV0ID0gbWF5YmVDdXN0b20uY2FsbChjb250ZXh0LCBkZXB0aCwgZ2V0VXNlck9wdGlvbnMoY3R4KSk7XG4gICAgICAvLyBJZiB0aGUgY3VzdG9tIGluc3BlY3Rpb24gbWV0aG9kIHJldHVybmVkIGB0aGlzYCwgZG9uJ3QgZ28gaW50b1xuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgaWYgKHJldCAhPT0gY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKC9cXG4vZywgYFxcbiR7JyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBVc2luZyBhbiBhcnJheSBoZXJlIGlzIGFjdHVhbGx5IGJldHRlciBmb3IgdGhlIGF2ZXJhZ2UgY2FzZSB0aGFuIHVzaW5nXG4gIC8vIGEgU2V0LiBgc2VlbmAgd2lsbCBvbmx5IGNoZWNrIGZvciB0aGUgZGVwdGggYW5kIHdpbGwgbmV2ZXIgZ3JvdyB0b28gbGFyZ2UuXG4gIGlmIChjdHguc2Vlbi5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICBsZXQgaW5kZXggPSAxO1xuICAgIGlmIChjdHguY2lyY3VsYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmNpcmN1bGFyID0gbmV3IE1hcChbW3ZhbHVlLCBpbmRleF1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLnNpemUgKyAxO1xuICAgICAgICBjdHguY2lyY3VsYXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHguc3R5bGl6ZShgW0NpcmN1bGFyICoke2luZGV4fV1gLCAnc3BlY2lhbCcpO1xuICB9XG4gIHJldHVybiBmb3JtYXRSYXcoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB0eXBlZEFycmF5KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJhdyhjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcbiAgbGV0IGtleXM7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKTtcbiAgbGV0IHRhZyA9IHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gIC8vIE9ubHkgbGlzdCB0aGUgdGFnIGluIGNhc2UgaXQncyBub24tZW51bWVyYWJsZSAvIG5vdCBhbiBvd24gcHJvcGVydHkuXG4gIC8vIE90aGVyd2lzZSB3ZSdkIHByaW50IHRoaXMgdHdpY2UuXG4gIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJyB8fCB0YWcgIT09ICcnICYmIChjdHguc2hvd0hpZGRlbiA/IGhhc093blByb3BlcnR5IDogcHJvcGVydHlJc0VudW1lcmFibGUpKHZhbHVlLCBTeW1ib2wudG9TdHJpbmdUYWcpKSB7XG4gICAgdGFnID0gJyc7XG4gIH1cbiAgbGV0IGJhc2UgPSAnJztcbiAgbGV0IGZvcm1hdHRlciA9IGdldEVtcHR5Rm9ybWF0QXJyYXk7XG4gIGxldCBicmFjZXM7XG4gIGxldCBub0l0ZXJhdG9yID0gdHJ1ZTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBmaWx0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IEFMTF9QUk9QRVJUSUVTIDogT05MWV9FTlVNRVJBQkxFO1xuICBsZXQgZXh0cmFzVHlwZSA9IGtPYmplY3RUeXBlO1xuXG4gIC8vIEl0ZXJhdG9ycyBhbmQgdGhlIHJlc3QgYXJlIHNwbGl0IHRvIHJlZHVjZSBjaGVja3MuXG4gIGlmICh2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgbm9JdGVyYXRvciA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSwgZmlsdGVyKTtcbiAgICAgIC8vIE9ubHkgc2V0IHRoZSBjb25zdHJ1Y3RvciBmb3Igbm9uIG9yZGluYXJ5IChcIkFycmF5IFsuLi5dXCIpIGFycmF5cy5cbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnQXJyYXknKTtcbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXggPT09ICdBcnJheSAnID8gJycgOiBwcmVmaXh9W2AsICddJ107XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHticmFjZXNbMF19XWA7XG4gICAgICB9XG4gICAgICBleHRyYXNUeXBlID0ga0FycmF5RXh0cmFzVHlwZTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEFycmF5O1xuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdTZXQnKTtcbiAgICAgIGlmICh2YWx1ZS5zaXplID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9e31gO1xuICAgICAgfVxuICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH17YCwgJ30nXTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdFNldDtcbiAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnTWFwJyk7XG4gICAgICBpZiAodmFsdWUuc2l6ZSA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fXt9YDtcbiAgICAgIH1cbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9e2AsICd9J107XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRNYXA7XG4gICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlLCBmaWx0ZXIpO1xuICAgICAgY29uc3QgcHJlZml4ID0gY29uc3RydWN0b3IgIT09IG51bGwgPyBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZykgOiBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmluZFR5cGVkQ29uc3RydWN0b3IodmFsdWUpLm5hbWUpO1xuICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH1bYCwgJ10nXTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDAgJiYgIWN0eC5zaG93SGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBgJHticmFjZXNbMF19XWA7XG4gICAgICB9XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRUeXBlZEFycmF5O1xuICAgICAgZXh0cmFzVHlwZSA9IGtBcnJheUV4dHJhc1R5cGU7XG4gICAgfSBlbHNlIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdNYXAnLCB0YWcpO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgfSBlbHNlIGlmIChpc1NldEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdTZXQnLCB0YWcpO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vSXRlcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAobm9JdGVyYXRvcikge1xuICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICBpZiAoY29uc3RydWN0b3IgPT09ICdPYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcmd1bWVudHNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlc1swXSA9ICdbQXJndW1lbnRzXSB7JztcbiAgICAgIH0gZWxzZSBpZiAodGFnICE9PSAnJykge1xuICAgICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ09iamVjdCcpfXtgO1xuICAgICAgfVxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHticmFjZXNbMF19fWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJhc2UgPSBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZWdleHBcbiAgICAgIGNvbnN0IHJlZ0V4cCA9IGNvbnN0cnVjdG9yICE9PSBudWxsID8gdmFsdWUgOiBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgIGJhc2UgPSBSZWdFeHBQcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWdFeHApO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdSZWdFeHAnKTtcbiAgICAgIGlmIChwcmVmaXggIT09ICdSZWdFeHAgJykge1xuICAgICAgICBiYXNlID0gYCR7cHJlZml4fSR7YmFzZX1gO1xuICAgICAgfVxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IHJlY3Vyc2VUaW1lcyA+IGN0eC5kZXB0aCAmJiBjdHguZGVwdGggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdyZWdleHAnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICAgICAgYmFzZSA9IE51bWJlci5pc05hTihEYXRlUHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWx1ZSkpID8gRGF0ZVByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA6IERhdGVQcm90b3R5cGUudG9JU09TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0RhdGUnKTtcbiAgICAgIGlmIChwcmVmaXggIT09ICdEYXRlICcpIHtcbiAgICAgICAgYmFzZSA9IGAke3ByZWZpeH0ke2Jhc2V9YDtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgJ2RhdGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICBiYXNlID0gZm9ybWF0RXJyb3IodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzSW9zKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVycm9yUHJvcHMgPSBbJ2xpbmUnLCAnY29sdW1uJywgJ3NvdXJjZVVSTCddO1xuICAgICAgICBpZiAoa2V5cy5ldmVyeShrZXkgPT4gbmF0aXZlRXJyb3JQcm9wcy5pbmNsdWRlcyhrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBBcnJheUJ1ZmZlciBhbmQgU2hhcmVkQXJyYXlCdWZmZXIuXG4gICAgICAvLyBDYW4ndCBkbyB0aGUgc2FtZSBmb3IgRGF0YVZpZXcgYmVjYXVzZSBpdCBoYXMgYSBub24tcHJpbWl0aXZlXG4gICAgICAvLyAuYnVmZmVyIHByb3BlcnR5IHRoYXQgd2UgbmVlZCB0byByZWN1cnNlIGZvci5cbiAgICAgIGNvbnN0IGFycmF5VHlwZSA9IGlzQXJyYXlCdWZmZXIodmFsdWUpID8gJ0FycmF5QnVmZmVyJyA6ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgYXJyYXlUeXBlKTtcbiAgICAgIGlmICh0eXBlZEFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0QXJyYXlCdWZmZXI7XG4gICAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9eyBieXRlTGVuZ3RoOiAke2Zvcm1hdE51bWJlcihjdHguc3R5bGl6ZSwgdmFsdWUuYnl0ZUxlbmd0aCl9IH1gO1xuICAgICAgfVxuICAgICAgYnJhY2VzWzBdID0gYCR7cHJlZml4fXtgO1xuICAgICAga2V5cy51bnNoaWZ0KCdieXRlTGVuZ3RoJyk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGFWaWV3KHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdEYXRhVmlldycpfXtgO1xuICAgICAgLy8gLmJ1ZmZlciBnb2VzIGxhc3QsIGl0J3Mgbm90IGEgcHJpbWl0aXZlIGxpa2UgdGhlIG90aGVycy5cbiAgICAgIGtleXMudW5zaGlmdCgnYnl0ZUxlbmd0aCcsICdieXRlT2Zmc2V0JywgJ2J1ZmZlcicpO1xuICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdQcm9taXNlJyl9e2A7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAoaXNXZWFrU2V0KHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdXZWFrU2V0Jyl9e2A7XG4gICAgICBmb3JtYXR0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IGZvcm1hdFdlYWtTZXQgOiBmb3JtYXRXZWFrQ29sbGVjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzV2Vha01hcCh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnV2Vha01hcCcpfXtgO1xuICAgICAgZm9ybWF0dGVyID0gY3R4LnNob3dIaWRkZW4gPyBmb3JtYXRXZWFrTWFwIDogZm9ybWF0V2Vha0NvbGxlY3Rpb247XG4gICAgICAvKlxuICAgICAgICogQGZpeG1lIGhvdyB0byBkbyBpc01vZHVsZU5hbWVzcGFjZU9iamVjdD9cbiAgICAgIH0gZWxzZSBpZiAoaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QodmFsdWUpKSB7XG4gICAgICBcdGJyYWNlc1swXSA9IGBbJHt0YWd9XSB7YDtcbiAgICAgIFx0Zm9ybWF0dGVyID0gZm9ybWF0TmFtZXNwYWNlT2JqZWN0O1xuICAgICAgKi9cbiAgICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICBiYXNlID0gZ2V0Qm94ZWRCYXNlKHZhbHVlLCBjdHgsIGtleXMsIGNvbnN0cnVjdG9yLCB0YWcpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgaW5wdXQgcHJvdG90eXBlIGdvdCBtYW5pcHVsYXRlZC4gU3BlY2lhbCBoYW5kbGUgdGhlc2UuIFdlIGhhdmUgdG9cbiAgICAgIC8vIHJlYnVpbGQgdGhlIGluZm9ybWF0aW9uIHNvIHdlIGFyZSBhYmxlIHRvIGRpc3BsYXkgZXZlcnl0aGluZy5cbiAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzcGVjaWFsSXRlcmF0b3IgPSBub1Byb3RvdHlwZUl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcyk7XG4gICAgICAgIGlmIChzcGVjaWFsSXRlcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gc3BlY2lhbEl0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNNYXBJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ01hcCcsIHRhZyk7XG4gICAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChpc1NldEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnU2V0JywgdGFnKTtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgICAgIC8vIEhhbmRsZSBvdGhlciByZWd1bGFyIG9iamVjdHMgYWdhaW4uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYCR7Z2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpfXt9YDtcbiAgICAgICAgfVxuICAgICAgICBicmFjZXNbMF0gPSBgJHtnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyl9e2A7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZWN1cnNlVGltZXMgPiBjdHguZGVwdGggJiYgY3R4LmRlcHRoICE9PSBudWxsKSB7XG4gICAgbGV0IGNvbnN0cnVjdG9yTmFtZSA9IGdldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKS5zbGljZSgwLCAtMSk7XG4gICAgaWYgKGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgICBjb25zdHJ1Y3Rvck5hbWUgPSBgWyR7Y29uc3RydWN0b3JOYW1lfV1gO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LnN0eWxpemUoY29uc3RydWN0b3JOYW1lLCAnc3BlY2lhbCcpO1xuICB9XG4gIHJlY3Vyc2VUaW1lcyArPSAxO1xuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcbiAgY3R4LmN1cnJlbnREZXB0aCA9IHJlY3Vyc2VUaW1lcztcbiAgbGV0IG91dHB1dDtcbiAgY29uc3QgaW5kZW50YXRpb25MdmwgPSBjdHguaW5kZW50YXRpb25Mdmw7XG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0dGVyKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5cywgYnJhY2VzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXlzW2ldLCBleHRyYXNUeXBlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykuc2xpY2UoMCwgLTEpO1xuICAgIHJldHVybiBoYW5kbGVNYXhDYWxsU3RhY2tTaXplKGN0eCwgZXJyLCBjb25zdHJ1Y3Rvck5hbWUsIGluZGVudGF0aW9uTHZsKTtcbiAgfVxuICBpZiAoY3R4LmNpcmN1bGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBpbmRleCA9IGN0eC5jaXJjdWxhci5nZXQodmFsdWUpO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2UgPSBjdHguc3R5bGl6ZShgPHJlZiAqJHtpbmRleH0+YCwgJ3NwZWNpYWwnKTtcbiAgICAgIC8vIEFkZCByZWZlcmVuY2UgYWx3YXlzIHRvIHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlKSB7XG4gICAgICAgIGJhc2UgPSBiYXNlID09PSAnJyA/IHJlZmVyZW5jZSA6IGAke3JlZmVyZW5jZX0gJHtiYXNlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmFjZXNbMF0gPSBgJHtyZWZlcmVuY2V9ICR7YnJhY2VzWzBdfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGN0eC5zZWVuLnBvcCgpO1xuICBpZiAoY3R4LnNvcnRlZCkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBjdHguc29ydGVkID09PSB0cnVlID8gdW5kZWZpbmVkIDogY3R4LnNvcnRlZDtcbiAgICBpZiAoZXh0cmFzVHlwZSA9PT0ga09iamVjdFR5cGUpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzb3J0ZWQgPSBvdXRwdXQuc2xpY2Uob3V0cHV0Lmxlbmd0aCAtIGtleXMubGVuZ3RoKS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgb3V0cHV0LnNwbGljZShvdXRwdXQubGVuZ3RoIC0ga2V5cy5sZW5ndGgsIGtleXMubGVuZ3RoLCAuLi5zb3J0ZWQpO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSByZWR1Y2VUb1NpbmdsZVN0cmluZyhjdHgsIG91dHB1dCwgYmFzZSwgYnJhY2VzLCBleHRyYXNUeXBlLCByZWN1cnNlVGltZXMsIHZhbHVlKTtcbiAgY29uc3QgYnVkZ2V0ID0gY3R4LmJ1ZGdldFtjdHguaW5kZW50YXRpb25MdmxdIHx8IDA7XG4gIGNvbnN0IG5ld0xlbmd0aCA9IGJ1ZGdldCArIHJlcy5sZW5ndGg7XG4gIGN0eC5idWRnZXRbY3R4LmluZGVudGF0aW9uTHZsXSA9IG5ld0xlbmd0aDtcbiAgLy8gSWYgYW55IGluZGVudGF0aW9uTHZsIGV4Y2VlZHMgdGhpcyBsaW1pdCwgbGltaXQgZnVydGhlciBpbnNwZWN0aW5nIHRvIHRoZVxuICAvLyBtaW5pbXVtLiBPdGhlcndpc2UgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG0gbWlnaHQgY29udGludWUgaW5zcGVjdGluZyB0aGVcbiAgLy8gb2JqZWN0IGV2ZW4gdGhvdWdoIHRoZSBtYXhpbXVtIHN0cmluZyBzaXplICh+MiAqKiAyOCBvbiAzMiBiaXQgc3lzdGVtcyBhbmRcbiAgLy8gfjIgKiogMzAgb24gNjQgYml0IHN5c3RlbXMpIGV4Y2VlZGVkLiBUaGUgYWN0dWFsIG91dHB1dCBpcyBub3QgbGltaXRlZCBhdFxuICAvLyBleGFjdGx5IDIgKiogMjcgYnV0IGEgYml0IGhpZ2hlci4gVGhpcyBkZXBlbmRzIG9uIHRoZSBvYmplY3Qgc2hhcGUuXG4gIC8vIFRoaXMgbGltaXQgYWxzbyBtYWtlcyBzdXJlIHRoYXQgaHVnZSBvYmplY3RzIGRvbid0IGJsb2NrIHRoZSBldmVudCBsb29wXG4gIC8vIHNpZ25pZmljYW50bHkuXG4gIGlmIChuZXdMZW5ndGggPiAyICoqIDI3KSB7XG4gICAgY3R4LmRlcHRoID0gLTE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yQnJhY2VzKHR5cGUsIHRhZykge1xuICBpZiAodGFnICE9PSBgJHt0eXBlfSBJdGVyYXRvcmApIHtcbiAgICBpZiAodGFnICE9PSAnJykge1xuICAgICAgdGFnICs9ICddIFsnO1xuICAgIH1cbiAgICB0YWcgKz0gYCR7dHlwZX0gSXRlcmF0b3JgO1xuICB9XG4gIHJldHVybiBbYFske3RhZ31dIHtgLCAnfSddO1xufVxuZnVuY3Rpb24gZ2V0Qm94ZWRCYXNlKHZhbHVlLCBjdHgsIGtleXMsIGNvbnN0cnVjdG9yLCB0YWcpIHtcbiAgbGV0IGZuO1xuICBsZXQgdHlwZTtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbHVlKSkge1xuICAgIGZuID0gTnVtYmVyUHJvdG90eXBlO1xuICAgIHR5cGUgPSAnTnVtYmVyJztcbiAgfSBlbHNlIGlmIChpc1N0cmluZ09iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IFN0cmluZ1Byb3RvdHlwZTtcbiAgICB0eXBlID0gJ1N0cmluZyc7XG4gICAgLy8gRm9yIGJveGVkIFN0cmluZ3MsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSAwLW4gaW5kZXhlZCBlbnRyaWVzLFxuICAgIC8vIHNpbmNlIHRoZXkganVzdCBub2lzeSB1cCB0aGUgb3V0cHV0IGFuZCBhcmUgcmVkdW5kYW50XG4gICAgLy8gTWFrZSBib3hlZCBwcmltaXRpdmUgU3RyaW5ncyBsb29rIGxpa2Ugc3VjaFxuICAgIGtleXMuc3BsaWNlKDAsIHZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbHVlKSkge1xuICAgIGZuID0gQm9vbGVhblByb3RvdHlwZTtcbiAgICB0eXBlID0gJ0Jvb2xlYW4nO1xuICB9IGVsc2Uge1xuICAgIGZuID0gU3ltYm9sUHJvdG90eXBlO1xuICAgIHR5cGUgPSAnU3ltYm9sJztcbiAgfVxuICBsZXQgYmFzZSA9IGBbJHt0eXBlfWA7XG4gIGlmICh0eXBlICE9PSBjb25zdHJ1Y3Rvcikge1xuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgYmFzZSArPSAnIChudWxsIHByb3RvdHlwZSknO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlICs9IGAgKCR7Y29uc3RydWN0b3J9KWA7XG4gICAgfVxuICB9XG4gIGJhc2UgKz0gYDogJHtmb3JtYXRQcmltaXRpdmUoc3R5bGl6ZU5vQ29sb3IsIGZuLnZhbHVlT2YodmFsdWUpLCBjdHgpfV1gO1xuICBpZiAodGFnICE9PSAnJyAmJiB0YWcgIT09IGNvbnN0cnVjdG9yKSB7XG4gICAgYmFzZSArPSBgIFske3RhZ31dYDtcbiAgfVxuICBpZiAoa2V5cy5sZW5ndGggIT09IDAgfHwgY3R4LnN0eWxpemUgPT09IHN0eWxpemVOb0NvbG9yKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsIHR5cGUudG9Mb3dlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpIHtcbiAgbGV0IHR5cGUgPSAnRnVuY3Rpb24nO1xuICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB0eXBlID0gYEdlbmVyYXRvciR7dHlwZX1gO1xuICB9XG4gIGlmIChpc0FzeW5jRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdHlwZSA9IGBBc3luYyR7dHlwZX1gO1xuICB9XG4gIGxldCBiYXNlID0gYFske3R5cGV9YDtcbiAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgYmFzZSArPSAnIChudWxsIHByb3RvdHlwZSknO1xuICB9XG4gIGlmICh2YWx1ZS5uYW1lID09PSAnJykge1xuICAgIGJhc2UgKz0gJyAoYW5vbnltb3VzKSc7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSArPSBgOiAke3ZhbHVlLm5hbWV9YDtcbiAgfVxuICBiYXNlICs9ICddJztcbiAgaWYgKGNvbnN0cnVjdG9yICE9PSB0eXBlICYmIGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgYmFzZSArPSBgICR7Y29uc3RydWN0b3J9YDtcbiAgfVxuICBpZiAodGFnICE9PSAnJyAmJiBjb25zdHJ1Y3RvciAhPT0gdGFnKSB7XG4gICAgYmFzZSArPSBgIFske3RhZ31dYDtcbiAgfVxuICByZXR1cm4gYmFzZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVyciwgY29uc3RydWN0b3IsIHRhZywgY3R4KSB7XG4gIGxldCBzdGFjayA9IGVyci5zdGFjayB8fCBFcnJvclByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycik7XG4gIC8vIHRyeSB0byBub3JtYWxpemUgSmF2YVNjcmlwdENvcmUgc3RhY2sgdG8gbWF0Y2ggdjhcbiAgaWYgKGlzSW9zKSB7XG4gICAgY29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgc3RhY2sgPSBgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2sgKz0gbGluZXMubWFwKHN0YWNrTGluZSA9PiB7XG4gICAgICAgIGNvbnN0IGF0U3ltYm9sSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignQCcpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzdGFja0xpbmUuc2xpY2UoYXRTeW1ib2xJbmRleCArIDEpO1xuICAgICAgICBjb25zdCBzb3VyY2VQYXR0ZXJuID0gLyguKik6KFxcZCspOihcXGQrKS87XG4gICAgICAgIGxldCBzeW1ib2xOYW1lID0gJ3Vua25vd24nO1xuICAgICAgICBpZiAoYXRTeW1ib2xJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzeW1ib2xOYW1lID0gc3RhY2tMaW5lLnNsaWNlKDAsIGF0U3ltYm9sSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZU1hdGNoID0gc291cmNlLm1hdGNoKHNvdXJjZVBhdHRlcm4pO1xuICAgICAgICBpZiAoc291cmNlTWF0Y2gpIHtcbiAgICAgICAgICBsZXQgZmlsZVBhdGggPSBzb3VyY2VNYXRjaFsxXTtcbiAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gc291cmNlTWF0Y2hbMl07XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gc291cmNlTWF0Y2hbM107XG4gICAgICAgICAgaWYgKGZpbGVQYXRoLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGgucmVwbGFjZShgZmlsZTovLyR7VGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3Rvcnl9YCwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYFxcbiAgICBhdCAke3N5bWJvbE5hbWV9ICgke2ZpbGVQYXRofToke2xpbmVOdW1iZXJ9OiR7Y29sdW1ufSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgXFxuICAgIGF0ICR7c3ltYm9sTmFtZX0gKCR7c291cmNlfSlgO1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG4gIH1cblxuICAvLyBBIHN0YWNrIHRyYWNlIG1heSBjb250YWluIGFyYml0cmFyeSBkYXRhLiBPbmx5IG1hbmlwdWxhdGUgdGhlIG91dHB1dFxuICAvLyBmb3IgXCJyZWd1bGFyIGVycm9yc1wiIChlcnJvcnMgdGhhdCBcImxvb2sgbm9ybWFsXCIpIGZvciBub3cuXG4gIGNvbnN0IG5hbWUgPSBlcnIubmFtZSB8fCAnRXJyb3InO1xuICBsZXQgbGVuID0gbmFtZS5sZW5ndGg7XG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCB8fCBuYW1lLmVuZHNXaXRoKCdFcnJvcicpICYmIHN0YWNrLnN0YXJ0c1dpdGgobmFtZSkgJiYgKHN0YWNrLmxlbmd0aCA9PT0gbGVuIHx8IHN0YWNrW2xlbl0gPT09ICc6JyB8fCBzdGFja1tsZW5dID09PSAnXFxuJykpIHtcbiAgICBsZXQgZmFsbGJhY2sgPSAnRXJyb3InO1xuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBzdGFjay5tYXRjaCgvXihbQS1aXVthLXpfIEEtWjAtOVtcXF0oKS1dKykoPzo6fFxcbiB7NH1hdCkvKSB8fCBzdGFjay5tYXRjaCgvXihbYS16X0EtWjAtOS1dKkVycm9yKSQvKTtcbiAgICAgIGZhbGxiYWNrID0gc3RhcnQgJiYgc3RhcnRbMV0gfHwgJyc7XG4gICAgICBsZW4gPSBmYWxsYmFjay5sZW5ndGg7XG4gICAgICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8ICdFcnJvcic7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjaykuc2xpY2UoMCwgLTEpO1xuICAgIGlmIChuYW1lICE9PSBwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXguaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHN0YWNrID0gYCR7cHJlZml4fTogJHtzdGFja31gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrID0gYCR7cHJlZml4fSR7c3RhY2suc2xpY2UobGVuKX1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFjayA9IGAke3ByZWZpeH0gWyR7bmFtZX1dJHtzdGFjay5zbGljZShsZW4pfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWdub3JlIHRoZSBlcnJvciBtZXNzYWdlIGlmIGl0J3MgY29udGFpbmVkIGluIHRoZSBzdGFjay5cbiAgbGV0IHBvcyA9IGVyci5tZXNzYWdlICYmIHN0YWNrLmluZGV4T2YoZXJyLm1lc3NhZ2UpIHx8IC0xO1xuICBpZiAocG9zICE9PSAtMSkge1xuICAgIHBvcyArPSBlcnIubWVzc2FnZS5sZW5ndGg7XG4gIH1cbiAgLy8gV3JhcCB0aGUgZXJyb3IgaW4gYnJhY2tldHMgaW4gY2FzZSBpdCBoYXMgbm8gc3RhY2sgdHJhY2UuXG4gIGxldCBzdGFja1N0YXJ0ID0gc3RhY2suaW5kZXhPZignXFxuICAgIGF0JywgcG9zKTtcbiAgaWYgKHN0YWNrU3RhcnQgPT09IC0xKSB7XG4gICAgc3RhY2sgPSBgWyR7c3RhY2t9XWA7XG4gIH0gZWxzZSBpZiAoY3R4LmNvbG9ycykge1xuICAgIC8vIEhpZ2hsaWdodCB1c2VybGFuZCBjb2RlIGFuZCBub2RlIG1vZHVsZXMuXG4gICAgbGV0IG5ld1N0YWNrID0gc3RhY2suc2xpY2UoMCwgc3RhY2tTdGFydCk7XG4gICAgY29uc3QgbGluZXMgPSBzdGFjay5zbGljZShzdGFja1N0YXJ0ICsgMSkuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgLy8gVGhpcyBhZGRzIHVuZGVyc2NvcmVzIHRvIGFsbCBub2RlX21vZHVsZXMgdG8gcXVpY2tseSBpZGVudGlmeSB0aGVtLlxuICAgICAgbGV0IG5vZGVNb2R1bGU7XG4gICAgICBuZXdTdGFjayArPSAnXFxuJztcbiAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgd2hpbGUgKG5vZGVNb2R1bGUgPSBub2RlTW9kdWxlc1JlZ0V4cC5leGVjKGxpbmUpKSB7XG4gICAgICAgIC8vICcvbm9kZV9tb2R1bGVzLycubGVuZ3RoID09PSAxNFxuICAgICAgICBuZXdTdGFjayArPSBsaW5lLnNsaWNlKHBvcywgbm9kZU1vZHVsZS5pbmRleCArIDE0KTtcbiAgICAgICAgbmV3U3RhY2sgKz0gY3R4LnN0eWxpemUobm9kZU1vZHVsZVsxXSwgJ21vZHVsZScpO1xuICAgICAgICBwb3MgPSBub2RlTW9kdWxlLmluZGV4ICsgbm9kZU1vZHVsZVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBuZXdTdGFjayArPSBwb3MgPT09IDAgPyBsaW5lIDogbGluZS5zbGljZShwb3MpO1xuICAgIH1cbiAgICBzdGFjayA9IG5ld1N0YWNrO1xuICB9XG4gIC8vIFRoZSBtZXNzYWdlIGFuZCB0aGUgc3RhY2sgaGF2ZSB0byBiZSBpbmRlbnRlZCBhcyB3ZWxsIVxuICBpZiAoY3R4LmluZGVudGF0aW9uTHZsICE9PSAwKSB7XG4gICAgY29uc3QgaW5kZW50YXRpb24gPSAnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCk7XG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9cXG4vZywgYFxcbiR7aW5kZW50YXRpb259YCk7XG4gIH1cbiAgcmV0dXJuIHN0YWNrO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvbWlzZShjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBwcm9taXNlIGRldGFpbHMgd2hpY2ggd2UgY2FuJ3QgZG9cbiAgcmV0dXJuIFtjdHguc3R5bGl6ZSgnPHVua25vd24+JywgJ3NwZWNpYWwnKV07XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleSwgdHlwZSkge1xuICBsZXQgbmFtZSwgc3RyO1xuICBsZXQgZXh0cmEgPSAnICc7XG4gIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHtcbiAgICB2YWx1ZTogdmFsdWVba2V5XSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG4gIGlmIChkZXNjLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkaWZmID0gdHlwZSAhPT0ga09iamVjdFR5cGUgfHwgY3R4LmNvbXBhY3QgIT09IHRydWUgPyAyIDogMztcbiAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gZGlmZjtcbiAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyk7XG4gICAgaWYgKGRpZmYgPT09IDMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGN0eC5jb2xvcnMgPyByZW1vdmVDb2xvcnMoc3RyKS5sZW5ndGggOiBzdHIubGVuZ3RoO1xuICAgICAgaWYgKGN0eC5icmVha0xlbmd0aCA8IGxlbikge1xuICAgICAgICBleHRyYSA9IGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gZGlmZjtcbiAgfSBlbHNlIGlmIChkZXNjLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbGFiZWwgPSBkZXNjLnNldCAhPT0gdW5kZWZpbmVkID8gJ0dldHRlci9TZXR0ZXInIDogJ0dldHRlcic7XG4gICAgY29uc3QgcyA9IGN0eC5zdHlsaXplO1xuICAgIGNvbnN0IHNwID0gJ3NwZWNpYWwnO1xuICAgIGlmIChjdHguZ2V0dGVycyAmJiAoY3R4LmdldHRlcnMgPT09IHRydWUgfHwgY3R4LmdldHRlcnMgPT09ICdnZXQnICYmIGRlc2Muc2V0ID09PSB1bmRlZmluZWQgfHwgY3R4LmdldHRlcnMgPT09ICdzZXQnICYmIGRlc2Muc2V0ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0bXAgPSB2YWx1ZVtrZXldO1xuICAgICAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcbiAgICAgICAgaWYgKHRtcCA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfTpgLCBzcCl9ICR7cygnbnVsbCcsICdudWxsJyl9JHtzKCddJywgc3ApfWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRtcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH1dYCwgc3ApfSAke2Zvcm1hdFZhbHVlKGN0eCwgdG1wLCByZWN1cnNlVGltZXMpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKHMsIHRtcCwgY3R4KTtcbiAgICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH06YCwgc3ApfSAke3ByaW1pdGl2ZX0ke3MoJ10nLCBzcCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYDxJbnNwZWN0aW9uIHRocmV3ICgke2Vyci5tZXNzYWdlfSk+YDtcbiAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9OmAsIHNwKX0gJHttZXNzYWdlfSR7cygnXScsIHNwKX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZShgWyR7bGFiZWx9XWAsIHNwKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVzYy5zZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgfVxuICBpZiAodHlwZSA9PT0ga0FycmF5VHlwZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgY29uc3QgdG1wID0ga2V5LnRvU3RyaW5nKCkucmVwbGFjZShzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciwgZXNjYXBlRm4pO1xuICAgIG5hbWUgPSBgWyR7Y3R4LnN0eWxpemUodG1wLCAnc3ltYm9sJyl9XWA7XG4gIH0gZWxzZSBpZiAoZGVzYy5lbnVtZXJhYmxlID09PSBmYWxzZSkge1xuICAgIG5hbWUgPSBgWyR7a2V5LnJlcGxhY2Uoc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIsIGVzY2FwZUZuKX1dYDtcbiAgfSBlbHNlIGlmIChrZXlTdHJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgbmFtZSA9IGN0eC5zdHlsaXplKGtleSwgJ25hbWUnKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gY3R4LnN0eWxpemUoc3RyRXNjYXBlKGtleSksICdzdHJpbmcnKTtcbiAgfVxuICByZXR1cm4gYCR7bmFtZX06JHtleHRyYX0ke3N0cn1gO1xufVxuZnVuY3Rpb24gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSkge1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICBsZXQgbWF4TGVuZ3RoID0gMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgb3V0cHV0TGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgaWYgKGN0eC5tYXhBcnJheUxlbmd0aCA8IG91dHB1dC5sZW5ndGgpIHtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhlIFwiLi4uIG4gbW9yZSBpdGVtc1wiIHBhcnQgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICBvdXRwdXRMZW5ndGgtLTtcbiAgfVxuICBjb25zdCBzZXBhcmF0b3JTcGFjZSA9IDI7IC8vIEFkZCAxIGZvciB0aGUgc3BhY2UgYW5kIDEgZm9yIHRoZSBzZXBhcmF0b3IuXG4gIGNvbnN0IGRhdGFMZW4gPSBuZXcgQXJyYXkob3V0cHV0TGVuZ3RoKTtcbiAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgYWxsIG91dHB1dCBlbnRyaWVzIGFuZCB0aGUgaW5kaXZpZHVhbCBtYXhcbiAgLy8gZW50cmllcyBsZW5ndGggb2YgYWxsIG91dHB1dCBlbnRyaWVzLiBXZSBoYXZlIHRvIHJlbW92ZSBjb2xvcnMgZmlyc3QsXG4gIC8vIG90aGVyd2lzZSB0aGUgbGVuZ3RoIHdvdWxkIG5vdCBiZSBjYWxjdWxhdGVkIHByb3Blcmx5LlxuICBmb3IgKDsgaSA8IG91dHB1dExlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGVuID0gY3R4LmNvbG9ycyA/IHJlbW92ZUNvbG9ycyhvdXRwdXRbaV0pLmxlbmd0aCA6IG91dHB1dFtpXS5sZW5ndGg7XG4gICAgZGF0YUxlbltpXSA9IGxlbjtcbiAgICB0b3RhbExlbmd0aCArPSBsZW4gKyBzZXBhcmF0b3JTcGFjZTtcbiAgICBpZiAobWF4TGVuZ3RoIDwgbGVuKSB7XG4gICAgICBtYXhMZW5ndGggPSBsZW47XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0d28gdG8gYG1heExlbmd0aGAgYXMgd2UgYWRkIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHBsdXMgYSBjb21tYVxuICAvLyBpbi1iZXR3ZWVuIHR3byBlbnRyaWVzLlxuICBjb25zdCBhY3R1YWxNYXggPSBtYXhMZW5ndGggKyBzZXBhcmF0b3JTcGFjZTtcbiAgLy8gQ2hlY2sgaWYgYXQgbGVhc3QgdGhyZWUgZW50cmllcyBmaXQgbmV4dCB0byBlYWNoIG90aGVyIGFuZCBwcmV2ZW50IGdyb3VwaW5nXG4gIC8vIG9mIGFycmF5cyB0aGF0IGNvbnRhaW5zIGVudHJpZXMgb2YgdmVyeSBkaWZmZXJlbnQgbGVuZ3RoIChpLmUuLCBpZiBhIHNpbmdsZVxuICAvLyBlbnRyeSBpcyBsb25nZXIgdGhhbiAxLzUgb2YgYWxsIG90aGVyIGVudHJpZXMgY29tYmluZWQpLiBPdGhlcndpc2UgdGhlXG4gIC8vIHNwYWNlIGluLWJldHdlZW4gc21hbGwgZW50cmllcyB3b3VsZCBiZSBlbm9ybW91cy5cbiAgaWYgKGFjdHVhbE1heCAqIDMgKyBjdHguaW5kZW50YXRpb25MdmwgPCBjdHguYnJlYWtMZW5ndGggJiYgKHRvdGFsTGVuZ3RoIC8gYWN0dWFsTWF4ID4gNSB8fCBtYXhMZW5ndGggPD0gNikpIHtcbiAgICBjb25zdCBhcHByb3hDaGFySGVpZ2h0cyA9IDIuNTtcbiAgICBjb25zdCBhdmVyYWdlQmlhcyA9IE1hdGguc3FydChhY3R1YWxNYXggLSB0b3RhbExlbmd0aCAvIG91dHB1dC5sZW5ndGgpO1xuICAgIGNvbnN0IGJpYXNlZE1heCA9IE1hdGgubWF4KGFjdHVhbE1heCAtIDMgLSBhdmVyYWdlQmlhcywgMSk7XG4gICAgLy8gRHluYW1pY2FsbHkgY2hlY2sgaG93IG1hbnkgY29sdW1ucyBzZWVtIHBvc3NpYmxlLlxuICAgIGNvbnN0IGNvbHVtbnMgPSBNYXRoLm1pbihcbiAgICAvLyBJZGVhbGx5IGEgc3F1YXJlIHNob3VsZCBiZSBkcmF3bi4gV2UgZXhwZWN0IGEgY2hhcmFjdGVyIHRvIGJlIGFib3V0IDIuNVxuICAgIC8vIHRpbWVzIGFzIGhpZ2ggYXMgd2lkZS4gVGhpcyBpcyB0aGUgYXJlYSBmb3JtdWxhIHRvIGNhbGN1bGF0ZSBhIHNxdWFyZVxuICAgIC8vIHdoaWNoIGNvbnRhaW5zIG4gcmVjdGFuZ2xlcyBvZiBzaXplIGBhY3R1YWxNYXggKiBhcHByb3hDaGFySGVpZ2h0c2AuXG4gICAgLy8gRGl2aWRlIHRoYXQgYnkgYGFjdHVhbE1heGAgdG8gcmVjZWl2ZSB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAvLyBUaGUgYWRkZWQgYmlhcyBpbmNyZWFzZXMgdGhlIGNvbHVtbnMgZm9yIHNob3J0IGVudHJpZXMuXG4gICAgTWF0aC5yb3VuZChNYXRoLnNxcnQoYXBwcm94Q2hhckhlaWdodHMgKiBiaWFzZWRNYXggKiBvdXRwdXRMZW5ndGgpIC8gYmlhc2VkTWF4KSxcbiAgICAvLyBEbyBub3QgZXhjZWVkIHRoZSBicmVha0xlbmd0aC5cbiAgICBNYXRoLmZsb29yKChjdHguYnJlYWtMZW5ndGggLSBjdHguaW5kZW50YXRpb25MdmwpIC8gYWN0dWFsTWF4KSxcbiAgICAvLyBMaW1pdCBhcnJheSBncm91cGluZyBmb3Igc21hbGwgYGNvbXBhY3RgIG1vZGVzIGFzIHRoZSB1c2VyIHJlcXVlc3RlZFxuICAgIC8vIG1pbmltYWwgZ3JvdXBpbmcuXG4gICAgY3R4LmNvbXBhY3QgKiA0LFxuICAgIC8vIExpbWl0IHRoZSBjb2x1bW5zIHRvIGEgbWF4aW11bSBvZiBmaWZ0ZWVuLlxuICAgIDE1KTtcbiAgICAvLyBSZXR1cm4gd2l0aCB0aGUgb3JpZ2luYWwgb3V0cHV0IGlmIG5vIGdyb3VwaW5nIHNob3VsZCBoYXBwZW4uXG4gICAgaWYgKGNvbHVtbnMgPD0gMSkge1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgdG1wID0gW107XG4gICAgY29uc3QgbWF4TGluZUxlbmd0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgICBsZXQgbGluZU1heExlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IG91dHB1dC5sZW5ndGg7IGogKz0gY29sdW1ucykge1xuICAgICAgICBpZiAoZGF0YUxlbltqXSA+IGxpbmVNYXhMZW5ndGgpIHtcbiAgICAgICAgICBsaW5lTWF4TGVuZ3RoID0gZGF0YUxlbltqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGluZU1heExlbmd0aCArPSBzZXBhcmF0b3JTcGFjZTtcbiAgICAgIG1heExpbmVMZW5ndGhbaV0gPSBsaW5lTWF4TGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgb3JkZXIgPSAncGFkU3RhcnQnO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yZGVyID0gJ3BhZEVuZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRWFjaCBpdGVyYXRpb24gY3JlYXRlcyBhIHNpbmdsZSBsaW5lIG9mIGdyb3VwZWQgZW50cmllcy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dExlbmd0aDsgaSArPSBjb2x1bW5zKSB7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lcyBtYXkgY29udGFpbiBsZXNzIGVudHJpZXMgdGhhbiBjb2x1bW5zLlxuICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4oaSArIGNvbHVtbnMsIG91dHB1dExlbmd0aCk7XG4gICAgICBsZXQgc3RyID0gJyc7XG4gICAgICBsZXQgaiA9IGk7XG4gICAgICBmb3IgKDsgaiA8IG1heCAtIDE7IGorKykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgZXh0cmEgY29sb3IgcGFkZGluZyBpbiBjYXNlIGl0J3MgYWN0aXZlLiBUaGlzIGhhcyB0byBiZVxuICAgICAgICAvLyBkb25lIGxpbmUgYnkgbGluZSBhcyBzb21lIGxpbmVzIG1pZ2h0IGNvbnRhaW4gbW9yZSBjb2xvcnMgdGhhblxuICAgICAgICAvLyBvdGhlcnMuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBtYXhMaW5lTGVuZ3RoW2ogLSBpXSArIG91dHB1dFtqXS5sZW5ndGggLSBkYXRhTGVuW2pdO1xuICAgICAgICBzdHIgKz0gYCR7b3V0cHV0W2pdfSwgYFtvcmRlcl0ocGFkZGluZywgJyAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmRlciA9PT0gJ3BhZFN0YXJ0Jykge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gbWF4TGluZUxlbmd0aFtqIC0gaV0gKyBvdXRwdXRbal0ubGVuZ3RoIC0gZGF0YUxlbltqXSAtIHNlcGFyYXRvclNwYWNlO1xuICAgICAgICBzdHIgKz0gb3V0cHV0W2pdLnBhZFN0YXJ0KHBhZGRpbmcsICcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gb3V0cHV0W2pdO1xuICAgICAgfVxuICAgICAgdG1wLnB1c2goc3RyKTtcbiAgICB9XG4gICAgaWYgKGN0eC5tYXhBcnJheUxlbmd0aCA8IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgIHRtcC5wdXNoKG91dHB1dFtvdXRwdXRMZW5ndGhdKTtcbiAgICB9XG4gICAgb3V0cHV0ID0gdG1wO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBoYW5kbGVNYXhDYWxsU3RhY2tTaXplKGN0eCwgZXJyLCBjb25zdHJ1Y3Rvck5hbWUsIGluZGVudGF0aW9uTHZsKSB7XG4gIGlmIChpc1N0YWNrT3ZlcmZsb3dFcnJvcihlcnIpKSB7XG4gICAgY3R4LnNlZW4ucG9wKCk7XG4gICAgY3R4LmluZGVudGF0aW9uTHZsID0gaW5kZW50YXRpb25Mdmw7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGBbJHtjb25zdHJ1Y3Rvck5hbWV9OiBJbnNwZWN0aW9uIGludGVycnVwdGVkICdwcmVtYXR1cmVseS4gTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQuXWAsICdzcGVjaWFsJyk7XG4gIH1cbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGZuLCB2YWx1ZSkge1xuICAvLyBGb3JtYXQgLTAgYXMgJy0wJy4gQ2hlY2tpbmcgYHZhbHVlID09PSAtMGAgd29uJ3QgZGlzdGluZ3Vpc2ggMCBmcm9tIC0wLlxuICByZXR1cm4gZm4oT2JqZWN0LmlzKHZhbHVlLCAtMCkgPyAnLTAnIDogYCR7dmFsdWV9YCwgJ251bWJlcicpO1xufVxuZnVuY3Rpb24gZm9ybWF0QmlnSW50KGZuLCB2YWx1ZSkge1xuICByZXR1cm4gZm4oYCR7dmFsdWV9bmAsICdiaWdpbnQnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShmbiwgdmFsdWUsIGN0eCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSAmJiB2YWx1ZS5sZW5ndGggPiBrTWluTGluZUxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiBjdHguYnJlYWtMZW5ndGggLSBjdHguaW5kZW50YXRpb25MdmwgLSA0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3BsaXQoL1xcbi8pLm1hcChsaW5lID0+IGZuKHN0ckVzY2FwZShsaW5lKSwgJ3N0cmluZycpKS5qb2luKGAgK1xcbiR7JyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwgKyAyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuKHN0ckVzY2FwZSh2YWx1ZSksICdzdHJpbmcnKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIoZm4sIHZhbHVlKTtcbiAgfVxuICAvKlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICBcdHJldHVybiBmb3JtYXRCaWdJbnQoZm4sIHZhbHVlKTtcbiAgfVxuICAqL1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZm4oYCR7dmFsdWV9YCwgJ2Jvb2xlYW4nKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmbigndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICB9XG4gIC8vIGVzNiBzeW1ib2wgcHJpbWl0aXZlXG4gIHJldHVybiBmbihTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdzeW1ib2wnKTtcbn1cblxuLy8gVGhlIGFycmF5IGlzIHNwYXJzZSBhbmQvb3IgaGFzIGV4dHJhIGtleXNcbmZ1bmN0aW9uIGZvcm1hdFNwZWNpYWxBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIG1heExlbmd0aCwgb3V0cHV0LCBpKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIGxldCBpbmRleCA9IGk7XG4gIGZvciAoOyBpIDwga2V5cy5sZW5ndGggJiYgb3V0cHV0Lmxlbmd0aCA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB0bXAgPSAra2V5O1xuICAgIC8vIEFycmF5cyBjYW4gb25seSBoYXZlIHVwIHRvIDJeMzIgLSAxIGVudHJpZXNcbiAgICBpZiAodG1wID4gMiAqKiAzMiAtIDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYCR7aW5kZXh9YCAhPT0ga2V5KSB7XG4gICAgICBpZiAoIW51bWJlclJlZ0V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBlbXB0eUl0ZW1zID0gdG1wIC0gaW5kZXg7XG4gICAgICBjb25zdCBlbmRpbmcgPSBlbXB0eUl0ZW1zID4gMSA/ICdzJyA6ICcnO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGA8JHtlbXB0eUl0ZW1zfSBlbXB0eSBpdGVtJHtlbmRpbmd9PmA7XG4gICAgICBvdXRwdXQucHVzaChjdHguc3R5bGl6ZShtZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuICAgICAgaW5kZXggPSB0bXA7XG4gICAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleSwga0FycmF5VHlwZSkpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgY29uc3QgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gaW5kZXg7XG4gIGlmIChvdXRwdXQubGVuZ3RoICE9PSBtYXhMZW5ndGgpIHtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgY29uc3QgZW5kaW5nID0gcmVtYWluaW5nID4gMSA/ICdzJyA6ICcnO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGA8JHtyZW1haW5pbmd9IGVtcHR5IGl0ZW0ke2VuZGluZ30+YDtcbiAgICAgIG91dHB1dC5wdXNoKGN0eC5zdHlsaXplKG1lc3NhZ2UsICd1bmRlZmluZWQnKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0QXJyYXlCdWZmZXIoY3R4LCB2YWx1ZSkge1xuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gIC8qXG4gIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIGlmIChoZXhTbGljZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0aGV4U2xpY2UgPSB1bmN1cnJ5VGhpcyhyZXF1aXJlKCcuLi8uLi9idWZmZXInKS5kZWZhdWx0LkJ1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UpO1xuICB9XG4gICovXG4gIGxldCBzdHIgPSBoZXhTbGljZShidWZmZXIsIDAsIE1hdGgubWluKGN0eC5tYXhBcnJheUxlbmd0aCwgYnVmZmVyLmxlbmd0aCkpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpO1xuICBjb25zdCByZW1haW5pbmcgPSBidWZmZXIubGVuZ3RoIC0gY3R4Lm1heEFycmF5TGVuZ3RoO1xuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIHN0ciArPSBgIC4uLiAke3JlbWFpbmluZ30gbW9yZSBieXRlJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfVxuICByZXR1cm4gW2Ake2N0eC5zdHlsaXplKCdbVWludDhDb250ZW50c10nLCAnc3BlY2lhbCcpfTogPCR7c3RyfT5gXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCB2YWxMZW4gPSB2YWx1ZS5sZW5ndGg7XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGN0eC5tYXhBcnJheUxlbmd0aCksIHZhbExlbik7XG4gIGNvbnN0IHJlbWFpbmluZyA9IHZhbExlbiAtIGxlbjtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBTcGVjaWFsIGhhbmRsZSBzcGFyc2UgYXJyYXlzLlxuICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsdWUsIGkpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0U3BlY2lhbEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgbGVuLCBvdXRwdXQsIGkpO1xuICAgIH1cbiAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGksIGtBcnJheVR5cGUpKTtcbiAgfVxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWApO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBmb3JtYXRUeXBlZEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdHgubWF4QXJyYXlMZW5ndGgpLCB2YWx1ZS5sZW5ndGgpO1xuICBjb25zdCByZW1haW5pbmcgPSB2YWx1ZS5sZW5ndGggLSBtYXhMZW5ndGg7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICBjb25zdCBlbGVtZW50Rm9ybWF0dGVyID0gdmFsdWUubGVuZ3RoID4gMCAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInID8gZm9ybWF0TnVtYmVyIDogZm9ybWF0QmlnSW50O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0W2ldID0gZWxlbWVudEZvcm1hdHRlcihjdHguc3R5bGl6ZSwgdmFsdWVbaV0pO1xuICB9XG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0W21heExlbmd0aF0gPSBgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gO1xuICB9XG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIC8vIC5idWZmZXIgZ29lcyBsYXN0LCBpdCdzIG5vdCBhIHByaW1pdGl2ZSBsaWtlIHRoZSBvdGhlcnMuXG4gICAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydCWVRFU19QRVJfRUxFTUVOVCcsICdsZW5ndGgnLCAnYnl0ZUxlbmd0aCcsICdieXRlT2Zmc2V0JywgJ2J1ZmZlciddKSB7XG4gICAgICBjb25zdCBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcywgdHJ1ZSk7XG4gICAgICBvdXRwdXQucHVzaChgWyR7a2V5fV06ICR7c3RyfWApO1xuICAgIH1cbiAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0U2V0KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG4gIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgIG91dHB1dC5wdXNoKGZvcm1hdFZhbHVlKGN0eCwgdiwgcmVjdXJzZVRpbWVzKSk7XG4gIH1cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG4gIC8vIFdpdGggYHNob3dIaWRkZW5gLCBgbGVuZ3RoYCB3aWxsIGRpc3BsYXkgYXMgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4gIC8vIGFycmF5cy4gRm9yIGNvbnNpc3RlbmN5J3Mgc2FrZSwgZG8gdGhlIHNhbWUgZm9yIGBzaXplYCwgZXZlbiB0aG91Z2ggdGhpc1xuICAvLyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBvdXRwdXQucHVzaChgW3NpemVdOiAke2N0eC5zdHlsaXplKGAke3ZhbHVlLnNpemV9YCwgJ251bWJlcicpfWApO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBmb3JtYXRNYXAoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUpIHtcbiAgICBvdXRwdXQucHVzaChgJHtmb3JtYXRWYWx1ZShjdHgsIGssIHJlY3Vyc2VUaW1lcyl9ID0+ICR7Zm9ybWF0VmFsdWUoY3R4LCB2LCByZWN1cnNlVGltZXMpfWApO1xuICB9XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICAvLyBTZWUgY29tbWVudCBpbiBmb3JtYXRTZXRcbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgb3V0cHV0LnB1c2goYFtzaXplXTogJHtjdHguc3R5bGl6ZShgJHt2YWx1ZS5zaXplfWAsICdudW1iZXInKX1gKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0U2V0SXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBzdGF0ZSkge1xuICBjb25zdCBtYXhBcnJheUxlbmd0aCA9IE1hdGgubWF4KGN0eC5tYXhBcnJheUxlbmd0aCwgMCk7XG4gIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWluKG1heEFycmF5TGVuZ3RoLCBlbnRyaWVzLmxlbmd0aCk7XG4gIGxldCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbaV0gPSBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbaV0sIHJlY3Vyc2VUaW1lcyk7XG4gIH1cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG4gIGlmIChzdGF0ZSA9PT0ga1dlYWsgJiYgIWN0eC5zb3J0ZWQpIHtcbiAgICAvLyBTb3J0IGFsbCBlbnRyaWVzIHRvIGhhdmUgYSBoYWxmd2F5IHJlbGlhYmxlIG91dHB1dCAoaWYgbW9yZSBlbnRyaWVzIHRoYW5cbiAgICAvLyByZXRyaWV2ZWQgb25lcyBleGlzdCwgd2UgY2FuIG5vdCByZWxpYWJseSByZXR1cm4gdGhlIHNhbWUgb3V0cHV0KSBpZiB0aGVcbiAgICAvLyBvdXRwdXQgaXMgbm90IHNvcnRlZCBhbnl3YXkuXG4gICAgb3V0cHV0ID0gb3V0cHV0LnNvcnQoKTtcbiAgfVxuICBjb25zdCByZW1haW5pbmcgPSBlbnRyaWVzLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0TWFwSXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBzdGF0ZSkge1xuICBjb25zdCBtYXhBcnJheUxlbmd0aCA9IE1hdGgubWF4KGN0eC5tYXhBcnJheUxlbmd0aCwgMCk7XG4gIC8vIEVudHJpZXMgZXhpc3QgYXMgW2tleTEsIHZhbDEsIGtleTIsIHZhbDIsIC4uLl1cbiAgY29uc3QgbGVuID0gZW50cmllcy5sZW5ndGggLyAyO1xuICBjb25zdCByZW1haW5pbmcgPSBsZW4gLSBtYXhBcnJheUxlbmd0aDtcbiAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5taW4obWF4QXJyYXlMZW5ndGgsIGxlbik7XG4gIGxldCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgbGV0IGkgPSAwO1xuICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcbiAgaWYgKHN0YXRlID09PSBrV2Vhaykge1xuICAgIGZvciAoOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvcyA9IGkgKiAyO1xuICAgICAgb3V0cHV0W2ldID0gYCR7Zm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3Bvc10sIHJlY3Vyc2VUaW1lcyl9YCArIGAgPT4gJHtmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zICsgMV0sIHJlY3Vyc2VUaW1lcyl9YDtcbiAgICB9XG4gICAgLy8gU29ydCBhbGwgZW50cmllcyB0byBoYXZlIGEgaGFsZndheSByZWxpYWJsZSBvdXRwdXQgKGlmIG1vcmUgZW50cmllcyB0aGFuXG4gICAgLy8gcmV0cmlldmVkIG9uZXMgZXhpc3QsIHdlIGNhbiBub3QgcmVsaWFibHkgcmV0dXJuIHRoZSBzYW1lIG91dHB1dCkgaWYgdGhlXG4gICAgLy8gb3V0cHV0IGlzIG5vdCBzb3J0ZWQgYW55d2F5LlxuICAgIGlmICghY3R4LnNvcnRlZCkge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnNvcnQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9zID0gaSAqIDI7XG4gICAgICBjb25zdCByZXMgPSBbZm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3Bvc10sIHJlY3Vyc2VUaW1lcyksIGZvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3MgKyAxXSwgcmVjdXJzZVRpbWVzKV07XG4gICAgICBvdXRwdXRbaV0gPSByZWR1Y2VUb1NpbmdsZVN0cmluZyhjdHgsIHJlcywgJycsIFsnWycsICddJ10sIGtBcnJheUV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICB9XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWApO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpIHtcbiAgcmV0dXJuIFtjdHguc3R5bGl6ZSgnPGl0ZW1zIHVua25vd24+JywgJ3NwZWNpYWwnKV07XG59XG5mdW5jdGlvbiBmb3JtYXRXZWFrU2V0KGN0eCwgX3ZhbHVlLCBfcmVjdXJzZVRpbWVzKSB7XG4gIC8vIE5vZGUgY2FsbHMgaW50byBuYXRpdmUgdG8gZ2V0IGEgcHJldmlldyBvZiBhY3R1YWwgdmFsdWVzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpO1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vha01hcChjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBhIHByZXZpZXcgb2YgYWN0dWFsIHZhbHVlcyB3aGljaCB3ZSBjYW4ndCBkb1xuICByZXR1cm4gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgX2tleXMsIGJyYWNlcykge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGxldCBpc0tleVZhbHVlID0gZmFsc2U7XG4gIGxldCByZXN1bHQgPSB2YWx1ZS5uZXh0KCk7XG4gIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBjdXJyZW50RW50cnkgPSByZXN1bHQudmFsdWU7XG4gICAgZW50cmllcy5wdXNoKGN1cnJlbnRFbnRyeSk7XG4gICAgaWYgKGN1cnJlbnRFbnRyeVswXSAhPT0gY3VycmVudEVudHJ5WzFdKSB7XG4gICAgICBpc0tleVZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdWx0ID0gdmFsdWUubmV4dCgpO1xuICB9XG4gIGlmIChpc0tleVZhbHVlKSB7XG4gICAgLy8gTWFyayBlbnRyeSBpdGVyYXRvcnMgYXMgc3VjaC5cbiAgICBicmFjZXNbMF0gPSBicmFjZXNbMF0ucmVwbGFjZSgvIEl0ZXJhdG9yXSB7JC8sICcgRW50cmllc10geycpO1xuICAgIHJldHVybiBmb3JtYXRNYXBJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIGtNYXBFbnRyaWVzKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0U2V0SXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBrSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCBzdGFydCwgYmFzZSkge1xuICAvLyBFYWNoIGVudHJ5IGlzIHNlcGFyYXRlZCBieSBhdCBsZWFzdCBhIGNvbW1hLiBUaHVzLCB3ZSBzdGFydCB3aXRoIGEgdG90YWxcbiAgLy8gbGVuZ3RoIG9mIGF0IGxlYXN0IGBvdXRwdXQubGVuZ3RoYC4gSW4gYWRkaXRpb24sIHNvbWUgY2FzZXMgaGF2ZSBhXG4gIC8vIHdoaXRlc3BhY2UgaW4tYmV0d2VlbiBlYWNoIG90aGVyIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRvdGFsIGFzIHdlbGwuXG4gIGxldCB0b3RhbExlbmd0aCA9IG91dHB1dC5sZW5ndGggKyBzdGFydDtcbiAgaWYgKHRvdGFsTGVuZ3RoICsgb3V0cHV0Lmxlbmd0aCA+IGN0eC5icmVha0xlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjdHguY29sb3JzKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSByZW1vdmVDb2xvcnMob3V0cHV0W2ldKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IG91dHB1dFtpXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCA+IGN0eC5icmVha0xlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBEbyBub3QgbGluZSB1cCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGxpbmUgaWYgYGJhc2VgIGNvbnRhaW5zIGxpbmUgYnJlYWtzLlxuICByZXR1cm4gYmFzZSA9PT0gJycgfHwgIWJhc2UuaW5jbHVkZXMoJ1xcbicpO1xufVxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSkge1xuICBpZiAoY3R4LmNvbXBhY3QgIT09IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIGN0eC5jb21wYWN0ID09PSAnbnVtYmVyJyAmJiBjdHguY29tcGFjdCA+PSAxKSB7XG4gICAgICAvLyBNZW1vcml6ZSB0aGUgb3JpZ2luYWwgb3V0cHV0IGxlbmd0aC4gSW4gY2FzZSB0aGUgdGhlIG91dHB1dCBpcyBncm91cGVkLFxuICAgICAgLy8gcHJldmVudCBsaW5pbmcgdXAgdGhlIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZS5cbiAgICAgIGNvbnN0IGVudHJpZXMgPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgLy8gR3JvdXAgYXJyYXkgZWxlbWVudHMgdG9nZXRoZXIgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IHNpeFxuICAgICAgLy8gc2VwYXJhdGUgZW50cmllcy5cbiAgICAgIGlmIChleHRyYXNUeXBlID09PSBrQXJyYXlFeHRyYXNUeXBlICYmIGVudHJpZXMgPiA2KSB7XG4gICAgICAgIG91dHB1dCA9IGdyb3VwQXJyYXlFbGVtZW50cyhjdHgsIG91dHB1dCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYGN0eC5jdXJyZW50RGVwdGhgIGlzIHNldCB0byB0aGUgbW9zdCBpbm5lciBkZXB0aCBvZiB0aGUgY3VycmVudGx5XG4gICAgICAvLyBpbnNwZWN0ZWQgb2JqZWN0IHBhcnQgd2hpbGUgYHJlY3Vyc2VUaW1lc2AgaXMgdGhlIGFjdHVhbCBjdXJyZW50IGRlcHRoXG4gICAgICAvLyB0aGF0IGlzIGluc3BlY3RlZC5cbiAgICAgIC8vXG4gICAgICAvLyBFeGFtcGxlOlxuICAgICAgLy9cbiAgICAgIC8vIGNvbnN0IGEgPSB7IGZpcnN0OiBbIDEsIDIsIDMgXSwgc2Vjb25kOiB7IGlubmVyOiBbIDEsIDIsIDMgXSB9IH1cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgZGVlcGVzdCBkZXB0aCBvZiBgYWAgaXMgMiAoYS5zZWNvbmQuaW5uZXIpIGFuZCBgYS5maXJzdGAgaGFzIGEgbWF4XG4gICAgICAvLyBkZXB0aCBvZiAxLlxuICAgICAgLy9cbiAgICAgIC8vIENvbnNvbGlkYXRlIGFsbCBlbnRyaWVzIG9mIHRoZSBsb2NhbCBtb3N0IGlubmVyIGRlcHRoIHVwIHRvXG4gICAgICAvLyBgY3R4LmNvbXBhY3RgLCBhcyBsb25nIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZSBzbWFsbGVyIHRoYW5cbiAgICAgIC8vIGBjdHguYnJlYWtMZW5ndGhgLlxuICAgICAgaWYgKGN0eC5jdXJyZW50RGVwdGggLSByZWN1cnNlVGltZXMgPCBjdHguY29tcGFjdCAmJiBlbnRyaWVzID09PSBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIC8vIExpbmUgdXAgYWxsIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZSBpbiBjYXNlIHRoZSBlbnRyaWVzIGRvIG5vdFxuICAgICAgICAvLyBleGNlZWQgYGJyZWFrTGVuZ3RoYC4gQWRkIDEwIGFzIGNvbnN0YW50IHRvIHN0YXJ0IG5leHQgdG8gYWxsIG90aGVyXG4gICAgICAgIC8vIGZhY3RvcnMgdGhhdCBtYXkgcmVkdWNlIGBicmVha0xlbmd0aGAuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gb3V0cHV0Lmxlbmd0aCArIGN0eC5pbmRlbnRhdGlvbkx2bCArIGJyYWNlc1swXS5sZW5ndGggKyBiYXNlLmxlbmd0aCArIDEwO1xuICAgICAgICBpZiAoaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCBzdGFydCwgYmFzZSkpIHtcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZSA/IGAke2Jhc2V9IGAgOiAnJ30ke2JyYWNlc1swXX0gJHtqb2luJDEob3V0cHV0LCAnLCAnKX0gJHticmFjZXNbMV19YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBMaW5lIHVwIGVhY2ggZW50cnkgb24gYW4gaW5kaXZpZHVhbCBsaW5lLlxuICAgIGNvbnN0IGluZGVudGF0aW9uID0gYFxcbiR7JyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpfWA7XG4gICAgcmV0dXJuIGAke2Jhc2UgPyBgJHtiYXNlfSBgIDogJyd9JHticmFjZXNbMF19JHtpbmRlbnRhdGlvbn0gIGAgKyBgJHtqb2luJDEob3V0cHV0LCBgLCR7aW5kZW50YXRpb259ICBgKX0ke2luZGVudGF0aW9ufSR7YnJhY2VzWzFdfWA7XG4gIH1cbiAgLy8gTGluZSB1cCBhbGwgZW50cmllcyBvbiBhIHNpbmdsZSBsaW5lIGluIGNhc2UgdGhlIGVudHJpZXMgZG8gbm90IGV4Y2VlZFxuICAvLyBgYnJlYWtMZW5ndGhgLlxuICBpZiAoaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCAwLCBiYXNlKSkge1xuICAgIHJldHVybiBgJHticmFjZXNbMF19JHtiYXNlID8gYCAke2Jhc2V9YCA6ICcnfSAke2pvaW4kMShvdXRwdXQsICcsICcpfSBgICsgYnJhY2VzWzFdO1xuICB9XG4gIGNvbnN0IGluZGVudGF0aW9uID0gJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpO1xuICAvLyBJZiB0aGUgb3BlbmluZyBcImJyYWNlXCIgaXMgdG9vIGxhcmdlLCBsaWtlIGluIHRoZSBjYXNlIG9mIFwiU2V0IHtcIixcbiAgLy8gd2UgbmVlZCB0byBmb3JjZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBvbiB0aGUgbmV4dCBsaW5lIG9yIHRoZVxuICAvLyBpdGVtcyB3aWxsIG5vdCBsaW5lIHVwIGNvcnJlY3RseS5cbiAgY29uc3QgbG4gPSBiYXNlID09PSAnJyAmJiBicmFjZXNbMF0ubGVuZ3RoID09PSAxID8gJyAnIDogYCR7YmFzZSA/IGAgJHtiYXNlfWAgOiAnJ31cXG4ke2luZGVudGF0aW9ufSAgYDtcbiAgLy8gTGluZSB1cCBlYWNoIGVudHJ5IG9uIGFuIGluZGl2aWR1YWwgbGluZS5cbiAgcmV0dXJuIGAke2JyYWNlc1swXX0ke2xufSR7am9pbiQxKG91dHB1dCwgYCxcXG4ke2luZGVudGF0aW9ufSAgYCl9ICR7YnJhY2VzWzFdfWA7XG59XG5mdW5jdGlvbiBmb3JtYXQkMSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZm9ybWF0V2l0aE9wdGlvbnModW5kZWZpbmVkLCAuLi5hcmdzKTtcbn1cbmNvbnN0IGZpcnN0RXJyb3JMaW5lID0gZXJyb3IgPT4gZXJyb3IubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG5sZXQgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRTtcbmZ1bmN0aW9uIHRyeVN0cmluZ2lmeShhcmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gUG9wdWxhdGUgdGhlIGNpcmN1bGFyIGVycm9yIG1lc3NhZ2UgbGF6aWx5XG4gICAgaWYgKCFDSVJDVUxBUl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhID0ge307XG4gICAgICAgIGEuYSA9IGE7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFID0gZmlyc3RFcnJvckxpbmUoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgZmlyc3RFcnJvckxpbmUoZXJyKSA9PT0gQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuZnVuY3Rpb24gZm9ybWF0V2l0aE9wdGlvbnMoaW5zcGVjdE9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgbGV0IGEgPSAwO1xuICBsZXQgc3RyID0gJyc7XG4gIGxldCBqb2luID0gJyc7XG4gIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGxldCB0ZW1wU3RyO1xuICAgIGxldCBsYXN0UG9zID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGZpcnN0LmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgIC8vICclJ1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGZpcnN0LmNoYXJDb2RlQXQoKytpKTtcbiAgICAgICAgaWYgKGEgKyAxICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIHN3aXRjaCAobmV4dENoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAvLyAncydcbiAgICAgICAgICAgICAgY29uc3QgdGVtcEFyZyA9IGFyZ3NbKythXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wQXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHRlbXBBcmcpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVtcEFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBcdHRlbXBTdHIgPSBgJHt0ZW1wQXJnfW5gO1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnN0cjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBBcmcgIT09ICdvYmplY3QnIHx8IHRlbXBBcmcgPT09IG51bGwgfHwgdHlwZW9mIHRlbXBBcmcudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgKGhhc093blByb3BlcnR5KHRlbXBBcmcsICd0b1N0cmluZycpXG4gICAgICAgICAgICAgICAgLy8gQSBkaXJlY3Qgb3duIHByb3BlcnR5IG9uIHRoZSBjb25zdHJ1Y3RvciBwcm90b3R5cGUgaW5cbiAgICAgICAgICAgICAgICAvLyBjYXNlIHRoZSBjb25zdHJ1Y3RvciBpcyBub3QgYW4gYnVpbHQtaW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHx8IChjb25zdHIgPSB0ZW1wQXJnLmNvbnN0cnVjdG9yKSAmJiAhYnVpbHRJbk9iamVjdHMuaGFzKGNvbnN0ci5uYW1lKSAmJiBjb25zdHIucHJvdG90eXBlICYmIGhhc093blByb3BlcnR5KGNvbnN0ci5wcm90b3R5cGUsICd0b1N0cmluZycpKSkge1xuICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9IFN0cmluZyh0ZW1wQXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGluc3BlY3QodGVtcEFyZywge1xuICAgICAgICAgICAgICAgICAgICAuLi5pbnNwZWN0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdDogMyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGg6IDBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTA2OlxuICAgICAgICAgICAgICAvLyAnaidcbiAgICAgICAgICAgICAgdGVtcFN0ciA9IHRyeVN0cmluZ2lmeShhcmdzWysrYV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAvLyAnZCdcbiAgICAgICAgICAgICAgY29uc3QgdGVtcE51bSA9IGFyZ3NbKythXTtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICBcdHRlbXBTdHIgPSBgJHt0ZW1wTnVtfW5gO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBOdW1iZXIodGVtcE51bSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICAgICAgLy8gJ08nXG4gICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwgaW5zcGVjdE9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgICAvLyAnbydcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwge1xuICAgICAgICAgICAgICAgICAgLi4uaW5zcGVjdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBzaG93SGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgc2hvd1Byb3h5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGVwdGg6IDRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMDU6XG4gICAgICAgICAgICAgIC8vICdpJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wSW50ZWdlciA9IGFyZ3NbKythXTtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wSW50ZWdlciA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcEludGVnZXJ9bmA7XG4gICAgICAgICAgICAgIH0gZWxzZSAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBJbnRlZ2VyID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUludCh0ZW1wSW50ZWdlcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICAgIC8vICdmJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wRmxvYXQgPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEZsb2F0ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUZsb2F0KHRlbXBGbG9hdCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgLy8gJyUnXG4gICAgICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEFueSBvdGhlciBjaGFyYWN0ZXIgaXMgbm90IGEgY29ycmVjdCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxhc3RQb3MgIT09IGkgLSAxKSB7XG4gICAgICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcywgaSAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gdGVtcFN0cjtcbiAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09IDM3KSB7XG4gICAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFBvcyAhPT0gMCkge1xuICAgICAgYSsrO1xuICAgICAgam9pbiA9ICcgJztcbiAgICAgIGlmIChsYXN0UG9zIDwgZmlyc3QubGVuZ3RoKSB7XG4gICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2hpbGUgKGEgPCBhcmdzLmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gYXJnc1thXTtcbiAgICBzdHIgKz0gam9pbjtcbiAgICBzdHIgKz0gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyA/IGluc3BlY3QodmFsdWUsIGluc3BlY3RPcHRpb25zKSA6IHZhbHVlO1xuICAgIGpvaW4gPSAnICc7XG4gICAgYSsrO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCAqL1xuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuZnVuY3Rpb24gbG9nVGltZShzZWxmLCBsYWJlbCwgbG9nRGF0YSkge1xuICBsYWJlbCA9IGAke2xhYmVsfWA7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYuX3RpbWVzLmdldChsYWJlbCk7XG4gIGlmICghc3RhcnRUaW1lKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgTGFiZWwgXCIke2xhYmVsfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICBpZiAobG9nRGF0YSkge1xuICAgIHNlbGYubG9nKGAke2xhYmVsfTogJHtkdXJhdGlvbn1tc2AsIC4uLmxvZ0RhdGEpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYubG9nKGAke2xhYmVsfTogJHtkdXJhdGlvbn1tc2ApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGtDb2xvckluc3BlY3RPcHRpb25zID0ge1xuICBjb2xvcnM6IHRydWVcbn07XG5jb25zdCBrTm9Db2xvckluc3BlY3RPcHRpb25zID0ge307XG5sZXQgdGFibGVXYXJuZWQ7IC8vIGJvb2xlYW4gZmxhZyBmb3Igb25lLXRpbWUgd2FybmluZyBhYm91dCBjb25zb2xlLnRhYmxlIG5vdCBiZWluZyBpbXBsZW1lbnRlZFxuXG4vLyBNYWtlIGEgZnVuY3Rpb24gdGhhdCBjYW4gc2VydmUgYXMgdGhlIGNhbGxiYWNrIHBhc3NlZCB0byBgc3RyZWFtLndyaXRlKClgLlxuZnVuY3Rpb24gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIoc3RyZWFtKSB7XG4gIHJldHVybiBlcnIgPT4ge1xuICAgIC8vIFRoaXMgY29uZGl0aW9uYWwgZXZhbHVhdGVzIHRvIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgLy8gdGhhdCB3YXMgbm90IGFscmVhZHkgZW1pdHRlZCAod2hpY2ggaGFwcGVucyB3aGVuIHRoZSBfd3JpdGUgY2FsbGJhY2tcbiAgICAvLyBpcyBpbnZva2VkIGFzeW5jaHJvbm91c2x5KS5cbiAgICBpZiAoZXJyICE9PSBudWxsICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3IsIGl0IHdpbGwgYmUgZW1pdHRlZCBvbiBgc3RyZWFtYCBhc1xuICAgICAgLy8gYW4gYGVycm9yYCBldmVudC4gQWRkaW5nIGEgYG9uY2VgIGxpc3RlbmVyIHdpbGwga2VlcCB0aGF0IGVycm9yXG4gICAgICAvLyBmcm9tIGJlY29taW5nIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiwgYnV0IHNpbmNlIHRoZSBoYW5kbGVyIGlzXG4gICAgICAvLyByZW1vdmVkIGFmdGVyIHRoZSBldmVudCwgbm9uLWNvbnNvbGUuKiB3cml0ZXMgd29uJ3QgYmUgYWZmZWN0ZWQuXG4gICAgICAvLyB3ZSBhcmUgb25seSBhZGRpbmcgbm9vcCBpZiB0aGVyZSBpcyBubyBvbmUgZWxzZSBsaXN0ZW5pbmcgZm9yICdlcnJvcidcbiAgICAgIGlmIChzdHJlYW0ubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBub29wJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmNsYXNzIENvbnNvbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBzdGRlcnIsIGlnbm9yZUVycm9ycykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBpTmFtZSA9PT0gJ1RpLkFQSScpIHtcbiAgICAgIC8vIFBhc3NpbmcgaW4gVGkuQVBJIG1vZHVsZSB3aGVyZSB3ZSByZXRhaW4gbG9nIGxldmVsc1xuICAgICAgdGhpcy5fYXBpTW9kdWxlID0gb3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZS5KUyBzdHJlYW1zXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm8gYXJncywgb3IgZmlyc3QgYXJnIGlzIGEgc3RyZWFtXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3Rkb3V0OiBvcHRpb25zLFxuICAgICAgICAgIHN0ZGVycixcbiAgICAgICAgICBpZ25vcmVFcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0ZG91dCA9IG9wdGlvbnMuc3Rkb3V0OyAvLyBUT0RPOiBlbmZvcmNlIGhhcyB3cml0ZSBmdW5jdGlvbj9cbiAgICAgIHRoaXMuX3N0ZGVyciA9IG9wdGlvbnMuc3RkZXJyIHx8IHRoaXMuX3N0ZG91dDtcbiAgICAgIHRoaXMuX2lnbm9yZUVycm9ycyA9IG9wdGlvbnMuaWdub3JlRXJyb3JzICE9PSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgdGhpcy5fc3Rkb3V0RXJyb3JIYW5kbGVyID0gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIodGhpcy5fc3Rkb3V0KTtcbiAgICAgICAgdGhpcy5fc3RkZXJyRXJyb3JIYW5kbGVyID0gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIodGhpcy5fc3RkZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbG9yTW9kZSA9IG9wdGlvbnMuY29sb3JNb2RlIHx8ICdhdXRvJzsgLy8gVE9ETzogZW5mb3JjZSBib29sZWFuIG9yICdhdXRvJ1xuICAgICAgdGhpcy5faW5zcGVjdE9wdGlvbnMgPSBvcHRpb25zLmluc3BlY3RPcHRpb25zOyAvLyBUT0RPOiBlbmZvcmNlIHVuZGVmaW5lZCBvciB0eXBlb2YgJ29iamVjdCdcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fZ3JvdXBJbmRlbnQgPSAnJztcbiAgfVxuICBfd3JpdGVUb0NvbnNvbGUobGV2ZWwsIHN0cmluZykge1xuICAgIGlmICh0aGlzLl9ncm91cEluZGVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXG4vZywgYFxcbiR7dGhpcy5fZ3JvdXBJbmRlbnR9YCk7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0aGlzLl9ncm91cEluZGVudCArIHN0cmluZztcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IHdyYXBwaW5nIFRpLkFQSSAod2hpY2ggcmV0YWlucyBsb2cgbGV2ZWwpXG4gICAgaWYgKHRoaXMuX2FwaU1vZHVsZSkge1xuICAgICAgdGhpcy5fYXBpTW9kdWxlW2xldmVsXShzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IE5vZGUuSlMgc3RyZWFtcyBsaWtlIHN0ZG91dC9zdGRlcnIgd2hpY2ggZG9uJ3QgaGF2ZSBsb2cgbGV2ZWxzXG4gICAgICBjb25zdCB1c2VTdGRFcnIgPSBsZXZlbCA9PT0gJ3dhcm4nIHx8IGxldmVsID09PSAnZXJyb3InIHx8IGxldmVsID09PSAndHJhY2UnO1xuICAgICAgY29uc3Qgc3RyZWFtID0gdXNlU3RkRXJyID8gdGhpcy5fc3RkZXJyIDogdGhpcy5fc3Rkb3V0O1xuICAgICAgaWYgKHRoaXMuX2lnbm9yZUVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS53cml0ZShzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVyZSBtYXkgYmUgYW4gZXJyb3Igb2NjdXJyaW5nIHN5bmNocm9ub3VzbHkgKGUuZy4gZm9yIGZpbGVzIG9yIFRUWXNcbiAgICAgIC8vIG9uIFBPU0lYIHN5c3RlbXMpIG9yIGFzeW5jaHJvbm91c2x5IChlLmcuIHBpcGVzIG9uIFBPU0lYIHN5c3RlbXMpLCBzb1xuICAgICAgLy8gaGFuZGxlIGJvdGggc2l0dWF0aW9ucy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEFkZCBhbmQgbGF0ZXIgcmVtb3ZlIGEgbm9vcCBlcnJvciBoYW5kbGVyIHRvIGNhdGNoIHN5bmNocm9ub3VzIGVycm9ycy5cbiAgICAgICAgaWYgKHN0cmVhbS5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICAgICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgbm9vcCQxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSB1c2VTdGRFcnIgPyB0aGlzLl9zdGRlcnJFcnJvckhhbmRsZXIgOiB0aGlzLl9zdGRvdXRFcnJvckhhbmRsZXI7XG4gICAgICAgIHN0cmVhbS53cml0ZShzdHJpbmcsIGVycm9ySGFuZGxlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIENvbnNvbGUgaXMgYSBkZWJ1Z2dpbmcgdXRpbGl0eSwgc28gaXQgc3dhbGxvd2luZyBlcnJvcnMgaXMgbm90IGRlc2lyYWJsZVxuICAgICAgICAvLyBldmVuIGluIGVkZ2UgY2FzZXMgc3VjaCBhcyBsb3cgc3RhY2sgc3BhY2UuXG4gICAgICAgIGlmIChpc1N0YWNrT3ZlcmZsb3dFcnJvcihlKSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ycnksIHRoZXJlJ3Mgbm8gcHJvcGVyIHdheSB0byBwYXNzIGFsb25nIHRoZSBlcnJvciBoZXJlLlxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyICYmIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBub29wJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbmZvKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2luZm8nLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG4gIHdhcm4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCd3YXJuJywgZm9ybWF0V2l0aE9wdGlvbnMoa05vQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG4gIGVycm9yKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnZXJyb3InLCBmb3JtYXRXaXRoT3B0aW9ucyhrTm9Db2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cbiAgZGVidWcoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCdkZWJ1ZycsIGZvcm1hdFdpdGhPcHRpb25zKGtDb2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cbiAgdHJhY2UoKSB7XG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCd0cmFjZScsIGZvcm1hdFdpdGhPcHRpb25zKGtDb2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cbiAgY2xlYXIoKSB7fSAvLyBuby1vcFxuXG4gIGdyb3VwKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5sb2coLi4uYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fZ3JvdXBJbmRlbnQgKz0gJyAgJztcbiAgfVxuICBncm91cEVuZCgpIHtcbiAgICB0aGlzLl9ncm91cEluZGVudCA9IHRoaXMuX2dyb3VwSW5kZW50LnNsaWNlKDAsIHRoaXMuX2dyb3VwSW5kZW50Lmxlbmd0aCAtIDIpO1xuICB9XG4gIGRpcihvYmosIG9wdGlvbnMpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnaW5mbycsIGluc3BlY3Qob2JqLCB7XG4gICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KSk7XG4gIH1cbiAgYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42ID4gMSA/IF9sZW42IC0gMSA6IDApLCBfa2V5NiA9IDE7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NiAtIDFdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cbiAgICAgIGFyZ3NbMF0gPSBgQXNzZXJ0aW9uIGZhaWxlZCR7YXJncy5sZW5ndGggPT09IDAgPyAnJyA6IGA6ICR7YXJnc1swXX1gfWA7XG4gICAgICB0aGlzLndhcm4oLi4uYXJncyk7IC8vIFRoZSBhcmd1bWVudHMgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gd2FybigpIGFnYWluXG4gICAgfVxuICB9XG5cbiAgY291bnQoKSB7XG4gICAgbGV0IGxhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGVmYXVsdCc7XG4gICAgLy8gRW5zdXJlcyB0aGF0IGxhYmVsIGlzIGEgc3RyaW5nLCBhbmQgb25seSB0aGluZ3MgdGhhdCBjYW4gYmVcbiAgICAvLyBjb2VyY2VkIHRvIHN0cmluZ3MuIGUuZy4gU3ltYm9sIGlzIG5vdCBhbGxvd2VkXG4gICAgbGFiZWwgPSBgJHtsYWJlbH1gO1xuICAgIGxldCBjb3VudCA9IHRoaXMuX2NvdW50cy5nZXQobGFiZWwpO1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHRoaXMuX2NvdW50cy5zZXQobGFiZWwsIGNvdW50KTtcbiAgICB0aGlzLmxvZyhgJHtsYWJlbH06ICR7Y291bnR9YCk7XG4gIH1cbiAgY291bnRSZXNldCgpIHtcbiAgICBsZXQgbGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkZWZhdWx0JztcbiAgICBpZiAoIXRoaXMuX2NvdW50cy5oYXMobGFiZWwpKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBDb3VudCBmb3IgJyR7bGFiZWx9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb3VudHMuZGVsZXRlKGAke2xhYmVsfWApO1xuICB9XG4gIHRpbWUoKSB7XG4gICAgbGV0IGxhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGVmYXVsdCc7XG4gICAgbGFiZWwgPSBgJHtsYWJlbH1gO1xuICAgIGlmICh0aGlzLl90aW1lcy5oYXMobGFiZWwpKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBMYWJlbCAke2xhYmVsfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RpbWVzLnNldChsYWJlbCwgRGF0ZS5ub3coKSk7XG4gIH1cbiAgdGltZUVuZCgpIHtcbiAgICBsZXQgbGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkZWZhdWx0JztcbiAgICBjb25zdCB3YXJuZWQgPSBsb2dUaW1lKHRoaXMsIGxhYmVsKTtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgdGhpcy5fdGltZXMuZGVsZXRlKGxhYmVsKTtcbiAgICB9XG4gIH1cbiAgdGltZUxvZygpIHtcbiAgICBsZXQgbGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkZWZhdWx0JztcbiAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGxvZ0RhdGEgPSBuZXcgQXJyYXkoX2xlbjcgPiAxID8gX2xlbjcgLSAxIDogMCksIF9rZXk3ID0gMTsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgbG9nRGF0YVtfa2V5NyAtIDFdID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICB9XG4gICAgbG9nVGltZSh0aGlzLCBsYWJlbCwgbG9nRGF0YSk7XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgY29uc29sZS50YWJsZSgpXG4gIHRhYmxlKCkge1xuICAgIGlmICghdGFibGVXYXJuZWQpIHtcbiAgICAgIHRhYmxlV2FybmVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1wiY29uc29sZS50YWJsZVwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gVGl0YW5pdW0hJyk7XG4gICAgfVxuICB9XG59XG5Db25zb2xlLnByb3RvdHlwZS5sb2cgPSBDb25zb2xlLnByb3RvdHlwZS5pbmZvOyAvLyBUcmVhdCBsb2cgYXMgYWxpYXMgdG8gaW5mb1xuQ29uc29sZS5wcm90b3R5cGUuZGlyeG1sID0gQ29uc29sZS5wcm90b3R5cGUubG9nOyAvLyBUcmVhdCBkaXJ4bWwgYXMgYWxpYXMgdG8gbG9nXG5Db25zb2xlLnByb3RvdHlwZS5ncm91cENvbGxhcHNlZCA9IENvbnNvbGUucHJvdG90eXBlLmdyb3VwO1xuY29uc3QgZ2xvYmFsQ29uc29sZSA9IG5ldyBDb25zb2xlKFRpLkFQSSk7XG5nbG9iYWxDb25zb2xlLkNvbnNvbGUgPSBDb25zb2xlO1xuZ2xvYmFsLmNvbnNvbGUgPSBnbG9iYWxDb25zb2xlO1xuXG4vKipcbiAqIFRpdGFuaXVtIFNES1xuICogQ29weXJpZ2h0IFRpRGV2LCBJbmMuIDA0LzA3LzIwMjItUHJlc2VudC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLy8gQWRkIGEgdG9KU09OKCkgbWV0aG9kIHRvIGFsbCBFcnJvciBvYmplY3RzIG5lZWRlZCB0byBvdXRwdXQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcy5cbi8vIFRoZSBKU09OLnN0cmluZ2lmeSgpIHdpbGwgYXV0b21hdGljYWxseSBjYWxsIHRoaXMgbWV0aG9kIGlmIGl0IGV4aXN0cyB0byBwcm92aWRlIGN1c3RvbSBvdXRwdXQuXG4vLyBOb3Rlczpcbi8vIC0gSW4gVjgsIGFsbCBFcnJvciBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZS4gV2UgbmVlZCB0aGlzIG9yIGVsc2Ugc3RyaW5naWZ5KCkgd2lsbCByZXR1cm4gXCJ7fVwiLlxuLy8gLSBJbiBKYXZhU2NyaXB0Q29yZSwgb25seSB0aGUgXCJzdGFja1wiIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlLiBXZSB3YW50IHRvIHJldmVhbCB0aGlzLlxuaWYgKHR5cGVvZiBFcnJvci5wcm90b3R5cGUudG9KU09OICE9PSAnZnVuY3Rpb24nKSB7XG4gIEVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm9wZXJ0aWVzW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgdXNlZCB0byBoaWphY2sgdGhlIHN0YW5kYXJkIHJlcXVpcmUgdG8gYWxsb3cgZm9yIEpTXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgXCJjb3JlXCIgbW9kdWxlcy5cbiAqXG4gKiBZb3UgYWRkIGEgYmluZGluZyBmcm9tIHRoZSBcImNvcmVcIiBtb2R1bGUgaWQgdG8gdGhlIHVuZGVyIHRoZSBob29kIEpTXG4gKiBpbXBsZW1lbnRhdGlvbi4gV2UgdGhlbiBpbnRlcmNlcHQgcmVxdWlyZSBjYWxscyB0byBoYW5kbGUgcmVxdWVzdHMgZm9yIHRoZXNlIG1vZHVsZXNcbiAqIGFuZCBsYXppbHkgbG9hZCB0aGUgZmlsZS5cbiAqL1xuXG4vKipcbiAqIFVzZWQgYnkgQGZ1bmN0aW9uIGJpbmRPYmplY3RUb0NvcmVNb2R1bGVJZFxuICogQHR5cGUge21hcDxzdHJpbmcsIG9iamVjdD59XG4gKi9cbmNvbnN0IGJpbmRpbmdzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIFVzZWQgYnkgQGZ1bmN0aW9uIHJlZGlyZWN0Q29yZU1vZHVsZUlkVG9QYXRoXG4gKiBAdHlwZSB7bWFwPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgcmVkaXJlY3RzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIERvZXMgdGhlIHJlcXVlc3QgbG9vayBsaWtlIGEgdHlwaWNhbCBjb3JlIG1vZHVsZT8gKG5vICcuJyBvciAnLycgY2hhcmFjdGVycylcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIG9yaWdpbmFsIHJlcXVpcmUgcGF0aC9pZFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzSGlqYWNrYWJsZU1vZHVsZUlkKHBhdGgpIHtcbiAgaWYgKCFwYXRoIHx8IHBhdGgubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBmaXJzdENoYXIgPSBwYXRoLmNoYXJBdCgwKTtcbiAgcmV0dXJuIGZpcnN0Q2hhciAhPT0gJy4nICYmIGZpcnN0Q2hhciAhPT0gJy8nO1xufVxuXG4vLyBIYWNrIHJlcXVpcmUgdG8gcG9pbnQgdG8gdGhpcyBhcyBjb3JlIG1vZHVsZSBcImJpbmRpbmdcIi4gKE5vdGUgdGhhdCBpT1MgZG9lcyBub3QgaGF2ZSBhIGdsb2JhbCByZXF1aXJlLilcbmNvbnN0IG9yaWdpbmFsUmVxdWlyZSA9IGdsb2JhbC5yZXF1aXJlID8gZ2xvYmFsLnJlcXVpcmUgOiByZXF1aXJlLm1haW4ucmVxdWlyZS5iaW5kKHJlcXVpcmUubWFpbik7XG4vLyBUaGlzIHdvcmtzIGZvciBXaW5kb3dzIGFzLWlzLCBhbmQgYWxzbyBpbnRlcmNlcHRzIHRoZSBjYWxsIG9uIEFuZHJvaWQvaU9TIGZvciB0aS5tYWluLmpzICh0aGUgZmlyc3QgZmlsZSBleGVjdXRlZClcbmdsb2JhbC5yZXF1aXJlID0gZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gIGlmIChiaW5kaW5ncy5oYXMobW9kdWxlSWQpKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdzLmdldChtb2R1bGVJZCk7XG4gIH1cbiAgaWYgKHJlZGlyZWN0cy5oYXMobW9kdWxlSWQpKSB7XG4gICAgbW9kdWxlSWQgPSByZWRpcmVjdHMuZ2V0KG1vZHVsZUlkKTtcbiAgfVxuICByZXR1cm4gb3JpZ2luYWxSZXF1aXJlKG1vZHVsZUlkKTtcbn07XG5cbi8vIC4uLiBidXQgd2Ugc3RpbGwgbmVlZCB0byBoYWNrIGl0IHdoZW4gcmVxdWlyaW5nIGZyb20gb3RoZXIgZmlsZXMgZm9yIEFuZHJvaWQvaU9TIChkdWUgdG8gbW9kdWxlLmpzIGltcGwpXG5jb25zdCBvcmlnaW5hbE1vZHVsZVJlcXVpcmUgPSBnbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlO1xuZ2xvYmFsLk1vZHVsZS5wcm90b3R5cGUucmVxdWlyZSA9IGZ1bmN0aW9uIChwYXRoLCBjb250ZXh0KSB7XG4gIGlmIChiaW5kaW5ncy5oYXMocGF0aCkpIHtcbiAgICByZXR1cm4gYmluZGluZ3MuZ2V0KHBhdGgpO1xuICB9XG4gIGlmIChyZWRpcmVjdHMuaGFzKHBhdGgpKSB7XG4gICAgcGF0aCA9IHJlZGlyZWN0cy5nZXQocGF0aCk7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbmFsTW9kdWxlUmVxdWlyZS5jYWxsKHRoaXMsIHBhdGgsIGNvbnRleHQpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBiaW5kaW5nIGZyb20gYSBzaG9ydCBtb2R1bGUgaWQgdG8gYW4gYWxyZWFkeSBsb2FkZWQvY29uc3RydWN0ZWQgb2JqZWN0L3ZhbHVlIHRvIGV4cG9ydCBmb3IgdGhhdCBjb3JlIG1vZHVsZSBpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCB0aGUgbW9kdWxlIGlkIHRvIFwiaGlqYWNrXCJcbiAqIEBwYXJhbSB7Kn0gYmluZGluZyBhbiBhbHJlYWR5IGNvbnN0cnVjdHVyZWQgdmFsdWUvb2JqZWN0IHRvIHJldHVyblxuICovXG5mdW5jdGlvbiByZWdpc3Rlcihtb2R1bGVJZCwgYmluZGluZykge1xuICBpZiAoIWlzSGlqYWNrYWJsZU1vZHVsZUlkKG1vZHVsZUlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIGZvciByZWxhdGl2ZS9hYnNvbHV0ZSBmaWxlIHBhdGhzOyBubyBsZWFkaW5nICcuJyBvciAnLycgYWxsb3dlZCAod2FzIGdpdmVuICR7bW9kdWxlSWR9KWApO1xuICB9XG4gIGlmIChyZWRpcmVjdHMuaGFzKG1vZHVsZUlkKSkge1xuICAgIFRpLkFQSS53YXJuKGBBbm90aGVyIGJpbmRpbmcgaGFzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbW9kdWxlIGlkOiAnJHttb2R1bGVJZH0nLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uYCk7XG4gICAgcmVkaXJlY3RzLmRlbGV0ZShtb2R1bGVJZCk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIFRpLkFQSS53YXJuKGBBbm90aGVyIGJpbmRpbmcgaGFzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbW9kdWxlIGlkOiAnJHttb2R1bGVJZH0nLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uYCk7XG4gIH1cbiAgYmluZGluZ3Muc2V0KG1vZHVsZUlkLCBiaW5kaW5nKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBiaW5kaW5nIGZyb20gYSBzaG9ydCBtb2R1bGUgaWQgdG8gdGhlIGZ1bGwgdW5kZXIgdGhlIGhvb2QgZmlsZXBhdGggaWYgZ2l2ZW4gYSBzdHJpbmcuXG4gKiBUaGlzIGFsbG93cyBmb3IgbGF6eSBpbnN0YW50aWF0aW9uIG9mIHRoZSBtb2R1bGUgb24tZGVtYW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIHRoZSBtb2R1bGUgaWQgdG8gXCJoaWphY2tcIlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIHRoZSBmdWxsIGZpbGVwYXRoIHRvIHJlcXVpcmUgdW5kZXIgdGhlIGhvb2QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgc2hvdWxkIGJlIGFuIGFscmVhZHkgcmVzb2x2ZWQgYWJzb2x1dGUgcGF0aCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgb3RoZXJ3aXNlIHRoZSBjb250ZXh0IG9mIHRoZSBjYWxsIGNvdWxkIGNoYW5nZSB3aGF0IGdldHMgbG9hZGVkIVxuICovXG5mdW5jdGlvbiByZWRpcmVjdChtb2R1bGVJZCwgZmlsZXBhdGgpIHtcbiAgaWYgKCFpc0hpamFja2FibGVNb2R1bGVJZChtb2R1bGVJZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiAke21vZHVsZUlkfSlgKTtcbiAgfVxuICBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIFRpLkFQSS53YXJuKGBBbm90aGVyIGJpbmRpbmcgaGFzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbW9kdWxlIGlkOiAnJHttb2R1bGVJZH0nLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uYCk7XG4gICAgYmluZGluZ3MuZGVsZXRlKG1vZHVsZUlkKTtcbiAgfSBlbHNlIGlmIChyZWRpcmVjdHMuaGFzKG1vZHVsZUlkKSkge1xuICAgIFRpLkFQSS53YXJuKGBBbm90aGVyIGJpbmRpbmcgaGFzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbW9kdWxlIGlkOiAnJHttb2R1bGVJZH0nLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uYCk7XG4gIH1cbiAgcmVkaXJlY3RzLnNldChtb2R1bGVJZCwgZmlsZXBhdGgpO1xufVxuXG4vLyBGSVhNRTogVGhlcmUncyBhIGNvbGxpc2lvbiBoZXJlIHdpdGggZ2xvYmFsLmJpbmRpbmcgZGVjbGFyZWQgaW4gS3JvbGxCcmlkZ2UubSBvbiBpT1NcbmlmICghZ2xvYmFsLmJpbmRpbmcpIHtcbiAgZ2xvYmFsLmJpbmRpbmcgPSB7fTtcbn1cbmdsb2JhbC5iaW5kaW5nLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5nbG9iYWwuYmluZGluZy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xuXG4vLyBMb2FkIGFsbCBKYXZhU2NyaXB0IGV4dGVuc2lvbnMvcG9seWZpbGxzXG5yZWdpc3RlcignY29uc29sZScsIGdsb2JhbENvbnNvbGUpO1xuXG4vKipcbiAqIFRpdGFuaXVtIFNES1xuICogQ29weXJpZ2h0IFRpRGV2LCBJbmMuIDA0LzA3LzIwMjItUHJlc2VudC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCwgT1NfSU9TLCBPU19WRVJTSU9OX01BSk9SICovXG5jb25zdCBidWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICB2YWx1ZTogJydcbn0pO1xuY29uc3QgYmxvYiA9IGJ1ZmZlci50b0Jsb2IoKTtcbmNvbnN0IEJsb2JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmxvYik7XG57XG4gIGlmIChPU19WRVJTSU9OX01BSk9SIDwgMTMpIHtcbiAgICBCbG9iUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/ICdbb2JqZWN0IFRpQmxvYl0nIDogdmFsdWU7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgc2NyaXB0IGlzIHVzZWQgYXQgcnVudGltZSBmb3IgVGkuVUkuZmV0Y2hTZW1hbnRpY0NvbG9yIC0gYXMgd2VsbCBhcyBhdCBidWlsZCB0aW1lIGJ5IGJvdGggaU9TL0FuZHJvaWQuXG4gKiBJdCBwcm92aWRlcyBhIGNvbW1vbiBpbnRlcmZhY2UgZm9yIGhhbmRsaW5nIGNvbG9ycyBhbmQgY29udmVydGluZyB0byBuZWNlc3Nhcnkgc3RyaW5nIGZvcm1zLlxuICovXG5jb25zdCBIRVhfM19SRUdFWCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7IC8vIGkuZS4gIzBGM1xuY29uc3QgSEVYXzRfUkVHRVggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTsgLy8gaS5lLiAjMEYzOFxuY29uc3QgSEVYXzZfUkVHRVggPSAvXiM/KFthLWZcXGRdKXs2fSQvaTsgLy8gaS5lLiAjMDBGRjMzXG5jb25zdCBIRVhfOF9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pezh9JC9pOyAvLyBpLmUuICMwMEZGMzM4OFxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlZ2VyIGluIHJhbmdlIG9mIDAtMjU1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAyLWNoYXJhY3RlciBoZXggc3RyaW5nIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHBhZGRlZEhleChpbnRlZ2VyKSB7XG4gIGNvbnN0IHN0ciA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBgMCR7c3RyfWA7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmNsYXNzIENvbG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIHJlZCB2YWx1ZSBpbiByYW5nZSAwLTI1NVxuICAgKiBAcGFyYW0ge251bWJlcn0gZyBncmVlbiB2YWx1ZSBpbiByYW5nZSAwLTI1NVxuICAgKiBAcGFyYW0ge251bWJlcn0gYiBibHVlIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYT0xLjBdIGFscGhhIHZhbHVlIGluIHJhbmdlIDAuMC0xLjBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHIsIGcsIGIpIHtcbiAgICBsZXQgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMS4wO1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5nID0gZztcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYWxwaGEgPSBhO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGljYXRlcyBpZiB0aGlzIGlzIGEgZnVsbHkgb3BhcXVlIGNvbG9yIChhbHBoYSBpcyAxLjAgb3Igd2FzIHVuZGVmaW5lZClcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc09wYXF1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYSA9PT0gMS4wO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBhbHBoYSB2YWx1ZSBpbnRvIGVxdWl2YWxlbnQgaGV4IHN0cmluZyB2YWx1ZSBwcm9wZXJseS5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGFscGhhSGV4KCkge1xuICAgIC8vIG5lZWQgdG8gcm91bmQgdG8gYXZvaWQgbm9uc2Vuc2ljYWwgdmFsdWVzIGxpa2UgJzdmLjgnIGZvciBhIDAuNSBhbHBoYVxuICAgIHJldHVybiBwYWRkZWRIZXgoTWF0aC5yb3VuZCh0aGlzLmFscGhhICogMjU1LjApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyBhbnkgYWxwaGEgdmFsdWUuIFRvIGJlIHVzZWQgaW50ZXJuYWxseSwgbm90IGV4dGVybmFsIGFwaS4gRG9lcyBub3QgcHJvdmlkZSBsZWFkaW5nICcjJyBzeW1ib2wuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdG9SR0JIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3BhZGRlZEhleCh0aGlzLnIpfSR7cGFkZGVkSGV4KHRoaXMuZyl9JHtwYWRkZWRIZXgodGhpcy5iKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgQ1NTLlxuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGEgaGV4IHN0cmluZyB3aXRoIGxlYWRpbmcgJyMnIHN5bWJvbCBhbmQgNi0gb3IgOC1cbiAgICogaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoZGVwZW5kaW5nIG9uIGlmIGFscGhhIGlzIDEuMClcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvUkdCQUhleFN0cmluZygpIHtcbiAgICBpZiAodGhpcy5pc09wYXF1ZSgpKSB7XG4gICAgICByZXR1cm4gYCMke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAjJHt0aGlzLl90b1JHQkhleFN0cmluZygpfSR7dGhpcy5hbHBoYUhleCgpfWA7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBBbmRyb2lkL2lPU1xuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGEgaGV4IHN0cmluZyB3aXRoIGxlYWRpbmcgJyMnIHN5bWJvbCBhbmQgNi0gb3IgOC1cbiAgICogaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoZGVwZW5kaW5nIG9uIGlmIGFscGhhIGlzIDEuMCkuIEFscGhhIGlzIHRoZSBmaXJzdCBlbnRyeSAoaWYgdGhlcmUgaXMgYWxwaGEuKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9BUkdCSGV4U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmlzT3BhcXVlKCkpIHtcbiAgICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCMke3RoaXMuYWxwaGFIZXgoKX0ke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgY29tbW9uYWxpdHkgd2l0aCBuYXRpdmUgaU9TIFRpQ29sb3IgcHJveHkuIFByb2R1Y2VzIGFuIEFBUlJHR0JCIChvciBSUkdHQkIgaWYgZnVsbCBhbHBoYSkgaGV4IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9IZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BUkdCSGV4U3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBjb2xvciB0byBhbiByZ2JhIGV4cHJlc3Npb24uIFRoaXMgZXhwcmVzc2lvbiBpcyBtb3JlIGNvbnNpc3RlbnQgYWNyb3NzIHBsYXRmb3Jtcy5cbiAgICogKHdoZXJlYXMgaU9TL0FuZHJvaWQgZGlmZmVyIGluIGV4cGVjdGF0aW9ucyBmb3IgaGV4IHN0cmluZ3MuKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9SR0JBU3RyaW5nKCkge1xuICAgIHJldHVybiBgcmdiYSgke3RoaXMucn0sICR7dGhpcy5nfSwgJHt0aGlzLmJ9LCAke3RoaXMuYWxwaGEudG9GaXhlZCgzKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q29sb3J9XG4gICAqL1xuICBzdGF0aWMgZmFsbGJhY2soKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwKTsgLy8gcmV0dXJuIGJsYWNrIHRvIG1hdGNoIG5hdGl2ZSBpbXBsIGluIGlPU1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMCcgKGkuZS4gbGVhZGluZyBwb3VuZCBzeW1ib2wsIDYgaGV4IGNoYXJhY3RlcnMgYWZ0ZXIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGFdIGFscGhhIHZhbHVlXG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSGV4NlN0cmluZyhoZXgsIGFscGhhKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGhleC5zdGFydHNXaXRoKCcjJykgPyAxIDogMDtcbiAgICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4LCAyKSwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyAyLCAyKSwgMTYpO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA0LCAyKSwgMTYpO1xuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYWxwaGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMDAwJyAoaS5lLiBsZWFkaW5nIHBvdW5kIHN5bWJvbCwgOCBoZXggY2hhcmFjdGVycyBhZnRlcilcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhleCBoZXhhZGVjaW1hbCBjb2xvciBzdHJpbmdcbiAgICogQHJldHVybnMge0NvbG9yfVxuICAgKi9cbiAgc3RhdGljIGZyb21IZXg4U3RyaW5nKGhleCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBoZXguc3RhcnRzV2l0aCgnIycpID8gMSA6IDA7XG4gICAgY29uc3QgYWxwaGEgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXgsIDIpLCAxNik7IC8vIGFscGhhIGlzIG5vdyAwLTI1NVxuICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyAyLCAyKSwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA0LCAyKSwgMTYpO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA2LCAyKSwgMTYpO1xuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYWxwaGEgLyAyNTUuMCk7IC8vIGNvbnZlcnQgdG8gMC4wLTEuMCAocGVyY2VudClcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgdGhlIGhleCB2YWx1ZSBjYW4gY29udGFpbiBhbHBoYSwgYnV0IG11c3QgZm9sbG93IHRoZSBDU1Mgc3RhbmRhcmQgb2YgI1JSR0dCQkFBIChOT1QgdGhlIEFuZHJvaWQgc3RhbmRhcmQgb2YgI0FBUlJHR0JCKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGVudHJ5IHBvc3NpYmxlIGhleCBzdHJpbmcgb3IgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2hleC5hbHBoYV0gYWxwaGEgdmFsdWUgaW4gcGVyY2VudCAoMC4wLTEwMC4wKSB3aGVuIGhleCBpcyBhbiBvYmplY3RcbiAgXHQgKiBAcGFyYW0ge3N0cmluZ30gW2hleC5jb2xvcl0gaGV4IHN0cmluZyBmb3IgdGhlIGJhc2UgY29sb3Igd2hlbiBoZXggaXMgYW4gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICogQHRocm93cyBpZiBlbnRyeSBoYXMgYm90aCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYW4gYWxwaGEgdmFsdWVcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VtYW50aWNDb2xvcnNFbnRyeShlbnRyeSkge1xuICAgIGxldCBjb2xvciA9IGVudHJ5O1xuICAgIGxldCBhbHBoYSA9IDEuMDtcbiAgICBsZXQgaGFkQWxwaGEgPSBmYWxzZTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudHJ5LCAnYWxwaGEnKSkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGVudHJ5LmFscGhhKSAvIDEwMC4wOyAvLyBjb252ZXJ0IGZyb20gMC0xMDAgcmFuZ2UgdG8gMC0xIHJhbmdlXG4gICAgICBoYWRBbHBoYSA9IHRydWU7XG4gICAgICBjb2xvciA9IGVudHJ5LmNvbG9yOyAvLyBpZiBpdCBoYXMgYW4gYWxwaGEgcHJvcGVydHkgYXNzdW1lIGl0IGhhcyBhIGNvbG9yIHByb3BlcnR5IHRvbyFcbiAgICB9XG5cbiAgICAvLyBleHBhbmQgdGhlIHNob3J0ZXIgaGV4IHN0cmluZyBmb3JtcyB0byA2IG9yIDggZGlnaXRzXG4gICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKEhFWF8zX1JFR0VYLCAobSwgciwgZywgYikgPT4gciArIHIgKyBnICsgZyArIGIgKyBiKTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGOFwiKSB0byBmdWxsIGZvcm0gKGUuZy4gXCIwMDMzRkY4OFwiKVxuICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKEhFWF80X1JFR0VYLCAobSwgYSwgciwgZywgYikgPT4gYSArIGEgKyByICsgciArIGcgKyBnICsgYiArIGIpO1xuICAgIH1cbiAgICBpZiAoSEVYXzZfUkVHRVguZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4NlN0cmluZyhjb2xvciwgYWxwaGEpO1xuICAgIH1cbiAgICBpZiAoSEVYXzhfUkVHRVguZXhlYyhjb2xvcikpIHtcbiAgICAgIGlmIChoYWRBbHBoYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbG9yICR7ZW50cnl9IGhhZCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggdmFsdWUgY29udGFpbmluZyBhbHBoYS4gVXNlIG9uZSBvciB0aGUgb3RoZXIuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29sb3IuZnJvbUhleDhTdHJpbmcoY29sb3IpO1xuICAgIH1cbiAgICAvLyB1aC1vaCwgc29tZXRoaW5nIGlzIHVwIVxuICAgIHJldHVybiBDb2xvci5mYWxsYmFjaygpO1xuICB9XG59XG52YXIgY29sb3IgPSBDb2xvcjtcblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5jb25zdCBpc0lPUzEzUGx1cyA9IE9TX1ZFUlNJT05fTUFKT1IgPj0gMTM7XG5jb25zdCBpc01hY09TID0gVGkuUGxhdGZvcm0ubmFtZSA9PT0gJ01hYyBPUyBYJztcbmNvbnN0IGlzTUFDT1NYQ2F0YWxpbmFQbHVzID0gaXNNYWNPUyAmJiAoT1NfVkVSU0lPTl9NQUpPUiA+IDEwIHx8IE9TX1ZFUlNJT05fTUFKT1IgPT09IDEwICYmIE9TX1ZFUlNJT05fTUlOT1IgPj0gMTUpO1xuXG4vLyBBcyBBbmRyb2lkIHBhc3NlcyBhIG5ldyBpbnN0YW5jZSBvZiBUaS5VSSB0byBldmVyeSBKUyBmaWxlIHdlIGNhbid0IGp1c3Rcbi8vIFRpLlVJIHdpdGhpbiB0aGlzIGZpbGUsIHdlIG11c3QgY2FsbCBrcm9sbC5iaW5kaW5nIHRvIGdldCB0aGUgVGl0YW5pdW1cbi8vIG5hbWVzcGFjZSB0aGF0IGlzIHBhc3NlZCBpbiB3aXRoIHJlcXVpcmUgYW5kIHRoYXQgZGVhbCB3aXRoIHRoZSAuVUlcbi8vIG5hbWVzcGFjZSB0aGF0IGlzIG9uIHRoYXQgZGlyZWN0bHkuXG5jb25zdCBVSSA9IFRpLlVJO1xuXG4vLyBNYWtlIG91ciByZWFkLW9ubHkgY29uc3RhbnRzXG4vLyBUT0RPOiBSZW1vdmUgaW4gU0RLIDEwLCBERVBSRUNBVEVEIGluIDkuMS4wXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVUksICdTRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUJywge1xuICB2YWx1ZTogJ2xpZ2h0JyxcbiAgd3JpdGFibGU6IGZhbHNlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ1NFTUFOVElDX0NPTE9SX1RZUEVfREFSSycsIHtcbiAgdmFsdWU6ICdkYXJrJyxcbiAgd3JpdGFibGU6IGZhbHNlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ3NlbWFudGljQ29sb3JUeXBlJywge1xuICBnZXQ6ICgpID0+IHtcbiAgICAvLyBUT0RPOiBHdWFyZCBhZ2FpbnN0IGlvcyA8IDEzIGFuZCBBbmRyb2lkIGFwaSA8IDI5P1xuICAgIC8vIEFzc3VtZSBcImxpZ2h0XCIgbW9kZSB1bmxlc3Mgd2UgZXhwbGljaXRseSBrbm93IGl0J3MgZGFya1xuICAgIGlmIChUaS5VSS51c2VySW50ZXJmYWNlU3R5bGUgPT09IFRpLlVJLlVTRVJfSU5URVJGQUNFX1NUWUxFX0RBUkspIHtcbiAgICAgIHJldHVybiBVSS5TRU1BTlRJQ19DT0xPUl9UWVBFX0RBUks7XG4gICAgfVxuICAgIHJldHVybiBVSS5TRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUO1xuICB9XG59KTtcblxuLy8gb24gQW5kcm9pZC9pT1MgPCAxMywgd2UgbmVlZCB0byByb2xsIG91ciBvd24gZmV0Y2hTZW1hbnRpY0NvbG9yIGltcGxcbi8vIG9uIGlPUyAxMyssIHdlIGhhdmUgYSBuYXRpdmUgdmVyc2lvblxuaWYgKCFpc0lPUzEzUGx1cyAmJiAhaXNNQUNPU1hDYXRhbGluYVBsdXMpIHtcbiAgLy8gT24gaU9TIDwgMTMsIHdlIGRvbid0IGhhdmUgdGhlIHRoZW1lIGNvbnN0YW50cyBkZWZpbmVkLCB3aGljaCBicmVha3Mgb3VyIHRlc3RzXG4gIGlmICghaXNNYWNPUykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ1VTRVJfSU5URVJGQUNFX1NUWUxFX1VOU1BFQ0lGSUVEJywge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVUksICdVU0VSX0lOVEVSRkFDRV9TVFlMRV9MSUdIVCcsIHtcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnVVNFUl9JTlRFUkZBQ0VfU1RZTEVfREFSSycsIHtcbiAgICAgIHZhbHVlOiAyLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gVHJlYXQgaU9TIDwgMTMgYXMgJ2xpZ2h0JyB0aGVtZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ3VzZXJJbnRlcmZhY2VTdHlsZScsIHtcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGNvbG9yc2V0O1xuICBVSS5mZXRjaFNlbWFudGljQ29sb3IgPSBmdW5jdGlvbiBmZXRjaFNlbWFudGljQ29sb3IoY29sb3JOYW1lKSB7XG4gICAgLy8gTG9hZCBhbGwgc2VtYW50aWMgY29sb3JzIGZyb20gSlNPTiBpZiBub3QgZG9uZSBhbHJlYWR5LlxuICAgIC8vIERvIHNvIHZpYSByZXF1aXJlKCkgaW4gY2FzZSB0aGlzIGZpbGUgd2FzIGNoYW5nZWQgd2hpbGUgcnVubmluZyBMaXZlVmlldy5cbiAgICBpZiAoIWNvbG9yc2V0KSB7XG4gICAgICBjb25zdCBjb2xvcnNldEZpbGVOYW1lID0gJ3NlbWFudGljLmNvbG9ycy5qc29uJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbG9yc2V0RmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSwgY29sb3JzZXRGaWxlTmFtZSk7XG4gICAgICAgIGlmIChjb2xvcnNldEZpbGUuZXhpc3RzKCkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLXJlcXVpcmVcbiAgICAgICAgICBjb2xvcnNldCA9IHJlcXVpcmUoYC8ke2NvbG9yc2V0RmlsZU5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIGNvbG9ycyBmaWxlICcke2NvbG9yc2V0RmlsZU5hbWV9J2ApO1xuICAgICAgICByZXR1cm4gY29sb3IuZmFsbGJhY2soKS50b0hleCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKGZhbHNlKSA7IGVsc2UgaWYgKGNvbG9yc2V0W2NvbG9yTmFtZV0pIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSByYXcgY29sb3Igc3RyaW5nIHZhbHVlIGZyb20gdGhlIFwic2VtYW50aWMuY29sb3JzLmpzb25cIi5cbiAgICAgICAgLy8gVXNlIHRoZSBtb3JlIGV4YWN0IHJnYmEgZnVuY3Rpb24gb3ZlciA4LWNoYXIgQVJHQiBoZXguIEhhcmQgdG8gY29udmVydCB0aGluZ3MgbGlrZSA3NSUgYWxwaGEgcHJvcGVybHkuXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gY29sb3JzZXRbY29sb3JOYW1lXVtVSS5zZW1hbnRpY0NvbG9yVHlwZV07XG4gICAgICAgIGNvbnN0IGNvbG9yT2JqID0gY29sb3IuZnJvbVNlbWFudGljQ29sb3JzRW50cnkoZW50cnkpO1xuICAgICAgICByZXR1cm4gY29sb3JPYmoudG9SR0JBU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb29rdXAgY29sb3IgZm9yICR7Y29sb3JOYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3IuZmFsbGJhY2soKS50b0hleCgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRpdGFuaXVtIFNES1xuICogQ29weXJpZ2h0IFRpRGV2LCBJbmMuIDA0LzA3LzIwMjItUHJlc2VudC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCwgT1NfSU9TICovXG57XG4gIGNvbnN0IHRhYiA9IFRpdGFuaXVtLlVJLmNyZWF0ZVRhYigpO1xuICBjb25zdCBUYWJQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFiKTtcbiAgVGFiUHJvdG90eXBlLnNldFdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdzsgLy8gZm9yd2FyZCB0byBzZXR0aW5nIHByb3BlcnR5XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgdGhlIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB0byB1c2UgdG8gcmVnaXN0ZXIgZm9yIGl0J3MgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciBmb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIHRoZSBsaXN0ZW5lciBjYWxsYmFjay9mdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICogQHBhcmFtIHtib29sZWFufSBwcmVwZW5kIHdoZXRoZXIgdG8gcHJlcGVuZCBvciBhcHBlbmQgdGhlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICovXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnROYW1lLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTsgLy8gaW5pdGlhbGl6ZSBpdFxuICB9XG4gIC8vIGlmIHRoZXJlJ3Mgc29tZW9uZSBsaXN0ZW5pbmcgdG8gJ25ld0xpc3RlbmVyJyBldmVudHMsIGVtaXQgdGhhdCAqKmJlZm9yZSoqIHdlIGFkZCB0aGUgbGlzdGVuZXIgKHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbilcbiAgaWYgKGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzLm5ld0xpc3RlbmVyKSB7XG4gICAgZW1pdHRlci5lbWl0KCduZXdMaXN0ZW5lcicsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgaWYgKHByZXBlbmQpIHtcbiAgICBldmVudExpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdID0gZXZlbnRMaXN0ZW5lcnM7XG5cbiAgLy8gQ2hlY2sgbWF4IGxpc3RlbmVycyBhbmQgc3BpdCBvdXQgd2FybmluZyBpZiA+XG4gIGNvbnN0IG1heCA9IGVtaXR0ZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gIGNvbnN0IGxlbmd0aCA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcbiAgaWYgKG1heCA+IDAgJiYgbGVuZ3RoID4gbWF4KSB7XG4gICAgY29uc3QgdyA9IG5ldyBFcnJvcihgUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAke2xlbmd0aH0gJHtldmVudE5hbWV9IGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRgKTtcbiAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICB3LmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHcudHlwZSA9IGV2ZW50TmFtZTtcbiAgICB3LmNvdW50ID0gbGVuZ3RoO1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcodyk7XG4gIH1cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5mdW5jdGlvbiBvbmNlV3JhcChlbWl0dGVyLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdGhpcy5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLndyYXBwZWRGdW5jKTsgLy8gcmVtb3ZlIG91cnNlbHZlc1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3MpOyAvLyB0aGVuIGZvcndhcmQgdGhlIGV2ZW50IGNhbGxiYWNrXG4gIH1cbiAgLy8gd2UgaGF2ZSB0byB1c2UgYmluZCB3aXRoIGEgY3VzdG9tICd0aGlzJywgYmVjYXVzZSBldmVudHMgZmlyZSB3aXRoICd0aGlzJyBwb2ludGluZyBhdCB0aGUgZW1pdHRlclxuICBjb25zdCB3cmFwcGVyVGhpcyA9IHtcbiAgICBlbWl0dGVyLFxuICAgIGV2ZW50TmFtZSxcbiAgICBsaXN0ZW5lclxuICB9O1xuICBjb25zdCBib3VuZCA9IHdyYXBwZXIuYmluZCh3cmFwcGVyVGhpcyk7IC8vIGJpbmQgdG8gZm9yY2UgXCJ0aGlzXCIgdG8gcmVmZXIgdG8gb3VyIGN1c3RvbSBvYmplY3QgdHJhY2tpbmcgdGhlIHdyYXBwZXIvZW1pdHRlci9saXN0ZW5lclxuICBib3VuZC5saXN0ZW5lciA9IGxpc3RlbmVyOyAvLyBoYXZlIHRvIGFkZCBsaXN0ZW5lciBwcm9wZXJ0eSBmb3IgXCJ1bndyYXBwaW5nXCJcbiAgd3JhcHBlclRoaXMud3JhcHBlZEZ1bmMgPSBib3VuZDtcbiAgcmV0dXJuIGJvdW5kO1xufVxuXG4vLyBtYW55IGNvbnN1bWVycyBtYWtlIHVzZSBvZiB0aGlzIHZpYSB1dGlsLmluaGVyaXRzLCB3aGljaCBkb2VzIG5vdCBjaGFpbiBjb25zdHJ1Y3RvciBjYWxscyFcbi8vIHNvIHdlIG5lZWQgdG8gYmUgYXdhcmUgdGhhdCBfZXZlbnRzVG9MaXN0ZW5lcnMgbWF5ZSBiZSBudWxsL3VuZGVmaW5lZCBvbiBpbnN0YW5jZXMsIGFuZCBjaGVjayBpbiBtZXRob2RzIGJlZm9yZSBhY2Nlc3NpbmcgaXRcbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgcHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICB9XG4gIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMub24oZXZlbnROYW1lLCBvbmNlV3JhcCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgcHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBvbmNlV3JhcCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBldmVudExpc3RlbmVycy5sZW5ndGg7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICBsZXQgdW53cmFwcGVkTGlzdGVuZXI7XG4gICAgLy8gTmVlZCB0byBzZWFyY2ggTElGTywgYW5kIG5lZWQgdG8gaGFuZGxlIHdyYXBwZWQgZnVuY3Rpb25zIChvbmNlIHdyYXBwZXJzKVxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGV2ZW50TGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIHVud3JhcHBlZExpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcnNbaV0ubGlzdGVuZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gbGVuZ3RoIHdhcyAxIGFuZCB3ZSB3YW50IHRvIHJlbW92ZSBsYXN0IGVudHJ5LCBzbyBkZWxldGUgdGhlIGV2ZW50IHR5cGUgZnJvbSBvdXIgbGlzdGVuZXIgbWFwcGluZyBub3chXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgaGFkIDIrIGxpc3RlbmVycywgc28gc3RvcmUgYXJyYXkgd2l0aG91dCB0aGlzIGdpdmVuIGxpc3RlbmVyXG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLnNwbGljZShmb3VuZEluZGV4LCAxKTsgLy8gbW9kaWZpZXMgaW4gcGxhY2UsIG5vIG5lZWQgdG8gYXNzaWduIHRvIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV1cbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGVtaXQgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgZm9yICdyZW1vdmVMaXN0ZW5lcicgdHlwZSFcbiAgICAgIGlmICh0aGlzLl9ldmVudHNUb0xpc3RlbmVycy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgZXZlbnROYW1lLCB1bndyYXBwZWRMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgZW1pdChldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGV2ZW50TGlzdGVuZXJzLnNsaWNlKCkpIHtcbiAgICAgIC8vIG11c3Qgb3BlcmF0ZSBvbiBjb3B5IGJlY2F1c2UgbGlzdGVuZXJzICxheSBnZXQgcmVtb3ZlIGFzIHNpZGUtZWZmZWN0IG9mIGNhbGxpbmdcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBldmVudExpc3RlbmVycy5sZW5ndGggIT09IDA7XG4gIH1cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcbiAgfVxuICBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9ldmVudHNUb0xpc3RlbmVycyB8fCB7fSk7XG4gIH1cbiAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBOZWVkIHRvIFwidW53cmFwXCIgb25jZSB3cmFwcGVycyFcbiAgICBjb25zdCByYXcgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHJldHVybiByYXcubWFwKGwgPT4gbC5saXN0ZW5lciB8fCBsKTsgLy8gaGVyZSB3ZSB1bndyYXAgdGhlIG9uY2Ugd3JhcHBlciBpZiB0aGVyZSBpcyBvbmUgb3IgZmFsbCBiYWNrIHRvIGxpc3RlbmVyIGZ1bmN0aW9uXG4gIH1cblxuICByYXdMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXSkuc2xpY2UoMCk7IC8vIHJldHVybiBhIGNvcHlcbiAgfVxuXG4gIGdldE1heExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9XG4gIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjsgLy8gVE9ETzogVHlwZSBjaGVjayBuLCBtYWtlIHN1cmUgPj0gMCAobyBlcXVhbHMgbm8gbGltaXQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTsgLy8gaW5pdGlhbGl6ZSBpdFxuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gZW1pdCEgd2UgY2FuIGp1c3Qgd2lwZSFcbiAgICAgIGlmIChldmVudE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZW1vdmUgZXZlcnkgdHlwZSFcbiAgICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBzcGVjaWZpYyB0eXBlXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8geXVjaywgd2UnbGwgaGF2ZSB0byBlbWl0ICdyZW1vdmVMaXN0ZW5lcicgZXZlbnRzIGFzIHdlIGdvXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW1vdmUgYWxsIHR5cGVzIChidXQgZG8gJ3JlbW92ZUxpc3RlbmVyJyBsYXN0ISlcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpLmZpbHRlcihuYW1lID0+IG5hbWUgIT09ICdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG5hbWUpKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVycyBmb3Igb25lIHR5cGUsIGJhY2sgdG8gZnJvbnQgKExhc3QtaW4sIGZpcnN0LW91dCwgZXhjZXB0IHdoZXJlIHByZXBlbmQgZi1lZCBpdCB1cClcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgICBmb3IgKGxldCBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIGV2ZW50TmFtZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XG59O1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLyoqXG4gKiBAcGFyYW0gIHsqfSBhcmcgcGFzc2VkIGluIGFyZ3VtZW50IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZW5hbWUgaS5lLiAnc3RyaW5nJywgJ0Z1bmN0aW9uJyAodmFsdWUgaXMgY29tcGFyZWQgdG8gdHlwZW9mIGFmdGVyIGxvd2VyY2FzaW5nKVxuICogQHJldHVybiB7dm9pZH1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRUeXBlKGFyZywgbmFtZSwgdHlwZW5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSB0eXBlbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSAke3R5cGVuYW1lfS4gUmVjZWl2ZWQgdHlwZSAke3R5cGV9YCk7XG4gIH1cbn1cblxuLy8gU3RhcnQgb3VyIHByb2Nlc3MgdXB0aW1lIHRpbWVyIGltbWVkaWF0ZWx5IVxuY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uICdzdGFuZGFyZGl6ZXMnIHRoZSByZXBvcnRlZCBhcmNoaXRlY3R1cmVzIHRvIHRoZSBlcXVpdmFsZW50cyByZXBvcnRlZCBieSBOb2RlLmpzXG4gKiBub2RlIHZhbHVlczogJ2FybScsICdhcm02NCcsICdpYTMyJywgJ21pcHMnLCAnbWlwc2VsJywgJ3BwYycsICdwcGM2NCcsICdzMzkwJywgJ3MzOTB4JywgJ3gzMicsIGFuZCAneDY0Jy5cbiAqIGlPUyB2YWx1ZXM6IFwiYXJtNjRcIiwgXCJhcm12N1wiLCBcIng4Nl82NFwiLCBcImkzODZcIiwgXCJVbmtub3duXCJcbiAqIEFuZHJvaWQgdmFsdWVzOiBcImFybWVhYmlcIiwgXCJhcm1lYWJpLXY3YVwiLCBcImFybTY0LXY4YVwiLCBcIng4NlwiLCBcIng4Nl82NFwiLCBcIm1pcHNcIiwgXCJtaXBzNjRcIiwgXCJ1bmtub3duXCJcbiAqIFdpbmRvd3MgdmFsdWVzOiBcIng2NFwiLCBcImlhNjRcIiwgXCJBUk1cIiwgXCJ4ODZcIiwgXCJ1bmtub3duXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbCBvcmlnaW5hbCBhcmNoaXRlY3R1cmUgcmVwb3J0ZWQgYnkgVGkuUGxhdGZvcm1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQXJjaChvcmlnaW5hbCkge1xuICBzd2l0Y2ggKG9yaWdpbmFsKSB7XG4gICAgLy8gY29lcmNlICdhcm12NycsICdhcm1lYWJpJywgJ2FybWVhYmktdjdhJywgJ0FSTScgLT4gJ2FybSdcbiAgICAvLyAnYXJtZWFiaScgaXMgYSBkZWFkIEFCSSBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG4gICAgY2FzZSAnYXJtdjcnOlxuICAgIGNhc2UgJ2FybWVhYmknOlxuICAgIGNhc2UgJ2FybWVhYmktdjdhJzpcbiAgICBjYXNlICdBUk0nOlxuICAgICAgcmV0dXJuICdhcm0nO1xuXG4gICAgLy8gY29lcmNlICdhcm02NC12OGEnIC0+ICdhcm02NCdcbiAgICBjYXNlICdhcm02NC12OGEnOlxuICAgICAgcmV0dXJuICdhcm02NCc7XG5cbiAgICAvLyBjb2VyY2UgJ2kzODYnLCAneDg2JyAtPiAnaWEzMidcbiAgICBjYXNlICdpMzg2JzpcbiAgICBjYXNlICd4ODYnOlxuICAgICAgcmV0dXJuICdpYTMyJztcblxuICAgIC8vIGNvZXJjZSAneDg2XzY0JywgJ2lhNjQnLCAneDY0JyAtPiAneDY0J1xuICAgIGNhc2UgJ3g4Nl82NCc6XG4gICAgY2FzZSAnaWE2NCc6XG4gICAgICByZXR1cm4gJ3g2NCc7XG5cbiAgICAvLyBjb2VyY2UgJ21pcHM2NCcgLT4gJ21pcHMnIC8vICdtaXBzJyBhbmQgJ21pcHM2NCcgYXJlIGRlYWQgQUJJcyBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG4gICAgY2FzZSAnbWlwczY0JzpcbiAgICAgIHJldHVybiAnbWlwcyc7XG5cbiAgICAvLyBjb2VyY2UgJ1Vua25vd24nIC0+ICd1bmtub3duJ1xuICAgIGNhc2UgJ1Vua25vd24nOlxuICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG59XG5jb25zdCBwcm9jZXNzJDEgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5wcm9jZXNzJDEuYWJvcnQgPSAoKSA9PiB7fTsgLy8gVE9ETzogRG8gd2UgaGF2ZSBlcXVpdmFsZW50IG9mIGZvcmNpYmx5IGtpbGxpbmcgdGhlIHByb2Nlc3M/IFdlIGhhdmUgcmVzdGFydCwgYnV0IEkgdGhpbmsgd2UganVzdCB3YW50IGEgbm8tb3Agc3R1YiBoZXJlXG5wcm9jZXNzJDEuYXJjaCA9IHN0YW5kYXJkaXplQXJjaChUaS5QbGF0Zm9ybS5hcmNoaXRlY3R1cmUpO1xucHJvY2VzcyQxLmFyZ3YgPSBbXTsgLy8gVE9ETzogV2hhdCBtYWtlcyBzZW5zZSBoZXJlPyBwYXRoIHRvIHRpdGFuaXVtIGNsaSBmb3IgZmlyc3QgYXJnPyBwYXRoIHRvIHRpLm1haW4vYXBwLmpzIGZvciBzZWNvbmQ/XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQxLCAnYXJndjAnLCB7XG4gIHZhbHVlOiAnJyxcbiAgLy8gVE9ETzogUGF0aCB0byAuYXBwIG9uIGlPUz9cbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcbnByb2Nlc3MkMS5iaW5kaW5nID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyB1bnN1cHBvcnRlZCBhbmQgbm90IHVzZXItZmFjaW5nIEFQSScpO1xufTtcbnByb2Nlc3MkMS5jaGFubmVsID0gdW5kZWZpbmVkO1xucHJvY2VzcyQxLmNoZGlyID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgdW5zdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzJDEuY29uZmlnID0ge307XG5wcm9jZXNzJDEuY29ubmVjdGVkID0gZmFsc2U7XG5wcm9jZXNzJDEuY3B1VXNhZ2UgPSAoKSA9PiB7XG4gIC8vIEZJWE1FOiBDYW4gd2UgbG9vayBhdCBPUy5jcHVzIHRvIGdldCB0aGlzIGRhdGE/XG4gIHJldHVybiB7XG4gICAgdXNlcjogMCxcbiAgICBzeXN0ZW06IDBcbiAgfTtcbn07XG5wcm9jZXNzJDEuY3dkID0gKCkgPT4gX19kaXJuYW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkMSwgJ2RlYnVnUG9ydCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHZhbHVlID0gMDsgLy8gZGVmYXVsdCB0byAwXG4gICAgdHJ5IHtcbiAgICAgIGlmIChUaS5QbGF0Zm9ybS5vc25hbWUgPT09ICdhbmRyb2lkJykge1xuICAgICAgICBjb25zdCBhc3NldHMgPSBrcm9sbC5iaW5kaW5nKCdhc3NldHMnKTtcbiAgICAgICAgY29uc3QganNvbiA9IGFzc2V0cy5yZWFkQXNzZXQoJ2RlcGxveS5qc29uJyk7XG4gICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgY29uc3QgZGVwbG95RGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgaWYgKGRlcGxveURhdGEuZGVidWdnZXJQb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gLTEgbWVhbnMgbm90IHNldCAobm90IGluIGRlYnVnIG1vZGUpXG4gICAgICAgICAgICB2YWx1ZSA9IGRlcGxveURhdGEuZGVidWdnZXJQb3J0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cnVlKSB7XG4gICAgICAgIC8vIGlPUyBpcyAyNzc1MyBhcyBvZiBpb3MgPCAxMS4zIGZvciBzaW11bGF0b3JzXG4gICAgICAgIC8vIGZvciAxMS4zKyBpdCB1c2VzIGEgdW5peCBzb2NrZXRcbiAgICAgICAgLy8gZm9yIGRldmljZXMsIGl0IHVzZXMgdXNibXV4ZFxuICAgICAgICB2YWx1ZSA9IDI3NzUzOyAvLyBUT0RPOiBDYW4gd2Ugb25seSByZXR1cm4gdGhpcyBmb3Igc2ltdWxhdG9yIDwgMTEuMz9cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gaWdub3JlXG4gICAgfVxuICAgIC8vIG92ZXJ3cml0ZSB0aGlzIGdldHRlciB3aXRoIHN0YXRpYyB2YWx1ZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVidWdQb3J0Jywge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xucHJvY2VzcyQxLmRpc2Nvbm5lY3QgPSAoKSA9PiB7fTsgLy8gbm8tb3BcbnByb2Nlc3MkMS5kbG9wZW4gPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5kbG9wZW4gaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MkMS5lbWl0V2FybmluZyA9IGZ1bmN0aW9uICh3YXJuaW5nLCBvcHRpb25zLCBjb2RlLCBjdG9yKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgbGV0IHR5cGU7XG4gIGxldCBkZXRhaWw7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICB0eXBlID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIGNvZGUgPSBvcHRpb25zLmNvZGU7XG4gICAgZGV0YWlsID0gb3B0aW9ucy5kZXRhaWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB3YXJuaW5nID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IG1ha2UgdXNlIG9mIGBjdG9yYCBhcmcgZm9yIGxpbWl0aW5nIHN0YWNrIHRyYWNlcz8gQ2FuIG9ubHkgcmVhbGx5IGJlIHVzZWQgb24gVjhcbiAgICAvLyBzZXQgc3RhY2sgdHJhY2UgbGltaXQgdG8gMCwgdGhlbiBjYWxsIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHdhcm5pbmcsIGN0b3IpO1xuICAgIHdhcm5pbmcgPSBuZXcgRXJyb3Iod2FybmluZyk7XG4gICAgd2FybmluZy5uYW1lID0gdHlwZSB8fCAnV2FybmluZyc7XG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybmluZy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgaWYgKGRldGFpbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nLmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG4gIH1cbiAgLy8gVE9ETzogVGhyb3cgVHlwZUVycm9yIGlmIG5vdCBhbiBpbnN0YW5jZW9mIEVycm9yIGF0IHRoaXMgcG9pbnQhXG4gIGNvbnN0IGlzRGVwcmVjYXRpb24gPSB3YXJuaW5nLm5hbWUgPT09ICdEZXByZWNhdGlvbldhcm5pbmcnO1xuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDEubm9EZXByZWNhdGlvbikge1xuICAgIHJldHVybjsgLy8gaWdub3JlXG4gIH1cblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDEudGhyb3dEZXByZWNhdGlvbikge1xuICAgIHRocm93IHdhcm5pbmc7XG4gIH1cbiAgdGhpcy5lbWl0KCd3YXJuaW5nJywgd2FybmluZyk7XG59O1xuZnVuY3Rpb24gbG9hZEVudkpzb24oKSB7XG4gIHRyeSB7XG4gICAgY29uc3QganNvbkZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksICdfZW52Xy5qc29uJyk7XG4gICAgaWYgKGpzb25GaWxlLmV4aXN0cygpKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uRmlsZS5yZWFkKCkudGV4dCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRpLkFQSS5lcnJvcihgRmFpbGVkIHRvIHJlYWQgXCJfZW52Xy5qc29uXCIuIFJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiB7fTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzJDEsICdlbnYnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGRlbGV0ZSB0aGlzLmVudjtcbiAgICByZXR1cm4gdGhpcy5lbnYgPSBsb2FkRW52SnNvbigpO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xucHJvY2VzcyQxLmV4ZWNBcmd2ID0gW107XG5wcm9jZXNzJDEuZXhlY1BhdGggPSAnJzsgLy8gRklYTUU6IFdoYXQgbWFrZXMgc2Vuc2UgaGVyZT8gUGF0aCB0byB0aXRhbml1bSBDTEkgaGVyZT9cbnByb2Nlc3MkMS5leGl0ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuZXhpdCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2VzcyQxLmV4aXRDb2RlID0gdW5kZWZpbmVkO1xucHJvY2VzcyQxLm5vRGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkMS5waWQgPSAwO1xuLy8gRklYTUU6IFNob3VsZCB3ZSB0cnkgYW5kIGFkb3B0ICdpcGFkJy8naXBob25lJyB0byAnZGFyd2luJz8gb3IgJ2lvcyc/XG5wcm9jZXNzJDEucGxhdGZvcm0gPSBUaS5QbGF0Zm9ybS5vc25hbWU7XG5wcm9jZXNzJDEucHBpZCA9IDA7XG4vLyBUT0RPOiBBZGQgcmVsZWFzZSBwcm9wZXJ0eSAoT2JqZWN0KVxuLy8gVE9ETzogQ2FuIHdlIGV4cG9zZSBzdGRvdXQvc3RkZXJyL3N0ZGluIG5hdGl2ZWx5P1xuLy8gRG9uJ3Qgd3JhcCBjb25zb2xlLmxvZy9lcnJvciBiZWNhdXNlIHRlY2huaWNhbGx5IGdsb2JhbCBjb25zb2xlIHdyYXBzIHByb2Nlc3Muc3Rkb3V0L3N0ZGVyciAob3Igc2hvdWxkKVxucHJvY2VzcyQxLnN0ZGVyciA9IHtcbiAgaXNUVFk6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgVGkuQVBJLmVycm9yKGNodW5rKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xucHJvY2VzcyQxLnN0ZG91dCA9IHtcbiAgaXNUVFk6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgVGkuQVBJLmluZm8oY2h1bmspO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDEudGl0bGUgPSBUaS5BcHAubmFtZTtcbnByb2Nlc3MkMS50aHJvd0RlcHJlY2F0aW9uID0gZmFsc2U7XG5wcm9jZXNzJDEudHJhY2VEZXByZWNhdGlvbiA9IGZhbHNlO1xucHJvY2VzcyQxLnVtYXNrID0gKCkgPT4gMDsgLy8ganVzdCBhbHdheXMgcmV0dXJuIDBcbnByb2Nlc3MkMS51cHRpbWUgPSAoKSA9PiB7XG4gIGNvbnN0IGRpZmZNcyA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIHJldHVybiBkaWZmTXMgLyAxMDAwLjA7IC8vIGNvbnZlcnQgdG8gXCJzZWNvbmRzXCIgd2l0aCBmcmFjdGlvbnNcbn07XG5cbnByb2Nlc3MkMS52ZXJzaW9uID0gXCIxMi43LjFcIjtcbnByb2Nlc3MkMS52ZXJzaW9ucyA9IHtcbiAgbW9kdWxlczogJycsXG4gIC8vIFRPRE86IFJlcG9ydCBtb2R1bGUgYXBpIHZlcnNpb24gKGZvciBjdXJyZW50IHBsYXRmb3JtISlcbiAgdjg6ICcnLFxuICAvLyBUT0RPOiByZXBvcnQgYW5kcm9pZCdzIHY4IHZlcnNpb24gKGlmIG9uIEFuZHJvaWQhKVxuICBqc2M6ICcnIC8vIFRPRE86IHJlcG9ydCBqYXZhc2NyaXB0Y29yZSB2ZXJzaW9uIGZvciBpT1MvV0luZG93cz9cbiAgLy8gVE9ETzogUmVwb3J0IGlvcy9BbmRyb2lkL1dpbmRvd3MgcGxhdGZvcm0gdmVyc2lvbnM/XG59O1xuXG5wcm9jZXNzJDFbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdwcm9jZXNzJztcbmdsb2JhbC5wcm9jZXNzID0gcHJvY2VzcyQxO1xuLy8gaGFuZGxlIHNwaXR0aW5nIG91dCB3YXJuaW5nc1xuY29uc3QgV0FSTklOR19QUkVGSVggPSBgKHRpdGFuaXVtOiR7cHJvY2VzcyQxLnBpZH0pIGA7XG5wcm9jZXNzJDEub24oJ3dhcm5pbmcnLCB3YXJuaW5nID0+IHtcbiAgY29uc3QgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7XG4gIC8vIGlmIHdlJ3JlIG5vdCBkb2luZyBkZXByZWNhdGlvbnMsIGlnbm9yZSFcbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogQ2hlY2sgcHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uIGFuZCBpZiBzZXQsIGluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gbWVzc2FnZSFcbiAgbGV0IG1zZyA9IFdBUk5JTkdfUFJFRklYO1xuICBpZiAod2FybmluZy5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtc2cgKz0gYFske3dhcm5pbmcuY29kZX1dIGA7XG4gIH1cbiAgaWYgKHdhcm5pbmcudG9TdHJpbmcpIHtcbiAgICBtc2cgKz0gd2FybmluZy50b1N0cmluZygpO1xuICB9XG4gIGlmICh3YXJuaW5nLmRldGFpbCkge1xuICAgIG1zZyArPSBgXFxuJHt3YXJuaW5nLmRldGFpbH1gO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcbn0pO1xubGV0IHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xucHJvY2VzcyQxLmhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrID0gKCkgPT4gdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayAhPT0gbnVsbDtcbnByb2Nlc3MkMS5zZXRVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjayA9IGZuID0+IHtcbiAgaWYgKGZuID09PSBudWxsKSB7XG4gICAgdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ2Z1bmN0aW9uJyk7XG4gIGlmICh1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvY2Vzcy5zZXRVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjaygpYCB3YXMgY2FsbGVkIHdoaWxlIGEgY2FwdHVyZSBjYWxsYmFjayB3YXMgYWxyZWFkeSBhY3RpdmUnKTtcbiAgfVxuICB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrID0gZm47XG59O1xuVGkuQXBwLmFkZEV2ZW50TGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIENyZWF0ZSBhbiBFcnJvciBpbnN0YW5jZSB0aGF0IHdyYXBzIHRoZSBkYXRhIGZyb20gdGhlIGV2ZW50XG4gIC8vIGlkZWFsbHkgd2UnZCBqdXN0IGZvcndhcmQgYWxvbmcgdGhlIG9yaWdpbmFsIEVycm9yIVxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihldmVudC5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBldmVudC5iYWNrdHJhY2U7XG4gIGVycm9yLmZpbGVOYW1lID0gZXZlbnQuc291cmNlTmFtZTtcbiAgZXJyb3IubGluZU51bWJlciA9IGV2ZW50LmxpbmU7XG4gIGVycm9yLmNvbHVtbk51bWJlciA9IGV2ZW50LmxpbmVPZmZzZXQ7XG4gIGlmIChwcm9jZXNzJDEuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2soKSkge1xuICAgIHJldHVybiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrKGVycm9yKTtcbiAgfVxuICAvLyBvdGhlcndpc2UgZm9yd2FyZCB0aGUgZXZlbnQhXG4gIHByb2Nlc3MkMS5lbWl0KCd1bmNhdWdodEV4Y2VwdGlvbicsIGVycm9yKTtcbn0pO1xuXG4vLyBVc2UgYSBuaWNlIHByZWRpY3RhYmxlIGNsYXNzL3N0cnVjdHVyZSBmb3Igb3VyIEltbWVkaWF0ZS9UaWNrIFwidGltZXJzXCJcbi8vIEpTIGVuZ2luZSBzaG91bGQgYmUgYWJsZSB0byBvcHRpbWl6ZSBlYXNpZXJcbmNsYXNzIENhbGxiYWNrV2l0aEFyZ3Mge1xuICBjb25zdHJ1Y3RvcihmdW5jLCBhcmdzKSB7XG4gICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG4gIHJ1bigpIHtcbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLmZ1bmMuYXBwbHkobnVsbCwgdGhpcy5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mdW4oKTtcbiAgICB9XG4gIH1cbn1cbi8vIG5leHRUaWNrIHZzIHNldEltbWVkaWF0ZSBzaG91bGQgYmUgaGFuZGxlZCBpbiBhIHNlbWktc21hcnQgd2F5XG4vLyBCYXNpY2FsbHkgbmV4dFRpY2sgbmVlZHMgdG8gZHJhaW4gdGhlIGZ1bGwgcXVldWUgKGFuZCBjYW4gY2F1c2UgaW5maW5pdGUgbG9vcHMgaWYgbmV4dFRpY2sgY2FsbGJhY2sgY2FsbHMgbmV4dFRpY2shKVxuLy8gVGhlbiB3ZSBzaG91bGQgZ28gdGhyb3VnaCB0aGUgXCJpbW1lZGlhdGVcIiBxdWV1ZVxuLy8gaHR0cDovL3BsYWZlci5naXRodWIuaW8vMjAxNS8wOS8wOC9uZXh0VGljay12cy1zZXRJbW1lZGlhdGUvXG5jb25zdCB0aWNrUXVldWUgPSBbXTtcbmNvbnN0IGltbWVkaWF0ZVF1ZXVlID0gW107XG5sZXQgZHJhaW5pbmdUaWNrUXVldWUgPSBmYWxzZTtcbmxldCBkcmFpblF1ZXVlc1RpbWVvdXQgPSBudWxsO1xuXG4vKipcbiAqIEl0ZXJhdGl2ZWx5IHJ1bnMgYWxsIFwidGlja3NcIiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZS5cbiAqIFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbiBpZiBhIHRpY2sgc2NoZWR1bGVzIGFub3RoZXIgZm9yZXZlci5cbiAqL1xuZnVuY3Rpb24gZHJhaW5UaWNrUXVldWUoKSB7XG4gIGlmIChkcmFpbmluZ1RpY2tRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkcmFpbmluZ1RpY2tRdWV1ZSA9IHRydWU7XG4gIHdoaWxlICh0aWNrUXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3QgdGljayA9IHRpY2tRdWV1ZS5zaGlmdCgpO1xuICAgIHRpY2sucnVuKCk7XG4gIH1cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYWluUXVldWVzKCkge1xuICAvLyBkcmFpbiB0aGUgZnVsbCB0aWNrIHF1ZXVlIGZpcnN0Li4uXG4gIGRyYWluVGlja1F1ZXVlKCk7XG4gIC8vIHRpY2sgcXVldWUgc2hvdWxkIGJlIGVtcHR5IVxuICBjb25zdCBpbW1lZGlhdGVzUmVtYWluaW5nID0gcHJvY2Vzc0ltbWVkaWF0ZVF1ZXVlKCk7XG4gIGlmIChpbW1lZGlhdGVzUmVtYWluaW5nICE9PSAwKSB7XG4gICAgLy8gcmUtc2NoZWR1bGUgZHJhaW5pbmcgb3VyIHF1ZXVlcywgYXMgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgbW9yZSBcImltbWVkaWF0ZVwiIHRvIGhhbmRsZVxuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9IGVsc2Uge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBwcm9jZXNzIFwiaW1tZWRpYXRlc1wiIChpbiBhIG11Y2ggbW9yZSBsZWlzdXJlbHkgd2F5IHRoYW4gdGlja3MpXG4gKiBXZSBnaXZlIGEgMTAwbXMgd2luZG93IHRvIHJ1biB0aGVtIGluIGJlZm9yZSByZS1zY2hlZHVsaW5nIHRoZSB0aW1lb3V0IHRvIHByb2Nlc3MgdGhlbSBhZ2Fpbi5cbiAqIElmIGFueSB0aWNrcyBhcmUgYWRkZWQgZHVyaW5nIGludm9jYXRpb24gb2YgaW1tZWRpYXRlLCB3ZSBkcmFpbiB0aGUgdGljayBxdWV1ZSBmdWxseSBiZWZvcmVcbiAqIHByb2NlZWRpbmcgdG8gbmV4dCBpbW1lZGlhdGUgKGlmIHdlIHN0aWxsIGhhdmUgdGltZSBpbiBvdXIgd2luZG93KS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IG51bWJlciBvZiByZW1haW5pbmcgaW1tZWRpYXRlcyB0byBiZSBwcm9jZXNzZWRcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0ltbWVkaWF0ZVF1ZXVlKCkge1xuICBjb25zdCBpbW1lZGlhdGVEZWFkbGluZSA9IERhdGUubm93KCkgKyAxMDA7IC8vIGdpdmUgdXMgdXAgdG8gMTAwbXMgdG8gcHJvY2VzcyBpbW1lZGlhdGVzXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgRGF0ZS5ub3coKSA8IGltbWVkaWF0ZURlYWRsaW5lKSB7XG4gICAgY29uc3QgaW1tZWRpYXRlID0gaW1tZWRpYXRlUXVldWUuc2hpZnQoKTtcbiAgICBpbW1lZGlhdGUucnVuKCk7XG4gICAgaWYgKHRpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyB0aGV5IGFkZGVkIGEgdGljayEgZHJhaW4gdGhlIHRpY2sgcXVldWUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2UgKHRoaXMgKm1heSogZWF0IHVwIG91ciBkZWFkbGluZS93aW5kb3cgdG8gcHJvY2VzcyBhbnkgbW9yZSBpbW1lZGlhdGVzKVxuICAgICAgZHJhaW5UaWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltbWVkaWF0ZVF1ZXVlLmxlbmd0aDtcbn1cbnByb2Nlc3MkMS5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY2FsbGJhY2ssICdjYWxsYmFjaycsICdmdW5jdGlvbicpO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdGlja1F1ZXVlLnB1c2gobmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpKTtcbiAgaWYgKCFkcmFpblF1ZXVlc1RpbWVvdXQpIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfVxufTtcbmdsb2JhbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIGNvbnN0IGltbWVkaWF0ZSA9IG5ldyBDYWxsYmFja1dpdGhBcmdzKGNhbGxiYWNrLCBhcmdzKTtcbiAgaW1tZWRpYXRlUXVldWUucHVzaChpbW1lZGlhdGUpO1xuICBpZiAoIWRyYWluUXVldWVzVGltZW91dCkge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9XG4gIHJldHVybiBpbW1lZGlhdGU7XG59O1xuZ2xvYmFsLmNsZWFySW1tZWRpYXRlID0gZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICBjb25zdCBpbmRleCA9IGltbWVkaWF0ZVF1ZXVlLmluZGV4T2YoaW1tZWRpYXRlKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGltbWVkaWF0ZVF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbmNvbnN0IEZPUldBUkRfU0xBU0ggPSA0NzsgLy8gJy8nXG5jb25zdCBCQUNLV0FSRF9TTEFTSCA9IDkyOyAvLyAnXFxcXCdcblxuLyoqXG4gKiBJcyB0aGlzIFthLXpBLVpdP1xuICogQHBhcmFtICB7bnVtYmVyfSAgY2hhckNvZGUgdmFsdWUgZnJvbSBTdHJpbmcuY2hhckNvZGVBdCgpXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93c0RldmljZU5hbWUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDkwIHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEyMjtcbn1cblxuLyoqXG4gKiBbaXNBYnNvbHV0ZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IGlzUG9zaXggd2hldGhlciB0aGlzIGltcGwgaXMgZm9yIFBPU0lYIG9yIG5vdFxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBpc0Fic29sdXRlKGlzUG9zaXgsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIGNvbnN0IGxlbmd0aCA9IGZpbGVwYXRoLmxlbmd0aDtcbiAgLy8gZW1wdHkgc3RyaW5nIHNwZWNpYWwgY2FzZVxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIGlmIChmaXJzdENoYXIgPT09IEZPUldBUkRfU0xBU0gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB3ZSBhbHJlYWR5IGRpZCBvdXIgY2hlY2tzIGZvciBwb3NpeFxuICBpZiAoaXNQb3NpeCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyB3aW4zMiBmcm9tIGhlcmUgb24gb3V0XG4gIGlmIChmaXJzdENoYXIgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDIgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXIpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgY29uc3QgdGhpcmRDaGFyID0gZmlsZXBhdGguY2hhckF0KDIpO1xuICAgIHJldHVybiB0aGlyZENoYXIgPT09ICcvJyB8fCB0aGlyZENoYXIgPT09ICdcXFxcJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogW2Rpcm5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGRpcm5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuICBsZXQgZnJvbUluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgY29uc3QgaGFkVHJhaWxpbmcgPSBmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpO1xuICBpZiAoaGFkVHJhaWxpbmcpIHtcbiAgICBmcm9tSW5kZXgtLTtcbiAgfVxuICBjb25zdCBmb3VuZEluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2Yoc2VwYXJhdG9yLCBmcm9tSW5kZXgpO1xuICAvLyBubyBzZXBhcmF0b3JzXG4gIGlmIChmb3VuZEluZGV4ID09PSAtMSkge1xuICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2Ygcm9vdCB3aW5kb3dzIHBhdGhzXG4gICAgaWYgKGxlbmd0aCA+PSAyICYmIHNlcGFyYXRvciA9PT0gJ1xcXFwnICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgICBjb25zdCBmaXJzdENoYXIgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyKSkge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7IC8vIGl0J3MgYSByb290IHdpbmRvd3MgcGF0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnLic7XG4gIH1cbiAgLy8gb25seSBmb3VuZCByb290IHNlcGFyYXRvclxuICBpZiAoZm91bmRJbmRleCA9PT0gMCkge1xuICAgIHJldHVybiBzZXBhcmF0b3I7IC8vIGlmIGl0IHdhcyAnLycsIHJldHVybiB0aGF0XG4gIH1cbiAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBvZiAnLy9zb21ldGhpbmcnXG4gIGlmIChmb3VuZEluZGV4ID09PSAxICYmIHNlcGFyYXRvciA9PT0gJy8nICYmIGZpbGVwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvLyc7XG4gIH1cbiAgcmV0dXJuIGZpbGVwYXRoLnNsaWNlKDAsIGZvdW5kSW5kZXgpO1xufVxuXG4vKipcbiAqIFtleHRuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBleHRuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgaW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpO1xuICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8vIGlnbm9yZSB0cmFpbGluZyBzZXBhcmF0b3JcbiAgbGV0IGVuZEluZGV4ID0gZmlsZXBhdGgubGVuZ3RoO1xuICBpZiAoZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKSkge1xuICAgIGVuZEluZGV4LS07XG4gIH1cbiAgcmV0dXJuIGZpbGVwYXRoLnNsaWNlKGluZGV4LCBlbmRJbmRleCk7XG59XG5mdW5jdGlvbiBsYXN0SW5kZXhXaW4zMlNlcGFyYXRvcihmaWxlcGF0aCwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGluZGV4OyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGNoYXIgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyID09PSBCQUNLV0FSRF9TTEFTSCB8fCBjaGFyID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFtiYXNlbmFtZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHBhcmFtICB7c3RyaW5nfSBbZXh0XSAgICAgIGZpbGUgZXh0ZW5zaW9uIHRvIGRyb3AgaWYgaXQgZXhpc3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBiYXNlbmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoLCBleHQpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0QXJndW1lbnRUeXBlKGV4dCwgJ2V4dCcsICdzdHJpbmcnKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nO1xuICBsZXQgZW5kSW5kZXggPSBsZW5ndGg7XG4gIC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIChpZiB0aGVyZSBpcyBvbmUpXG4gIGNvbnN0IGxhc3RDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSk7XG4gIGlmIChsYXN0Q2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgIWlzUG9zaXggJiYgbGFzdENoYXJDb2RlID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIGVuZEluZGV4LS07XG4gIH1cblxuICAvLyBGaW5kIGxhc3Qgb2NjdXJlbmNlIG9mIHNlcGFyYXRvclxuICBsZXQgbGFzdEluZGV4ID0gLTE7XG4gIGlmIChpc1Bvc2l4KSB7XG4gICAgbGFzdEluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2Yoc2VwYXJhdG9yLCBlbmRJbmRleCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uIHdpbjMyLCBoYW5kbGUgKmVpdGhlciogc2VwYXJhdG9yIVxuICAgIGxhc3RJbmRleCA9IGxhc3RJbmRleFdpbjMyU2VwYXJhdG9yKGZpbGVwYXRoLCBlbmRJbmRleCAtIDEpO1xuICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2Ygcm9vdCBwYXRoIGxpa2UgJ0M6JyBvciAnQzpcXFxcJ1xuICAgIGlmICgobGFzdEluZGV4ID09PSAyIHx8IGxhc3RJbmRleCA9PT0gLTEpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlsZXBhdGguY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvLyBUYWtlIGZyb20gbGFzdCBvY2N1cnJlbmNlIG9mIHNlcGFyYXRvciB0byBlbmQgb2Ygc3RyaW5nIChvciBiZWdpbm5pbmcgdG8gZW5kIGlmIG5vdCBmb3VuZClcbiAgY29uc3QgYmFzZSA9IGZpbGVwYXRoLnNsaWNlKGxhc3RJbmRleCArIDEsIGVuZEluZGV4KTtcblxuICAvLyBkcm9wIHRyYWlsaW5nIGV4dGVuc2lvbiAoaWYgc3BlY2lmaWVkKVxuICBpZiAoZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICByZXR1cm4gYmFzZS5lbmRzV2l0aChleHQpID8gYmFzZS5zbGljZSgwLCBiYXNlLmxlbmd0aCAtIGV4dC5sZW5ndGgpIDogYmFzZTtcbn1cblxuLyoqXG4gKiBUaGUgYHBhdGgubm9ybWFsaXplKClgIG1ldGhvZCBub3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoLCByZXNvbHZpbmcgJy4uJyBhbmQgJy4nIHNlZ21lbnRzLlxuICpcbiAqIFdoZW4gbXVsdGlwbGUsIHNlcXVlbnRpYWwgcGF0aCBzZWdtZW50IHNlcGFyYXRpb24gY2hhcmFjdGVycyBhcmUgZm91bmQgKGUuZy5cbiAqIC8gb24gUE9TSVggYW5kIGVpdGhlciBcXCBvciAvIG9uIFdpbmRvd3MpLCB0aGV5IGFyZSByZXBsYWNlZCBieSBhIHNpbmdsZVxuICogaW5zdGFuY2Ugb2YgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggc2VnbWVudCBzZXBhcmF0b3IgKC8gb24gUE9TSVggYW5kIFxcXG4gKiBvbiBXaW5kb3dzKS4gVHJhaWxpbmcgc2VwYXJhdG9ycyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBwYXRoIGlzIGEgemVyby1sZW5ndGggc3RyaW5nLCAnLicgaXMgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGVcbiAqIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBpZiAoZmlsZXBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIC8vIFdpbmRvd3MgY2FuIGhhbmRsZSAnLycgb3IgJ1xcXFwnIGFuZCBib3RoIHNob3VsZCBiZSB0dXJuZWQgaW50byBzZXBhcmF0b3JcbiAgY29uc3QgaXNXaW5kb3dzID0gc2VwYXJhdG9yID09PSAnXFxcXCc7XG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICBmaWxlcGF0aCA9IGZpbGVwYXRoLnJlcGxhY2UoL1xcLy9nLCBzZXBhcmF0b3IpO1xuICB9XG4gIGNvbnN0IGhhZExlYWRpbmcgPSBmaWxlcGF0aC5zdGFydHNXaXRoKHNlcGFyYXRvcik7XG4gIC8vIE9uIFdpbmRvd3MsIG5lZWQgdG8gaGFuZGxlIFVOQyBwYXRocyAoXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFxkaXIpIHNwZWNpYWwgdG8gcmV0YWluIGxlYWRpbmcgZG91YmxlIGJhY2tzbGFzaFxuICBjb25zdCBpc1VOQyA9IGhhZExlYWRpbmcgJiYgaXNXaW5kb3dzICYmIGZpbGVwYXRoLmxlbmd0aCA+IDIgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnXFxcXCc7XG4gIGNvbnN0IGhhZFRyYWlsaW5nID0gZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKTtcbiAgY29uc3QgcGFydHMgPSBmaWxlcGF0aC5zcGxpdChzZXBhcmF0b3IpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhcnRzKSB7XG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoICE9PSAwICYmIHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgICAgcmVzdWx0LnBvcCgpOyAvLyBGSVhNRTogV2hhdCBpZiB0aGlzIGdvZXMgYWJvdmUgcm9vdD8gU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBub3JtYWxpemVkID0gaGFkTGVhZGluZyA/IHNlcGFyYXRvciA6ICcnO1xuICBub3JtYWxpemVkICs9IHJlc3VsdC5qb2luKHNlcGFyYXRvcik7XG4gIGlmIChoYWRUcmFpbGluZykge1xuICAgIG5vcm1hbGl6ZWQgKz0gc2VwYXJhdG9yO1xuICB9XG4gIGlmIChpc1VOQykge1xuICAgIG5vcm1hbGl6ZWQgPSAnXFxcXCcgKyBub3JtYWxpemVkO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vKipcbiAqIFthc3NlcnRTZWdtZW50IGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Kn0gc2VnbWVudCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHt2b2lkfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U2VnbWVudChzZWdtZW50KSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICR7c2VnbWVudH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgcGF0aC5qb2luKClgIG1ldGhvZCBqb2lucyBhbGwgZ2l2ZW4gcGF0aCBzZWdtZW50cyB0b2dldGhlciB1c2luZyB0aGVcbiAqIHBsYXRmb3JtLXNwZWNpZmljIHNlcGFyYXRvciBhcyBhIGRlbGltaXRlciwgdGhlbiBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aC5cbiAqIFplcm8tbGVuZ3RoIHBhdGggc2VnbWVudHMgYXJlIGlnbm9yZWQuIElmIHRoZSBqb2luZWQgcGF0aCBzdHJpbmcgaXMgYSB6ZXJvLVxuICogbGVuZ3RoIHN0cmluZyB0aGVuICcuJyB3aWxsIGJlIHJldHVybmVkLCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nW119IHBhdGhzIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgVGhlIGpvaW5lZCBmaWxlcGF0aFxuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciwgcGF0aHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIC8vIG5haXZlIGltcGw6IGp1c3Qgam9pbiBhbGwgdGhlIHBhdGhzIHdpdGggc2VwYXJhdG9yXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRocykge1xuICAgIGFzc2VydFNlZ21lbnQoc2VnbWVudCk7XG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZShzZXBhcmF0b3IsIHJlc3VsdC5qb2luKHNlcGFyYXRvcikpO1xufVxuXG4vKipcbiAqIFRoZSBgcGF0aC5yZXNvbHZlKClgIG1ldGhvZCByZXNvbHZlcyBhIHNlcXVlbmNlIG9mIHBhdGhzIG9yIHBhdGggc2VnbWVudHMgaW50byBhbiBhYnNvbHV0ZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmdbXX0gcGF0aHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUoc2VwYXJhdG9yLCBwYXRocykge1xuICBsZXQgcmVzb2x2ZWQgPSAnJztcbiAgbGV0IGhpdFJvb3QgPSBmYWxzZTtcbiAgY29uc3QgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nO1xuICAvLyBnbyBmcm9tIHJpZ2h0IHRvIGxlZnQgdW50aWwgd2UgaGl0IGFic29sdXRlIHBhdGgvcm9vdFxuICBmb3IgKGxldCBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzZWdtZW50ID0gcGF0aHNbaV07XG4gICAgYXNzZXJ0U2VnbWVudChzZWdtZW50KTtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBza2lwIGVtcHR5XG4gICAgfVxuXG4gICAgcmVzb2x2ZWQgPSBzZWdtZW50ICsgc2VwYXJhdG9yICsgcmVzb2x2ZWQ7IC8vIHByZXBlbmQgbmV3IHNlZ21lbnRcbiAgICBpZiAoaXNBYnNvbHV0ZShpc1Bvc2l4LCBzZWdtZW50KSkge1xuICAgICAgLy8gaGF2ZSB3ZSBiYWNrZWQgaW50byBhbiBhYnNvbHV0ZSBwYXRoP1xuICAgICAgaGl0Um9vdCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gaWYgd2UgZGlkbid0IGhpdCByb290LCBwcmVwZW5kIGN3ZFxuICBpZiAoIWhpdFJvb3QpIHtcbiAgICByZXNvbHZlZCA9IChnbG9iYWwucHJvY2VzcyA/IHByb2Nlc3MuY3dkKCkgOiAnLycpICsgc2VwYXJhdG9yICsgcmVzb2x2ZWQ7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShzZXBhcmF0b3IsIHJlc29sdmVkKTtcbiAgaWYgKG5vcm1hbGl6ZWQuY2hhckF0KG5vcm1hbGl6ZWQubGVuZ3RoIC0gMSkgPT09IHNlcGFyYXRvcikge1xuICAgIC8vIEZJWE1FOiBIYW5kbGUgVU5DIHBhdGhzIG9uIFdpbmRvd3MgYXMgd2VsbCwgc28gd2UgZG9uJ3QgdHJpbSB0cmFpbGluZyBzZXBhcmF0b3Igb24gc29tZXRoaW5nIGxpa2UgJ1xcXFxcXFxcaG9zdC1uYW1lXFxcXHJlc291cmNlXFxcXCdcbiAgICAvLyBEb24ndCByZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yIGlmIHRoaXMgaXMgcm9vdCBwYXRoIG9uIHdpbmRvd3MhXG4gICAgaWYgKCFpc1Bvc2l4ICYmIG5vcm1hbGl6ZWQubGVuZ3RoID09PSAzICYmIG5vcm1hbGl6ZWQuY2hhckF0KDEpID09PSAnOicgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShub3JtYWxpemVkLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHRyaW0gdHJhaWxpbmcgc2VwYXJhdG9yXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQuc2xpY2UoMCwgbm9ybWFsaXplZC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLyoqXG4gKiBUaGUgYHBhdGgucmVsYXRpdmUoKWAgbWV0aG9kIHJldHVybnMgdGhlIHJlbGF0aXZlIHBhdGggYGZyb21gIGZyb20gdG8gYHRvYCBiYXNlZFxuICogb24gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIElmIGZyb20gYW5kIHRvIGVhY2ggcmVzb2x2ZSB0byB0aGUgc2FtZVxuICogcGF0aCAoYWZ0ZXIgY2FsbGluZyBgcGF0aC5yZXNvbHZlKClgIG9uIGVhY2gpLCBhIHplcm8tbGVuZ3RoIHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBhIHplcm8tbGVuZ3RoIHN0cmluZyBpcyBwYXNzZWQgYXMgYGZyb21gIG9yIGB0b2AsIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gKiB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgemVyby1sZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmcm9tIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gdG8gICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShzZXBhcmF0b3IsIGZyb20sIHRvKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmcm9tLCAnZnJvbScsICdzdHJpbmcnKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHRvLCAndG8nLCAnc3RyaW5nJyk7XG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBmcm9tID0gcmVzb2x2ZShzZXBhcmF0b3IsIFtmcm9tXSk7XG4gIHRvID0gcmVzb2x2ZShzZXBhcmF0b3IsIFt0b10pO1xuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyB3ZSBub3cgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsXG4gIC8vIGxldHMgXCJnbyB1cFwiIGZyb20gYGZyb21gIHVudGlsIHdlIHJlYWNoIGNvbW1vbiBiYXNlIGRpciBvZiBgdG9gXG4gIC8vIGNvbnN0IG9yaWdpbmFsRnJvbSA9IGZyb207XG4gIGxldCB1cENvdW50ID0gMDtcbiAgbGV0IHJlbWFpbmluZ1BhdGggPSAnJztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodG8uc3RhcnRzV2l0aChmcm9tKSkge1xuICAgICAgLy8gbWF0Y2ghIHJlY29yZCByZXN0Li4uP1xuICAgICAgcmVtYWluaW5nUGF0aCA9IHRvLnNsaWNlKGZyb20ubGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBGSVhNRTogQnJlYWsvdGhyb3cgaWYgd2UgaGl0IGJhZCBlZGdlIGNhc2Ugb2Ygbm8gY29tbW9uIHJvb3QhXG4gICAgZnJvbSA9IGRpcm5hbWUoc2VwYXJhdG9yLCBmcm9tKTtcbiAgICB1cENvdW50Kys7XG4gIH1cbiAgLy8gcmVtb3ZlIGxlYWRpbmcgc2VwYXJhdG9yIGZyb20gcmVtYWluaW5nUGF0aCBpZiB0aGVyZSBpcyBhbnlcbiAgaWYgKHJlbWFpbmluZ1BhdGgubGVuZ3RoID4gMCkge1xuICAgIHJlbWFpbmluZ1BhdGggPSByZW1haW5pbmdQYXRoLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiAoJy4uJyArIHNlcGFyYXRvcikucmVwZWF0KHVwQ291bnQpICsgcmVtYWluaW5nUGF0aDtcbn1cblxuLyoqXG4gKiBUaGUgYHBhdGgucGFyc2UoKWAgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgcmVwcmVzZW50XG4gKiBzaWduaWZpY2FudCBlbGVtZW50cyBvZiB0aGUgcGF0aC4gVHJhaWxpbmcgZGlyZWN0b3J5IHNlcGFyYXRvcnMgYXJlIGlnbm9yZWQsXG4gKiBzZWUgYHBhdGguc2VwYC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSBkaXIgPHN0cmluZz5cbiAqIC0gcm9vdCA8c3RyaW5nPlxuICogLSBiYXNlIDxzdHJpbmc+XG4gKiAtIG5hbWUgPHN0cmluZz5cbiAqIC0gZXh0IDxzdHJpbmc+XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJvb3Q6ICcnLFxuICAgIGRpcjogJycsXG4gICAgYmFzZTogJycsXG4gICAgZXh0OiAnJyxcbiAgICBuYW1lOiAnJ1xuICB9O1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gQ2hlYXQgYW5kIGp1c3QgY2FsbCBvdXIgb3RoZXIgbWV0aG9kcyBmb3IgZGlybmFtZS9iYXNlbmFtZS9leHRuYW1lP1xuICByZXN1bHQuYmFzZSA9IGJhc2VuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgpO1xuICByZXN1bHQuZXh0ID0gZXh0bmFtZShzZXBhcmF0b3IsIHJlc3VsdC5iYXNlKTtcbiAgY29uc3QgYmFzZUxlbmd0aCA9IHJlc3VsdC5iYXNlLmxlbmd0aDtcbiAgcmVzdWx0Lm5hbWUgPSByZXN1bHQuYmFzZS5zbGljZSgwLCBiYXNlTGVuZ3RoIC0gcmVzdWx0LmV4dC5sZW5ndGgpO1xuICBjb25zdCB0b1N1YnRyYWN0ID0gYmFzZUxlbmd0aCA9PT0gMCA/IDAgOiBiYXNlTGVuZ3RoICsgMTtcbiAgcmVzdWx0LmRpciA9IGZpbGVwYXRoLnNsaWNlKDAsIGZpbGVwYXRoLmxlbmd0aCAtIHRvU3VidHJhY3QpOyAvLyBkcm9wIHRyYWlsaW5nIHNlcGFyYXRvciFcbiAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIC8vIGJvdGggd2luMzIgYW5kIFBPU0lYIHJldHVybiAnLycgcm9vdFxuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJlc3VsdC5yb290ID0gJy8nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gd2UncmUgZG9uZSB3aXRoIFBPU0lYLi4uXG4gIGlmIChzZXBhcmF0b3IgPT09ICcvJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gZm9yIHdpbjMyLi4uXG4gIGlmIChmaXJzdENoYXJDb2RlID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIC8vIEZJWE1FOiBIYW5kbGUgVU5DIHBhdGhzIGxpa2UgJ1xcXFxcXFxcaG9zdC1uYW1lXFxcXHJlc291cmNlXFxcXGZpbGVfcGF0aCdcbiAgICAvLyBuZWVkIHRvIHJldGFpbiAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcJyBhcyByb290IGluIHRoYXQgY2FzZSFcbiAgICByZXN1bHQucm9vdCA9ICdcXFxcJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIGNoZWNrIGZvciBDOiBzdHlsZSByb290XG4gIGlmIChsZW5ndGggPiAxICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyQ29kZSkgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgLy8gaXMgaXQgbGlrZSBDOlxcXFw/XG4gICAgICBjb25zdCB0aGlyZENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZENoYXJDb2RlID09PSBGT1JXQVJEX1NMQVNIIHx8IHRoaXJkQ2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgIHJlc3VsdC5yb290ID0gZmlsZXBhdGguc2xpY2UoMCwgMyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vcGUsIGp1c3QgQzosIG5vIHRyYWlsaW5nIHNlcGFyYXRvclxuICAgIHJlc3VsdC5yb290ID0gZmlsZXBhdGguc2xpY2UoMCwgMik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYHBhdGguZm9ybWF0KClgIG1ldGhvZCByZXR1cm5zIGEgcGF0aCBzdHJpbmcgZnJvbSBhbiBvYmplY3QuIFRoaXMgaXMgdGhlXG4gKiBvcHBvc2l0ZSBvZiBgcGF0aC5wYXJzZSgpYC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7b2JqZWN0fSBwYXRoT2JqZWN0IG9iamVjdCBvZiBmb3JtYXQgcmV0dXJuZWQgYnkgYHBhdGgucGFyc2UoKWBcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5kaXIgZGlyZWN0b3J5IG5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5yb290IGZpbGUgcm9vdCBkaXIsIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuZGlyYCBpcyBwcm92aWRlZFxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LmJhc2UgZmlsZSBiYXNlbmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0Lm5hbWUgYmFzZW5hbWUgbWludXMgZXh0ZW5zaW9uLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmJhc2VgIGV4aXN0c1xuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LmV4dCBmaWxlIGV4dGVuc2lvbiwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5iYXNlYCBleGlzdHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHNlcGFyYXRvciwgcGF0aE9iamVjdCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUocGF0aE9iamVjdCwgJ3BhdGhPYmplY3QnLCAnb2JqZWN0Jyk7XG4gIGNvbnN0IGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgYCR7cGF0aE9iamVjdC5uYW1lIHx8ICcnfSR7cGF0aE9iamVjdC5leHQgfHwgJyd9YDtcblxuICAvLyBhcHBlbmQgYmFzZSB0byByb290IGlmIGBkaXJgIHdhc24ndCBzcGVjaWZpZWQsIG9yIGlmXG4gIC8vIGRpciBpcyB0aGUgcm9vdFxuICBpZiAoIXBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3QuZGlyID09PSBwYXRoT2JqZWN0LnJvb3QpIHtcbiAgICByZXR1cm4gYCR7cGF0aE9iamVjdC5yb290IHx8ICcnfSR7YmFzZX1gO1xuICB9XG4gIC8vIGNvbWJpbmUgZGlyICsgLyArIGJhc2VcbiAgcmV0dXJuIGAke3BhdGhPYmplY3QuZGlyfSR7c2VwYXJhdG9yfSR7YmFzZX1gO1xufVxuXG4vKipcbiAqIE9uIFdpbmRvd3Mgc3lzdGVtcyBvbmx5LCByZXR1cm5zIGFuIGVxdWl2YWxlbnQgbmFtZXNwYWNlLXByZWZpeGVkIHBhdGggZm9yXG4gKiB0aGUgZ2l2ZW4gcGF0aC4gSWYgcGF0aCBpcyBub3QgYSBzdHJpbmcsIHBhdGggd2lsbCBiZSByZXR1cm5lZCB3aXRob3V0IG1vZGlmaWNhdGlvbnMuXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy9kZXNrdG9wL0ZpbGVJTy9uYW1pbmctYS1maWxlI25hbWVzcGFjZXNcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIHRvTmFtZXNwYWNlZFBhdGgoZmlsZXBhdGgpIHtcbiAgaWYgKHR5cGVvZiBmaWxlcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH1cbiAgaWYgKGZpbGVwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCByZXNvbHZlZFBhdGggPSByZXNvbHZlKCdcXFxcJywgW2ZpbGVwYXRoXSk7XG4gIGNvbnN0IGxlbmd0aCA9IHJlc29sdmVkUGF0aC5sZW5ndGg7XG4gIGlmIChsZW5ndGggPCAyKSB7XG4gICAgLy8gbmVlZCAnXFxcXFxcXFwnIG9yICdDOicgbWluaW11bVxuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuICBjb25zdCBmaXJzdENoYXJDb2RlID0gcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMCk7XG4gIC8vIGlmIHN0YXJ0IHdpdGggJ1xcXFxcXFxcJywgcHJlZml4IHdpdGggVU5DIHJvb3QsIGRyb3AgdGhlIHNsYXNoZXNcbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJykge1xuICAgIC8vIHJldHVybiBhcy1pcyBpZiBpdCdzIGFuIGFyZWFkeSBsb25nIHBhdGggKCdcXFxcXFxcXD9cXFxcJyBvciAnXFxcXFxcXFwuXFxcXCcgcHJlZml4KVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgY29uc3QgdGhpcmRDaGFyID0gcmVzb2x2ZWRQYXRoLmNoYXJBdCgyKTtcbiAgICAgIGlmICh0aGlyZENoYXIgPT09ICc/JyB8fCB0aGlyZENoYXIgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnXFxcXFxcXFw/XFxcXFVOQ1xcXFwnICsgcmVzb2x2ZWRQYXRoLnNsaWNlKDIpO1xuICB9IGVsc2UgaWYgKGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyQ29kZSkgJiYgcmVzb2x2ZWRQYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgcmV0dXJuICdcXFxcXFxcXD9cXFxcJyArIHJlc29sdmVkUGF0aDtcbiAgfVxuICByZXR1cm4gZmlsZXBhdGg7XG59XG5jb25zdCBXaW4zMlBhdGggPSB7XG4gIHNlcDogJ1xcXFwnLFxuICBkZWxpbWl0ZXI6ICc7JyxcbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCwgZXh0KSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCwgZXh0KTtcbiAgfSxcbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGpvaW46IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGF0aHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwYXRoc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBwYXRocyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgcGF0aHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmUodGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBwYXJzZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBmb3JtYXQ6IGZ1bmN0aW9uIChwYXRoT2JqZWN0KSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnNlcCwgcGF0aE9iamVjdCk7XG4gIH0sXG4gIHRvTmFtZXNwYWNlZFBhdGg6IHRvTmFtZXNwYWNlZFBhdGhcbn07XG5jb25zdCBQb3NpeFBhdGggPSB7XG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCwgZXh0KSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCwgZXh0KTtcbiAgfSxcbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGpvaW46IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhdGhzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBwYXRoc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICByZXR1cm4gam9pbih0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBleHRuYW1lOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZXh0bmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBkaXJuYW1lOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZGlybmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gaXNBYnNvbHV0ZSh0cnVlLCBmaWxlcGF0aCk7XG4gIH0sXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gcmVsYXRpdmUodGhpcy5zZXAsIGZyb20sIHRvKTtcbiAgfSxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgcGF0aHMgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIHBhdGhzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gcGFyc2UodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZm9ybWF0OiBmdW5jdGlvbiAocGF0aE9iamVjdCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7IC8vIG5vLW9wXG4gIH1cbn07XG5cbmNvbnN0IHBhdGggPSBQb3NpeFBhdGg7XG5wYXRoLndpbjMyID0gV2luMzJQYXRoO1xucGF0aC5wb3NpeCA9IFBvc2l4UGF0aDtcblxuY29uc3QgaXNBbmRyb2lkJDEgPSBUaS5QbGF0Zm9ybS5vc25hbWUgPT09ICdhbmRyb2lkJztcbmNvbnN0IGlzSU9TID0gIWlzQW5kcm9pZCQxICYmIHRydWU7XG5jb25zdCBQb3NpeENvbnN0YW50cyA9IHtcbiAgVVZfVURQX1JFVVNFQUREUjogNCxcbiAgZGxvcGVuOiB7fSxcbiAgZXJybm86IHtcbiAgICBFMkJJRzogNyxcbiAgICBFQUNDRVM6IDEzLFxuICAgIEVBRERSSU5VU0U6IDQ4LFxuICAgIEVBRERSTk9UQVZBSUw6IDQ5LFxuICAgIEVBRk5PU1VQUE9SVDogNDcsXG4gICAgRUFHQUlOOiAzNSxcbiAgICBFQUxSRUFEWTogMzcsXG4gICAgRUJBREY6IDksXG4gICAgRUJBRE1TRzogOTQsXG4gICAgRUJVU1k6IDE2LFxuICAgIEVDQU5DRUxFRDogODksXG4gICAgRUNISUxEOiAxMCxcbiAgICBFQ09OTkFCT1JURUQ6IDUzLFxuICAgIEVDT05OUkVGVVNFRDogNjEsXG4gICAgRUNPTk5SRVNFVDogNTQsXG4gICAgRURFQURMSzogMTEsXG4gICAgRURFU1RBRERSUkVROiAzOSxcbiAgICBFRE9NOiAzMyxcbiAgICBFRFFVT1Q6IDY5LFxuICAgIEVFWElTVDogMTcsXG4gICAgRUZBVUxUOiAxNCxcbiAgICBFRkJJRzogMjcsXG4gICAgRUhPU1RVTlJFQUNIOiA2NSxcbiAgICBFSURSTTogOTAsXG4gICAgRUlMU0VROiA5MixcbiAgICBFSU5QUk9HUkVTUzogMzYsXG4gICAgRUlOVFI6IDQsXG4gICAgRUlOVkFMOiAyMixcbiAgICBFSU86IDUsXG4gICAgRUlTQ09OTjogNTYsXG4gICAgRUlTRElSOiAyMSxcbiAgICBFTE9PUDogNjIsXG4gICAgRU1GSUxFOiAyNCxcbiAgICBFTUxJTks6IDMxLFxuICAgIEVNU0dTSVpFOiA0MCxcbiAgICBFTVVMVElIT1A6IDk1LFxuICAgIEVOQU1FVE9PTE9ORzogNjMsXG4gICAgRU5FVERPV046IDUwLFxuICAgIEVORVRSRVNFVDogNTIsXG4gICAgRU5FVFVOUkVBQ0g6IDUxLFxuICAgIEVORklMRTogMjMsXG4gICAgRU5PQlVGUzogNTUsXG4gICAgRU5PREFUQTogOTYsXG4gICAgRU5PREVWOiAxOSxcbiAgICBFTk9FTlQ6IDIsXG4gICAgRU5PRVhFQzogOCxcbiAgICBFTk9MQ0s6IDc3LFxuICAgIEVOT0xJTks6IDk3LFxuICAgIEVOT01FTTogMTIsXG4gICAgRU5PTVNHOiA5MSxcbiAgICBFTk9QUk9UT09QVDogNDIsXG4gICAgRU5PU1BDOiAyOCxcbiAgICBFTk9TUjogOTgsXG4gICAgRU5PU1RSOiA5OSxcbiAgICBFTk9TWVM6IDc4LFxuICAgIEVOT1RDT05OOiA1NyxcbiAgICBFTk9URElSOiAyMCxcbiAgICBFTk9URU1QVFk6IDY2LFxuICAgIEVOT1RTT0NLOiAzOCxcbiAgICBFTk9UU1VQOiA0NSxcbiAgICBFTk9UVFk6IDI1LFxuICAgIEVOWElPOiA2LFxuICAgIEVPUE5PVFNVUFA6IDEwMixcbiAgICBFT1ZFUkZMT1c6IDg0LFxuICAgIEVQRVJNOiAxLFxuICAgIEVQSVBFOiAzMixcbiAgICBFUFJPVE86IDEwMCxcbiAgICBFUFJPVE9OT1NVUFBPUlQ6IDQzLFxuICAgIEVQUk9UT1RZUEU6IDQxLFxuICAgIEVSQU5HRTogMzQsXG4gICAgRVJPRlM6IDMwLFxuICAgIEVTUElQRTogMjksXG4gICAgRVNSQ0g6IDMsXG4gICAgRVNUQUxFOiA3MCxcbiAgICBFVElNRTogMTAxLFxuICAgIEVUSU1FRE9VVDogNjAsXG4gICAgRVRYVEJTWTogMjYsXG4gICAgRVdPVUxEQkxPQ0s6IDM1LFxuICAgIEVYREVWOiAxOFxuICB9LFxuICBzaWduYWxzOiB7XG4gICAgU0lHSFVQOiAxLFxuICAgIFNJR0lOVDogMixcbiAgICBTSUdRVUlUOiAzLFxuICAgIFNJR0lMTDogNCxcbiAgICBTSUdUUkFQOiA1LFxuICAgIFNJR0FCUlQ6IDYsXG4gICAgU0lHSU9UOiA2LFxuICAgIFNJR0JVUzogMTAsXG4gICAgU0lHRlBFOiA4LFxuICAgIFNJR0tJTEw6IDksXG4gICAgU0lHVVNSMTogMzAsXG4gICAgU0lHU0VHVjogMTEsXG4gICAgU0lHVVNSMjogMzEsXG4gICAgU0lHUElQRTogMTMsXG4gICAgU0lHQUxSTTogMTQsXG4gICAgU0lHVEVSTTogMTUsXG4gICAgU0lHQ0hMRDogMjAsXG4gICAgU0lHQ09OVDogMTksXG4gICAgU0lHU1RPUDogMTcsXG4gICAgU0lHVFNUUDogMTgsXG4gICAgU0lHVFRJTjogMjEsXG4gICAgU0lHVFRPVTogMjIsXG4gICAgU0lHVVJHOiAxNixcbiAgICBTSUdYQ1BVOiAyNCxcbiAgICBTSUdYRlNaOiAyNSxcbiAgICBTSUdWVEFMUk06IDI2LFxuICAgIFNJR1BST0Y6IDI3LFxuICAgIFNJR1dJTkNIOiAyOCxcbiAgICBTSUdJTzogMjMsXG4gICAgU0lHSU5GTzogMjksXG4gICAgU0lHU1lTOiAxMlxuICB9LFxuICBwcmlvcml0eToge1xuICAgIFBSSU9SSVRZX0xPVzogMTksXG4gICAgUFJJT1JJVFlfQkVMT1dfTk9STUFMOiAxMCxcbiAgICBQUklPUklUWV9OT1JNQUw6IDAsXG4gICAgUFJJT1JJVFlfQUJPVkVfTk9STUFMOiAtNyxcbiAgICBQUklPUklUWV9ISUdIOiAtMTQsXG4gICAgUFJJT1JJVFlfSElHSEVTVDogLTIwXG4gIH1cbn07XG5cbi8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zXG5jb25zdCBPUyA9IHtcbiAgRU9MOiAnXFxuJyxcbiAgYXJjaDogKCkgPT4gcHJvY2Vzcy5hcmNoLFxuICBjb25zdGFudHM6IFBvc2l4Q29uc3RhbnRzLFxuICBjcHVzOiAoKSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBUaS5QbGF0Zm9ybS5wcm9jZXNzb3JDb3VudDtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIG1vZGVsOiAndW5rbm93bicsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICB0aW1lczoge1xuICAgICAgICAgIHVzZXI6IDAsXG4gICAgICAgICAgbmljZTogMCxcbiAgICAgICAgICBzeXM6IDAsXG4gICAgICAgICAgaWRsZTogMCxcbiAgICAgICAgICBpcnE6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcbiAgZW5kaWFubmVzczogKCkgPT4ge1xuICAgIC8vIFRPRE86IENhY2hlIHRoZSB2YWx1ZSFcbiAgICBjb25zdCByZXN1bHQgPSBUaS5Db2RlYy5nZXROYXRpdmVCeXRlT3JkZXIoKTtcbiAgICBpZiAocmVzdWx0ID09PSBUaS5Db2RlYy5MSVRUTEVfRU5ESUFOKSB7XG4gICAgICByZXR1cm4gJ0xFJztcbiAgICB9XG4gICAgcmV0dXJuICdCRSc7XG4gIH0sXG4gIGZyZWVtZW06ICgpID0+IFRpLlBsYXRmb3JtLmF2YWlsYWJsZU1lbW9yeSxcbiAgZ2V0UHJpb3JpdHk6ICgpID0+IDAsXG4gIC8vIGZha2UgaXRcbiAgaG9tZWRpcjogKCkgPT4gVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gIC8vIGZha2UgaXRcbiAgaG9zdG5hbWU6ICgpID0+IFRpLlBsYXRmb3JtLmFkZHJlc3MsXG4gIC8vIGZha2UgaXRcbiAgbG9hZGF2ZzogKCkgPT4gWzAsIDAsIDBdLFxuICAvLyBmYWtlIGl0XG4gIG5ldHdvcmtJbnRlcmZhY2VzOiAoKSA9PiB7fSxcbiAgLy8gRklYTUU6IFdoYXQgZG8gd2UgZG8gaGVyZT8gV2UgbWlnaHQgYmUgYWJsZSB0byBwaWVjZSBzb21lIG9mIHRoaXMgdG9nZXRoZXIgdXNpbmcgVGkuUGxhdGZvcm0ubmV0bWFzaywgVGkuUGxhdGZvcm0uYWRkcmVzc1xuICBwbGF0Zm9ybTogKCkgPT4gcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgcmVsZWFzZTogKCkgPT4gVGkuUGxhdGZvcm0udmVyc2lvbixcbiAgc2V0UHJpb3JpdHk6ICgpID0+IHt9LFxuICAvLyBuby1vcCwgZmFrZSBpdFxuICAvKipcbiAgICogVGhlIGBvcy50bXBkaXIoKWAgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgb3BlcmF0aW5nIHN5c3RlbSdzIGRlZmF1bHQgZGlyZWN0b3J5IGZvciB0ZW1wb3JhcnkgZmlsZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG1wZGlyOiAoKSA9PiBUaS5GaWxlc3lzdGVtLnRlbXBEaXJlY3RvcnksXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRvdGFsbWVtKClgIG1ldGhvZCByZXR1cm5zIHRoZSB0b3RhbCBhbW91bnQgb2Ygc3lzdGVtIG1lbW9yeSBpbiBieXRlcyBhcyBhbiBpbnRlZ2VyLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0b3RhbG1lbTogKCkgPT4gVGkuUGxhdGZvcm0udG90YWxNZW1vcnksXG4gIHR5cGU6ICgpID0+ICdVbmtub3duJyxcbiAgLy8gb3ZlcnJpZGRlbiBwZXItcGxhdGZvcm0gYXQgYm90dG9tXG4gIC8qKlxuICAgKiBUaGUgYG9zLnVwdGltZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgc3lzdGVtIHVwdGltZSBpbiBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdXB0aW1lOiAoKSA9PiBUaS5QbGF0Zm9ybS51cHRpbWUsXG4gIHVzZXJJbmZvOiAoKSA9PiB7XG4gICAgLy8gZmFrZSBpdCFcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiAtMSxcbiAgICAgIGdpZDogLTEsXG4gICAgICB1c2VybmFtZTogVGkuUGxhdGZvcm0udXNlcm5hbWUsXG4gICAgICBob21lZGlyOiBUaS5GaWxlc3lzdGVtLmFwcGxpY2F0aW9uRGF0YURpcmVjdG9yeSxcbiAgICAgIHNoZWxsOiBudWxsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gT24gc3BlY2lmaWMgcGxhdGZvcm1zLCBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbnMgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoZW1cbi8vIHlldCBhbmQgbmVlZCB0byBmYWtlIGl0LCBvciB0byBoYWNrIHRoZW1cbi8vIEknbSBhbHNvIGRvaW5nIHRoaXMgaW4gYmxvY2tzIHRvIGFzc2lnbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCBkb24ndCBuZWVkIHRvIGNvbnN1bHQgcGxhdGZvcm1cbi8vIHR5cGUgYXQgcnVudGltZSAoaG9wZWZ1bGx5IHNwZWVkaW5nIHVwIGV4ZWN1dGlvbiBhdCBydW50aW1lKVxuaWYgKGlzSU9TKSB7XG4gIE9TLnR5cGUgPSAoKSA9PiAnRGFyd2luJztcblxuICAvLyBOb3cgYSBnaWFudCBoYWNrIGZvciBsb29raW5nIHVwIENQVSBpbmZvIGZvciBPUy5jcHVzKCkgb24gaU9TXG4gIC8vIGh0dHBzOi8vd3d3LnRoZWlwaG9uZXdpa2kuY29tL3dpa2kvTGlzdF9vZl9pUGhvbmVzXG4gIGNvbnN0IEFwcGxlTWFwID0ge1xuICAgIC8vIGlQaG9uZSAxMiBQcm8gTWF4XG4gICAgJ2lQaG9uZTEzLDQnOiBbJ0FwcGxlIEExNCBCaW9uaWMgQCAyLjk5IEdIeicsIDI5OTBdLFxuICAgIC8vIGlQaG9uZSAxMiBQcm9cbiAgICAnaVBob25lMTMsMyc6IFsnQXBwbGUgQTE0IEJpb25pYyBAIDIuOTkgR0h6JywgMjk5MF0sXG4gICAgLy8gaVBob25lIDEyXG4gICAgJ2lQaG9uZTEzLDInOiBbJ0FwcGxlIEExNCBCaW9uaWMgQCAyLjk5IEdIeicsIDI5OTBdLFxuICAgIC8vIGlQaG9uZSAxMiBtaW5pXG4gICAgJ2lQaG9uZTEzLDEnOiBbJ0FwcGxlIEExNCBCaW9uaWMgQCAyLjk5IEdIeicsIDI5OTBdLFxuICAgIC8vIGlQaG9uZSBTRSAoMm5kIGdlbilcbiAgICAnaVBob25lMTIsOCc6IFsnQXBwbGUgQTEzIEJpb25pYyBAIDIuNjYgR0h6JywgMjY2MF0sXG4gICAgLy8gaVBob25lIDExIFBybyBNYXhcbiAgICAnaVBob25lMTIsNSc6IFsnQXBwbGUgQTEzIEJpb25pYyBAIDIuNjYgR0h6JywgMjY2MF0sXG4gICAgLy8gaVBob25lIDExIFByb1xuICAgICdpUGhvbmUxMiwzJzogWydBcHBsZSBBMTMgQmlvbmljIEAgMi42NiBHSHonLCAyNjYwXSxcbiAgICAvLyBpUGhvbmUgMTFcbiAgICAnaVBob25lMTIsMSc6IFsnQXBwbGUgQTEzIEJpb25pYyBAIDIuNjYgR0h6JywgMjY2MF0sXG4gICAgLy8gaVBob25lIFhSXG4gICAgJ2lQaG9uZTExLDgnOiBbJ0FwcGxlIEExMiBCaW9uaWMgQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQaG9uZSBYUyBNYXhcbiAgICAnaVBob25lMTEsNic6IFsnQXBwbGUgQTEyIEJpb25pYyBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQaG9uZTExLDQnOiBbJ0FwcGxlIEExMiBCaW9uaWMgQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQaG9uZSBYU1xuICAgICdpUGhvbmUxMSwyJzogWydBcHBsZSBBMTIgQmlvbmljIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAvLyBpUGhvbmUgWFxuICAgICdpUGhvbmUxMCw2JzogWydBcHBsZSBBMTEgQmlvbmljIEAgMi4zOSBHSHonLCAyMzkwXSxcbiAgICAnaVBob25lMTAsMyc6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgLy8gaVBob25lIDggUGx1c1xuICAgICdpUGhvbmUxMCw1JzogWydBcHBsZSBBMTEgQmlvbmljIEAgMi4zOSBHSHonLCAyMzkwXSxcbiAgICAnaVBob25lMTAsMic6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgLy8gaVBob25lIDhcbiAgICAnaVBob25lMTAsNCc6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgJ2lQaG9uZTEwLDEnOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgIC8vIGlQaG9uZSA3IFBsdXNcbiAgICAnaVBob25lOSw0JzogWydBcHBsZSBBMTAgRnVzaW9uIEAgMi4zNCBHSHonLCAyMzQwXSxcbiAgICAnaVBob25lOSwyJzogWydBcHBsZSBBMTAgRnVzaW9uIEAgMi4zNCBHSHonLCAyMzQwXSxcbiAgICAvLyBpUGhvbmUgN1xuICAgICdpUGhvbmU5LDMnOiBbJ0FwcGxlIEExMCBGdXNpb24gQCAyLjM0IEdIeicsIDIzNDBdLFxuICAgICdpUGhvbmU5LDEnOiBbJ0FwcGxlIEExMCBGdXNpb24gQCAyLjM0IEdIeicsIDIzNDBdLFxuICAgIC8vIGlQaG9uZSBTRVxuICAgICdpUGhvbmU4LDQnOiBbJ0FwcGxlIEE5IFR3aXN0ZXIgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgIC8vIGlQaG9uZSA2cyBQbHVzXG4gICAgJ2lQaG9uZTgsMic6IFsnQXBwbGUgQTkgVHdpc3RlciBAIDEuODUgR0h6JywgMTg1MF0sXG4gICAgLy8gaVBob25lIDZzXG4gICAgJ2lQaG9uZTgsMSc6IFsnQXBwbGUgQTkgVHdpc3RlciBAIDEuODUgR0h6JywgMTg1MF0sXG4gICAgLy8gaVBob25lIDYgUGx1c1xuICAgICdpUGhvbmU3LDEnOiBbJ0FwcGxlIEE4IFR5cGhvb24gQCAxLjM4IEdIeicsIDEzODBdLFxuICAgIC8vIGlQaG9uZSA2XG4gICAgJ2lQaG9uZTcsMic6IFsnQXBwbGUgQTggVHlwaG9vbiBAIDEuMzggR0h6JywgMTM4MF0sXG4gICAgLy8gaVBob25lIDVzXG4gICAgJ2lQaG9uZTYsMic6IFsnQXBwbGUgQTcgQ3ljbG9uZSBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAnaVBob25lNiwxJzogWydBcHBsZSBBNyBDeWNsb25lIEAgMS4zIEdIeicsIDEzMDBdLFxuICAgIC8vIGlQaG9uZSA1Y1xuICAgICdpUGhvbmU1LDQnOiBbJ0FwcGxlIEE2IFN3aWZ0IEAgMS4yIEdIeicsIDEyMDBdLFxuICAgICdpUGhvbmU1LDMnOiBbJ0FwcGxlIEE2IFN3aWZ0IEAgMS4yIEdIeicsIDEyMDBdLFxuICAgIC8vIGlQaG9uZSA1XG4gICAgJ2lQaG9uZTUsMSc6IFsnQXBwbGUgQTYgU3dpZnQgQCAxLjIgR0h6JywgMTIwMF0sXG4gICAgJ2lQaG9uZTUsMic6IFsnQXBwbGUgQTYgU3dpZnQgQCAxLjIgR0h6JywgMTIwMF0sXG4gICAgLy8gaVBob25lIDRzXG4gICAgJ2lQaG9uZTQsMSc6IFsnQXBwbGUgQTUgQCA4MDAgTUh6JywgODAwXSxcbiAgICAvLyBpUGhvbmUgNFxuICAgICdpUGhvbmUzLDMnOiBbJ0FwcGxlIEE0IEAgODAwIE1IeicsIDgwMF0sXG4gICAgJ2lQaG9uZTMsMic6IFsnQXBwbGUgQTQgQCA4MDAgTUh6JywgODAwXSxcbiAgICAnaVBob25lMywxJzogWydBcHBsZSBBNCBAIDgwMCBNSHonLCA4MDBdLFxuICAgIC8vIGlQaG9uZSAzR1NcbiAgICAnaVBob25lMiwxJzogWydTYW1zdW5nIFM1TDg5MjAgQCA2MjAgTUh6JywgNjIwXSxcbiAgICAvLyBpUGhvbmUgM0dcbiAgICAnaVBob25lMSwyJzogWydTYW1zdW5nIFM1TDg5MDAgQCA0MTIgTUh6JywgNDEyXSxcbiAgICAvLyBpUGhvbmVcbiAgICAnaVBob25lMSwxJzogWydTYW1zdW5nIFM1TDg5MDAgQCA0MTIgTUh6JywgNDEyXSxcbiAgICAvLyAvLy8vLy8gaVBhZHNcbiAgICAvLyBodHRwczovL3d3dy50aGVpcGhvbmV3aWtpLmNvbS93aWtpL0xpc3Rfb2ZfaVBhZHNcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JUGFkXG4gICAgLy8gaVBhZCBQcm8gKDR0aCBnZW4pXG4gICAgJ2lQYWQ4LDEyJzogWydBcHBsZSBBMTJaIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsMTEnOiBbJ0FwcGxlIEExMlogQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQYWQgbWluaSAoNXRoIGdlbilcbiAgICAnaVBhZDExLDEnOiBbJ0FwcGxlIEExMiBCaW9uaWMgQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkMTEsMic6IFsnQXBwbGUgQTEyIEJpb25pYyBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgLy8gaVBhZCBBaXIgKDNyZCBnZW4pXG4gICAgJ2lQYWQxMSwzJzogWydBcHBsZSBBMTIgQmlvbmljIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDExLDQnOiBbJ0FwcGxlIEExMiBCaW9uaWMgQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQYWQgUHJvICgxMi45XCIgM3JkIGdlbilcbiAgICAnaVBhZDgsOCc6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQYWQ4LDcnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkOCw2JzogWydBcHBsZSBBMTJYIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsNSc6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgLy8gaVBhZCBQcm8gKDExXCIpXG4gICAgJ2lQYWQ4LDQnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkOCwzJzogWydBcHBsZSBBMTJYIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsMic6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQYWQ4LDEnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQYWQgKDd0aCBnZW4pXG4gICAgJ2lQYWQ3LDExJzogWydBcHBsZSBBMTAgQCAyLjMxIEdIeicsIDIzMTBdLFxuICAgICdpUGFkNywxMic6IFsnQXBwbGUgQTEwIEAgMi4zMSBHSHonLCAyMzEwXSxcbiAgICAvLyBpUGFkICg2dGggZ2VuKVxuICAgICdpUGFkNyw2JzogWydBcHBsZSBBMTAgQCAyLjMxIEdIeicsIDIzMTBdLFxuICAgIC8vIEZJWE1FOiBXaWtpcGVkaWEgc2F5cyAyLjM0IEdIelxuICAgICdpUGFkNyw1JzogWydBcHBsZSBBMTAgQCAyLjMxIEdIeicsIDIzMTBdLFxuICAgIC8vIGlQYWQgUHJvICgxMC41XCIpXG4gICAgJ2lQYWQ3LDQnOiBbJ0FwcGxlIEExMFggQCAyLjM4IEdIeicsIDIzODBdLFxuICAgICdpUGFkNywzJzogWydBcHBsZSBBMTBYIEAgMi4zOCBHSHonLCAyMzgwXSxcbiAgICAvLyBpUGFkIFBybyAoMTIuOVwiIDJuZCBnZW4pXG4gICAgJ2lQYWQ3LDInOiBbJ0FwcGxlIEExMFggQCAyLjM4IEdIeicsIDIzODBdLFxuICAgICdpUGFkNywxJzogWydBcHBsZSBBMTBYIEAgMi4zOCBHSHonLCAyMzgwXSxcbiAgICAvLyBpUGFkICg1dGggZ2VuKVxuICAgICdpUGFkNiwxMic6IFsnQXBwbGUgQTkgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgICdpUGFkNiwxMSc6IFsnQXBwbGUgQTkgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgIC8vIGlQYWQgUHJvICgxMi45XCIgMXN0IGdlbilcbiAgICAnaVBhZDYsOCc6IFsnQXBwbGUgQTlYIEAgMi4yNCBHSHonLCAyMjQwXSxcbiAgICAnaVBhZDYsNyc6IFsnQXBwbGUgQTlYIEAgMi4yNCBHSHonLCAyMjQwXSxcbiAgICAvLyBpUGFkIFBybyAoOS43XCIpXG4gICAgJ2lQYWQ2LDQnOiBbJ0FwcGxlIEE5WCBAIDIuMTYgR0h6JywgMjE2MF0sXG4gICAgJ2lQYWQ2LDMnOiBbJ0FwcGxlIEE5WCBAIDIuMTYgR0h6JywgMjE2MF0sXG4gICAgLy8gaVBhZCBBaXIgMlxuICAgICdpUGFkNSw0JzogWydBcHBsZSBBOFggQCAxLjUgR0h6JywgMTUwMF0sXG4gICAgJ2lQYWQ1LDMnOiBbJ0FwcGxlIEE4WCBAIDEuNSBHSHonLCAxNTAwXSxcbiAgICAvLyBpUGFkIE1pbmkgNFxuICAgICdpUGFkNSwyJzogWydBcHBsZSBBOCBAIDEuNDkgR0h6JywgMTQ5MF0sXG4gICAgJ2lQYWQ1LDEnOiBbJ0FwcGxlIEE4IEAgMS40OSBHSHonLCAxNDkwXSxcbiAgICAvLyBpUGFkIE1pbmkgM1xuICAgICdpUGFkNCw5JzogWydBcHBsZSBBNyBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAnaVBhZDQsOCc6IFsnQXBwbGUgQTcgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgJ2lQYWQ0LDcnOiBbJ0FwcGxlIEE3IEAgMS4zIEdIeicsIDEzMDBdLFxuICAgIC8vIGlQYWQgTWluaSAyXG4gICAgJ2lQYWQ0LDYnOiBbJ0FwcGxlIEE3IEAgMS4zIEdIeicsIDEzMDBdLFxuICAgICdpUGFkNCw1JzogWydBcHBsZSBBNyBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAnaVBhZDQsNCc6IFsnQXBwbGUgQTcgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgLy8gaVBhZCBBaXIgMlxuICAgICdpUGFkNCwzJzogWydBcHBsZSBBNyBSZXYgQSBAIDEuNCBHSHonLCAxNDAwXSxcbiAgICAnaVBhZDQsMic6IFsnQXBwbGUgQTcgUmV2IEEgQCAxLjQgR0h6JywgMTQwMF0sXG4gICAgJ2lQYWQ0LDEnOiBbJ0FwcGxlIEE3IFJldiBBIEAgMS40IEdIeicsIDE0MDBdLFxuICAgIC8vIGlQYWQgKDR0aCBnZW4pXG4gICAgJ2lQYWQzLDYnOiBbJ0FwcGxlIEE2WCBAIDEuNCBHSHonLCAxNDAwXSxcbiAgICAnaVBhZDMsNSc6IFsnQXBwbGUgQTZYIEAgMS40IEdIeicsIDE0MDBdLFxuICAgICdpUGFkMyw0JzogWydBcHBsZSBBNlggQCAxLjQgR0h6JywgMTQwMF0sXG4gICAgLy8gaVBhZCAoM3JkIGdlbilcbiAgICAnaVBhZDMsMyc6IFsnQXBwbGUgQTVYIEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDMsMic6IFsnQXBwbGUgQTVYIEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDMsMSc6IFsnQXBwbGUgQTVYIEAgMSBHSHonLCAxMDAwXSxcbiAgICAvLyBpUGFkIE1pbmlcbiAgICAnaVBhZDIsNyc6IFsnQXBwbGUgQTUgUmV2IEEgQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMiw2JzogWydBcHBsZSBBNSBSZXYgQSBAIDEgR0h6JywgMTAwMF0sXG4gICAgJ2lQYWQyLDUnOiBbJ0FwcGxlIEE1IFJldiBBIEAgMSBHSHonLCAxMDAwXSxcbiAgICAvLyBpUGFkIDJcbiAgICAnaVBhZDIsNCc6IFsnQXBwbGUgQTUgQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMiwzJzogWydBcHBsZSBBNSBAIDEgR0h6JywgMTAwMF0sXG4gICAgJ2lQYWQyLDInOiBbJ0FwcGxlIEE1IEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDIsMSc6IFsnQXBwbGUgQTUgQCAxIEdIeicsIDEwMDBdLFxuICAgIC8vIGlQYWQgM0dcbiAgICAnaVBhZDEsMic6IFsnQXBwbGUgQTQgQCAxIEdIeicsIDEwMDBdLFxuICAgIC8vIGlQYWRcbiAgICAnaVBhZDEsMSc6IFsnQXBwbGUgQTQgQCAxIEdIeicsIDEwMDBdXG4gIH07XG5cbiAgLyoqXG4gICAqIFtjcHVNb2RlbCBkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7c3RyaW5nfSBtb2RlbCBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBjb25zdCBjcHVNb2RlbEFuZFNwZWVkID0gbW9kZWwgPT4ge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBtb2RlbC5yZXBsYWNlKCcgKFNpbXVsYXRvciknLCAnJykudHJpbSgpO1xuICAgIHJldHVybiBBcHBsZU1hcFt0cmltbWVkXSB8fCBbJ1Vua25vd24nLCAwXTtcbiAgfTtcbiAgLy8gb3ZlcnJpZGUgY3B1cyBpbXBsXG4gIE9TLmNwdXMgPSAoKSA9PiB7XG4gICAgLy8gVE9ETzogQ2FjaGUgdGhlIHJlc3VsdCFcbiAgICBjb25zdCBjb3VudCA9IFRpLlBsYXRmb3JtLnByb2Nlc3NvckNvdW50O1xuICAgIGNvbnN0IG1vZGVsQW5kU3BlZWQgPSBjcHVNb2RlbEFuZFNwZWVkKFRpLlBsYXRmb3JtLm1vZGVsKTtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIG1vZGVsOiBtb2RlbEFuZFNwZWVkWzBdLFxuICAgICAgICBzcGVlZDogbW9kZWxBbmRTcGVlZFsxXSxcbiAgICAgICAgdGltZXM6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xufSBlbHNlIGlmIChpc0FuZHJvaWQkMSkge1xuICBPUy5jcHVzID0gKCkgPT4gVGkuUGxhdGZvcm0uY3B1cygpO1xuICBPUy50eXBlID0gKCkgPT4gJ0xpbnV4Jztcbn1cblxuY29uc3QgdHR5ID0ge1xuICBpc2F0dHk6ICgpID0+IGZhbHNlLFxuICBSZWFkU3RyZWFtOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0dHkuUmVhZFN0cmVhbSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfSxcbiAgV3JpdGVTdHJlYW06ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3R0eS5Xcml0ZVN0cmVhbSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufTtcblxuY29uc3QgTU9OVEhTID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuY29uc3QgdXRpbCA9IHtcbiAgZm9ybWF0OiBmb3JtYXQkMSxcbiAgZm9ybWF0V2l0aE9wdGlvbnMsXG4gIGluc3BlY3QsXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG4gIGlzQm9vbGVhbjogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gIGlzQnVmZmVyOiBCdWZmZXJNb2R1bGUuQnVmZmVyLmlzQnVmZmVyLFxuICBpc0Z1bmN0aW9uOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicsXG4gIGlzTnVsbDogdmFsdWUgPT4gdmFsdWUgPT09IG51bGwsXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsLFxuICBpc051bWJlcjogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgaXNPYmplY3Q6IHZhbHVlID0+IHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcsXG4gIGlzUHJpbWl0aXZlOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSA9PT0gbnVsbCxcbiAgaXNTdHJpbmc6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gIGlzU3ltYm9sOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnLFxuICBpc1VuZGVmaW5lZDogdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCxcbiAgaXNSZWdFeHA6IGlzUmVnRXhwLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNFcnJvcjogZSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yLFxuICBsb2c6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgdGltZSA9IGAke2RhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7ZGF0ZS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2RhdGUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICAgIC8vIFByb2R1Y2VzIG91dHB1dCBsaWtlOiBcIjIxIEZlYiAxMDowNDoyMyAtIG1lc3NhZ2VcIlxuICAgIGNvbnNvbGUubG9nKGAke2RhdGUuZ2V0RGF0ZSgpfSAke01PTlRIU1tkYXRlLmdldE1vbnRoKCldfSAke3RpbWV9IC0gJHtzdHJpbmd9YCk7XG4gIH0sXG4gIHByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29uc29sZS5sb2coYXJncy5qb2luKCcnKSk7XG4gIH0sXG4gIC8vIEZJWE1FOiBTaG91bGRuJ3QgYWRkIHRyYWlsaW5nIG5ld2xpbmUgbGlrZSBjb25zb2xlLmxvZyBkb2VzIVxuICBwdXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIHJldHVybiBjb25zb2xlLmxvZyhhcmdzLmpvaW4oJ1xcbicpKTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYXJncy5qb2luKCdcXG4nKSk7XG4gIH0sXG4gIGRlYnVnOiBzdHJpbmcgPT4gY29uc29sZS5lcnJvcihgREVCVUc6ICR7c3RyaW5nfWApLFxuICB0eXBlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBzdWJjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvciBiYXNlIGNsYXNzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xudXRpbC5pbmhlcml0cyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY29uc3RydWN0b3IsICdjb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3RvciwgJ3N1cGVyQ29uc3RydWN0b3InLCAnRnVuY3Rpb24nKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUnLCAnT2JqZWN0Jyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyXycsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3RvclxuICB9KTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcmlnaW5hbCBvcmlnaW5hbCBmdW5jdGlvbiB0byB3cmFwIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBmaW5hbCBjYWxsYmFjayBhcmd1bWVudFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlXG4gKi9cbnV0aWwucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShvcmlnaW5hbCwgJ29yaWdpbmFsJywgJ0Z1bmN0aW9uJyk7XG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvcmlnaW5hbC5jYWxsKHRoaXMsIC4uLmFyZ3MsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcbiAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9yaWdpbmFsIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBhc3luYy9Qcm9taXNlIHJldHVybiB2YWx1ZSB0byBhIGNhbGxiYWNrIHN0eWxlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHByb21pc2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL2Fsd2F5cy1yZXR1cm5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9uby1jYWxsYmFjay1pbi1wcm9taXNlXG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRFcnJvciA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBmYWxzeSB2YWx1ZScpO1xuICAgICAgICB3cmFwcGVkRXJyb3IucmVhc29uID0gZXJyO1xuICAgICAgICBlcnIgPSB3cmFwcGVkRXJyb3I7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2Uvbm8tY2FsbGJhY2staW4tcHJvbWlzZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdG8gZGVwcmVjYXRlL3dyYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgbWVzc2FnZSB0byBnaXZlIHdoZW4gZGVwcmVjYXRpb24gd2FybmluZyBpcyBlbWl0dGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBkZXByZWNhdGlvbiBjb2RlIHRvIHVzZSB0byBncm91cCB3YXJuaW5nc1xuICogQHJldHVybnMge0Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXG4gKi9cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH1cbiAgLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgbGV0IHdhcm5lZCA9IGZhbHNlO1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHN0cmluZywgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8vIFRPRE86IFN1cHBvcnQgZGVidWdsb2c/IFdoYXQgaXMgb3VyIGVxdWl2YWxlbnQgb2YgcHJvY2Vzcy5lbnYoJ05PREVfREVCVUcnKT9cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbnV0aWwuZGVidWdsb2cgPSAoKSA9PiB7XG4gIHJldHVybiBub29wO1xufTtcblxuY29uc3QgREVGQVVMVF9NRVNTQUdFUyA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86J1xufTtcblxuLy8gRmFrZSBlbnVtcyB0byB1c2UgaW50ZXJuYWxseVxuY29uc3QgQ09NUEFSRV9UWVBFID0ge1xuICBPYmplY3Q6IDAsXG4gIE1hcDogMSxcbiAgU2V0OiAyXG59O1xuY29uc3QgU1RSSUNUTkVTUyA9IHtcbiAgU3RyaWN0OiAwLFxuICBMb29zZTogMVxufTtcbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBGSVhNRTogR2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIG1lc3NhZ2Ugd2l0aCBkaWZmIG9mIGFjdHVhbC9leHBlY3RlZCFcbiAgICAgIG1lc3NhZ2UgPSBgJHtERUZBVUxUX01FU1NBR0VTW29wZXJhdG9yXX1cXG5cXG5gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nO1xuICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgfVxufVxuXG4vLyBUT0RPOiBDYW4gd2UgZGVmaW5lIEFzc2VydFN0cmljdCBhbmQgQXNzZXJ0TG9vc2UgYXMgc3ViY2xhc3NlcyBvZiBhIGJhc2UgQXNzZXJ0IGNsYXNzXG4vLyB0aGF0IGNsYXNzIGhvbGRzIGltcGxzIGZvciBzaGFyZWQgbWV0aG9kcywgc3ViY2xhc3NlcyBvdmVycmlkZSBzcGVjaWZpY1xuLy8gY29tcGFyaXNvbnMgdXNlZCAoT2JqZWN0LmlzIHZzID09PSk/XG5cbmNvbnN0IGFzc2VydCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuYXNzZXJ0Lm9rID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICBsZXQgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gIC8vIENoZWNrIGlmIHZhbHVlICgxc3QgYXJnKSB3YXMgbm90IHN1cHBsaWVkIVxuICAvLyBIYXZlIHRvIHVzZSB1Z2x5IGhhY2sgb24gYXJncyBkZWZpbml0aW9uIHRvIGRvIHNvXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIC8vIFRPRE86IGdlbmVyYXRlIHJlc3Qgb2YgdGhlIG1lc3NhZ2UuIE5vZGUgYWN0dWFsbHkgcmVhZHMgdGhlIGlucHV0IGZpbGUhIFRoZSBoYWNrZWQgYnJvd3NlcmlmeSBkb2VzIG5vdCBkbyB0aGlzXG4gICAgLy8gSXQgdHJlYXRlcyBvayBmYWlsaW5nIGxpa2UgYHZhbHVlID09IHRydWVgIGZhaWxpbmdcbiAgICBtZXNzYWdlID0gJ1RoZSBleHByZXNzaW9uIGV2YWx1YXRlZCB0byBhIGZhbHN5IHZhbHVlOlxcblxcbic7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgbWVzc2FnZTtcbiAgfVxuICBjb25zdCBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIGFjdHVhbDogdmFsdWUsXG4gICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJz09J1xuICB9KTtcbiAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICB0aHJvdyBlcnI7XG59O1xuZnVuY3Rpb24gdGhyb3dFcnJvcihvYmopIHtcbiAgLy8gSWYgbWVzc2FnZSBpcyBhbiBFcnJvciBvYmplY3QsIHRocm93IHRoYXQgaW5zdGVhZCFcbiAgaWYgKG9iai5tZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyBvYmoubWVzc2FnZTtcbiAgfVxuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cbmFzc2VydC5lcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIHJldHVybjtcbiAgfVxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ2VxdWFsJ1xuICB9KTtcbn07XG5hc3NlcnQuc3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbCxcbiAgICBleHBlY3RlZCxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnXG4gIH0pO1xufTtcbmFzc2VydC5ub3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIHJldHVybjtcbiAgfVxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdEVxdWFsJ1xuICB9KTtcbn07XG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoIU9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIC8vIHByb3ZpZGVzIFNhbWVWYWx1ZSBjb21wYXJpc29uIGZvciB1c1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJ1xuICB9KTtcbn07XG5jb25zdCBpc1ByaW1pdGl2ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlID09PSBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcH0gYWN0dWFsIG1hcCB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge01hcH0gZXhwZWN0ZWQgbWFwIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge1NUUklDVE5FU1MuTG9vc2V8c3RyaWN0bmVzcy5TdHJpY3R9IHN0cmljdG5lc3MgaG93IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VzIG1lbW9pemVkIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGUgZGVlcEVxdWFsIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNYXBzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgY29uc3QgbG9vc2VDaGVja3MgPSBuZXcgU2V0KCk7IC8vIGtlZXAgdHJhY2sgb2Ygb2JqZWN0cyB3ZSBuZWVkIHRvIHRlc3QgbW9yZSBleHRlbnNpdmVseSB0aGFuIHVzaW5nICNnZXQoKS8jaGFzKClcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYWN0dWFsKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gbm9uLW51bGwgb2JqZWN0LiBXZSBuZWVkIHRvIGRvIG91ciBvd24gY2hlY2tpbmcsIG5vdCB1c2UgZ2V0KCkvaGFzKClcbiAgICAgIGxvb3NlQ2hlY2tzLmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgXCJwcmltaXRpdmVzXCJcbiAgICAgIGlmIChleHBlY3RlZC5oYXMoa2V5KSAmJiBkZWVwRXF1YWwodmFsdWUsIGV4cGVjdGVkLmdldChrZXkpLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICAvLyB5YXkhIGEgbmljZSBlYXN5IG1hdGNoIC0gYm90aCBrZXkgYW5kIHZhbHVlIG1hdGNoZWQgZXhhY3RseSAtIG1vdmUgb25cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgaW4gc3RyaWN0IG1vZGUsIGZhaWwgcmlnaHQgYXdheVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBzbyBpdCBkaWRuJ3QgbWF0Y2gga2V5L3ZhbHVlIHBlcmZlY3RseSAtIGJ1dCB3ZSdyZSBpbiBsb29zZSBtb2RlLCBzbyBmYWxsIGJhY2sgdG8gdHJ5IGFnYWluXG4gICAgICBsb29zZUNoZWNrcy5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBvbmx5IGdvIHRocm91Z2ggdGhlIHNlY29uZCBNYXAgb25jZSFcbiAgZm9yIChjb25zdCBbZXhwZWN0ZWRLZXksIGV4cGVjdGVkVmFsdWVdIG9mIGV4cGVjdGVkKSB7XG4gICAgLy8gaWYgaXQncyBub3QgYSBub24tbnVsbCBvYmplY3QgaW4gc3RyaWN0IG1vZGUsIGZhaWwhXG4gICAgLy8gKGkuZS4gaWYgaXQncyBhIHByaW1pdGl2ZSB0aGF0IGZhaWxlZCBhIG1hdGNoLCBkb24ndCBmYWxsIGJhY2sgdG8gbW9yZSBsb29zZWx5IG1hdGNoIGl0KVxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiBzaW5jZSB3ZSBzaG91bGQgYmUgcmV0dXJuaW5nIGZhbHNlIGltbWVkaWF0ZWx5IGFib3ZlXG4gICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0ICYmICEodHlwZW9mIGV4cGVjdGVkS2V5ID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZEtleSAhPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIHRlc3QgaXQgLy8gVE9ETzogV2lzaCB3ZSBjb3VsZCB1c2UgI2ZpbmQoKSBsaWtlIG9uIGFuIEFycmF5LCBidXQgU2V0IGRvZXNuJ3QgaGF2ZSBpdCFcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBsb29zZUNoZWNrcykge1xuICAgICAgLy8gaWYgYm90aCBrZXkgYW5kIHZhbHVlIG1hdGNoZXNcbiAgICAgIGlmIChkZWVwRXF1YWwoa2V5LCBleHBlY3RlZEtleSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykgJiYgZGVlcEVxdWFsKGFjdHVhbC5nZXQoa2V5KSwgZXhwZWN0ZWRWYWx1ZSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsb29zZUNoZWNrcy5kZWxldGUoa2V5KTsgLy8gcmVtb3ZlIGZyb20gb3VyIGxvb3NlQ2hlY2tzIFNldCBzaW5jZSB3ZSBhbHJlYWR5IG1hdGNoZWQgaXRcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vdCBmb3VuZCwgd2UgZmFpbGVkIHRvIG1hdGNoXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBkaWQgd2UgbGVhdmUgdW4tbWF0Y2hlZCBrZXlzPyBpZiBzbywgZmFpbFxuICByZXR1cm4gbG9vc2VDaGVja3Muc2l6ZSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NldH0gYWN0dWFsIG1hcCB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1NldH0gZXhwZWN0ZWQgbWFwIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge3N0cmljdG5lc3MuTG9vc2V8c3RyaWN0bmVzcy5TdHJpY3R9IHN0cmljdG5lc3MgaG93IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VzIG1lbW9pemVkIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGUgZGVlcEVxdWFsIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVTZXRzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgY29uc3QgbG9vc2VDaGVja3MgPSBuZXcgU2V0KCk7IC8vIGtlZXAgdHJhY2sgb2YgdmFsdWVzIHdlIG5lZWQgdG8gdGVzdCBtb3JlIGV4dGVuc2l2ZWx5IHRoYW4gdXNpbmcgI2hhcygpXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYWN0dWFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIC8vIG5vbi1udWxsIG9iamVjdC4gV2UgbmVlZCB0byBkbyBvdXIgb3duIGNoZWNraW5nLCBub3QgdXNlIGhhcygpXG4gICAgICBsb29zZUNoZWNrcy5hZGQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIWV4cGVjdGVkLmhhcyh2YWx1ZSkpIHtcbiAgICAgIC8vIEZJWE1FOiBoYXMgZG9lcyBcInNhbWUtdmFsdWUtemVyb1wiIGNoZWNrLCB3aGljaCBpcyBsaWtlIE9iamVjdC5pcyBleGNlcHQgZm9yIC0wLyswIGJlaW5nIGNvbnNpZGVyZWQgZXF1YWxcbiAgICAgIC8vIHNvIG1heSBuZWVkIHRvIHNwZWNpYWwgY2FzZSB0aGF0IGhlcmUsIHRoYXQnZCBoYXZlIHRvIGJlIGluIGFuIGVsc2UgYmVsb3cgKHNpbmNlIGhhcyB3aWxsIHJldHVybiB0cnVlIGhlcmUpXG5cbiAgICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgICAgICAvLyBmYWlsZWQgXCJzYW1lLXZhbHVlXCIgbWF0Y2ggZm9yIHByaW1pdGl2ZSBpbiBzdHJpY3QgbW9kZSwgc28gZmFpbCByaWdodCBhd2F5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBkb2luZyBsb29zZSBjaGVjaywgd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gbG9vc2VyIGNoZWNrIHRoYW4gI2hhcygpLCBzbyB3ZSBjYW4ndCBqdXN0IHJldHVybiBmYWxzZSBpbW1lZGlhdGVseSBoZXJlXG4gICAgICAvLyBhZGQgdG8gc2V0IG9mIHZhbHVlcyB0byBjaGVjayBtb3JlIHRob3JvdWdobHlcbiAgICAgIGxvb3NlQ2hlY2tzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChsb29zZUNoZWNrcy5zaXplID09PSAwKSB7XG4gICAgLy8gbm8gbG9vc2UgZW5kcyB0byB0aWUgdXAsIGV2ZXJ5dGhpbmcgbWF0Y2hlZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVHJ5IHRvIHdoaXR0bGUgZG93biB0aGUgbG9vc2UgY2hlY2tzIHNldCB0byBiZSBlbXB0eS4uLlxuICAvLyBvbmx5IGdvIHRocm91Z2ggdGhlIHNlY29uZCBTZXQgb25jZSFcbiAgZm9yIChjb25zdCBleHBlY3RlZFZhbHVlIG9mIGV4cGVjdGVkKSB7XG4gICAgLy8gaWYgaXQncyBub3QgYSBub24tbnVsbCBvYmplY3QgaW4gc3RyaWN0IG1vZGUsIGZhaWwhXG4gICAgLy8gKGkuZS4gaWYgaXQncyBhIHByaW1pdGl2ZSB0aGF0IGZhaWxlZCBhIG1hdGNoLCBkb24ndCBmYWxsIGJhY2sgdG8gbW9yZSBsb29zZWx5IG1hdGNoIGl0KVxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiBzaW5jZSB3ZSBzaG91bGQgYmUgcmV0dXJuaW5nIGZhbHNlIGltbWVkaWF0ZWx5IGFib3ZlXG4gICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0ICYmICEodHlwZW9mIGV4cGVjdGVkVmFsdWUgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkVmFsdWUgIT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGxvb3NlQ2hlY2tzKSB7XG4gICAgICBpZiAoZGVlcEVxdWFsKG9iamVjdCwgZXhwZWN0ZWRWYWx1ZSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlOyAvLyBmb3VuZCBhIG1hdGNoIVxuICAgICAgICBsb29zZUNoZWNrcy5kZWxldGUob2JqZWN0KTsgLy8gcmVtb3ZlIGZyb20gb3VyIGxvb3NlQ2hlY2tzIFNldCBzaW5jZSB3ZSBtYXRjaGVkIGl0XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkaWQgd2UgbGVhdmUgdW4tbWF0Y2hlZCB2YWx1ZXM/IGlmIHNvLCBmYWlsXG4gIHJldHVybiBsb29zZUNoZWNrcy5zaXplID09PSAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYWN0dWFsIHZhbHVlIHdlIGFyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7Kn0gZXhwZWN0ZWQgdmFsdWVzIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge1NUUklDVE5FU1MuU3RyaWN0fFNUUklDVE5FU1MuTG9vc2V9IHN0cmljdG5lc3MgaG93IHN0cmljdCBhIGNvbXBhcmlzb24gdG8gZG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcmVmZXJlbmNlc10gb3B0aW9uYWwgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB0aGUgaGllcmFyY2h5XG4gKiBAcGFyYW0ge01hcDxvYmplY3QsbnVtYmVyPn0gW3JlZmVyZW5jZXMuYWN0dWFsXSBtYXBwaW5nIGZyb20gb2JqZWN0cyB2aXNpdGVkIChvbiBgYWN0dWFsYCkgdG8gdGhlaXIgZGVwdGhcbiAqIEBwYXJhbSB7TWFwPG9iamVjdCxudW1iZXI+fSBbcmVmZXJlbmNlcy5leHBlY3RlZF0gbWFwcGluZyBmcm9tIG9iamVjdHMgdmlzaXRlZCAob24gYGV4cGVjdGVkYCkgdG8gdGhlaXIgZGVwdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmVmZXJlbmNlcy5kZXB0aF0gVGhlIGN1cnJlbnQgZGVwdGggb2YgdGhlIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIC8vIGlmIHByaW1pdGl2ZXMsIGNvbXBhcmUgdXNpbmcgT2JqZWN0LmlzXG4gIC8vIFRoaXMgaGFuZGxlczogbnVsbCwgdW5kZWZpbmVkLCBudW1iZXIsIHN0cmluZywgYm9vbGVhblxuICBpZiAoaXNQcmltaXRpdmUoYWN0dWFsKSAmJiBpc1ByaW1pdGl2ZShleHBlY3RlZCkpIHtcbiAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgfVxuICB9XG5cbiAgLy8gTm93IHdlIGhhdmUgdmFyaW91cyBvYmplY3RzL2Z1bmN0aW9uczpcbiAgLy8gRGF0ZSwgRXJyb3IsIFJlZ0V4cCwgQXJyYXksIE1hcCwgU2V0LCBPYmplY3QsIEZ1bmN0aW9uLCBBcnJvdyBmdW5jdGlvbnMsIFdlYWtNYXAsIERhdGFWaWV3LCBBcnJheUJ1ZmZlciwgV2Vha1NldCwgdHlwZWQgYXJyYXlzXG4gIC8vIG5vdGFibHksIHRoaXMgaW5jbHVkZXMgXCJib3hlZFwiIHByaW1pdGl2ZXMgY3JlYXRlZCBieSBuZXcgQm9vbGVhbihmYWxzZSksIG5ldyBTdHJpbmcoJ3ZhbHVlJyksIFN5bWJvbCgnd2hhdGV2ZXInKSwgZXRjXG5cbiAgLy8gVHlwZSB0YWdzIG9mIG9iamVjdHMgc2hvdWxkIGJlIHRoZSBzYW1lXG4gIGNvbnN0IGFjdHVhbFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhY3R1YWwpO1xuICBjb25zdCBleHBlY3RlZFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCk7XG4gIGlmIChhY3R1YWxUYWcgIT09IGV4cGVjdGVkVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gW1tQcm90b3R5cGVdXSBvZiBvYmplY3RzIGFyZSBjb21wYXJlZCB1c2luZyB0aGUgU3RyaWN0IEVxdWFsaXR5IENvbXBhcmlzb24uXG4gIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgIC8vIGRvbid0IGNoZWNrIHByb3RvdHlwZSB3aGVuIGRvaW5nIFwibG9vc2VcIlxuICAgIGNvbnN0IGFjdHVhbFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhY3R1YWwpO1xuICAgIGNvbnN0IGV4cGVjdGVkUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGV4cGVjdGVkKTtcbiAgICBpZiAoYWN0dWFsUHJvdG90eXBlICE9PSBleHBlY3RlZFByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBsZXQgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5PYmplY3Q7XG4gIGlmICh1dGlsLnR5cGVzLmlzUmVnRXhwKGFjdHVhbCkpIHtcbiAgICAvLyBSZWdFeHAgc291cmNlIGFuZCBmbGFncyBzaG91bGQgbWF0Y2hcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNSZWdFeHAoZXhwZWN0ZWQpIHx8IGFjdHVhbC5mbGFncyAhPT0gZXhwZWN0ZWQuZmxhZ3MgfHwgYWN0dWFsLnNvdXJjZSAhPT0gZXhwZWN0ZWQuc291cmNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzRGF0ZShhY3R1YWwpKSB7XG4gICAgLy8gRGF0ZSdzIHVuZGVybHlpbmcgdGltZSBzaG91bGQgbWF0Y2hcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNEYXRlKGV4cGVjdGVkKSB8fCBhY3R1YWwuZ2V0VGltZSgpICE9PSBleHBlY3RlZC5nZXRUaW1lKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gRXJyb3IncyBuYW1lIGFuZCBtZXNzYWdlIG11c3QgbWF0Y2hcbiAgICBpZiAoIShleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB8fCBhY3R1YWwubmFtZSAhPT0gZXhwZWN0ZWQubmFtZSB8fCBhY3R1YWwubWVzc2FnZSAhPT0gZXhwZWN0ZWQubWVzc2FnZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY3R1YWwpKSB7XG4gICAgLy8gaWYgYXJyYXkgbGVuZ3RocyBkaWZmZXIsIHF1aWNrIGZhaWxcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpIHx8IGFjdHVhbC5sZW5ndGggIT09IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0JveGVkUHJpbWl0aXZlKGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gY2hlY2sgdGhhdCB0aGV5J3JlIHRoZSBzYW1lIHR5cGUgb2Ygd3JhcHBlZCBwcmltaXRpdmUgYW5kIHRoZW4gY2FsbCB0aGUgcmVsZXZhbnQgdmFsdWVPZigpIGZvciB0aGF0IHR5cGUgdG8gY29tcGFyZSB0aGVtIVxuICAgIGlmICh1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGV4cGVjdGVkKSB8fCAhT2JqZWN0LmlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGV4cGVjdGVkKSB8fCBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzQm9vbGVhbk9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc0Jvb2xlYW5PYmplY3QoZXhwZWN0ZWQpIHx8IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRklYTUU6IFVuY29tbWVudCB3aGVuIHdlIHN1cHBvcnQgQmlnSW50IGNyb3NzLXBsYXRmb3JtIVxuICAgICAgLy8gfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzQmlnSW50T2JqZWN0KGFjdHVhbClcbiAgICAgIC8vIFx0JiYgKCF1dGlsLnR5cGVzLmlzQmlnSW50T2JqZWN0KGV4cGVjdGVkKVxuICAgICAgLy8gXHRcdHx8IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCkgIT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpIHtcbiAgICAgIC8vIFx0cmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc1N5bWJvbE9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc1N5bWJvbE9iamVjdChleHBlY3RlZCkgfHwgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc1NldChhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzU2V0KGV4cGVjdGVkKSB8fCBhY3R1YWwuc2l6ZSAhPT0gZXhwZWN0ZWQuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLlNldDtcbiAgICAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc01hcChhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzTWFwKGV4cGVjdGVkKSB8fCBhY3R1YWwuc2l6ZSAhPT0gZXhwZWN0ZWQuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLk1hcDtcbiAgICAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG4gIH1cblxuICAvLyBOb3cgaXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgYW5kIGNvbXBhcmUgdGhlbSFcbiAgY29uc3QgYWN0dWFsS2V5cyA9IE9iamVjdC5rZXlzKGFjdHVhbCk7IC8vIGZvciBhbiBhcnJheSwgdGhpcyB3aWxsIHJldHVybiB0aGUgaW5kaWNlcyB0aGF0IGhhdmUgdmFsdWVzXG4gIGNvbnN0IGV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gYW5kIGl0IGp1c3QgbWFnaWNhbGx5IHdvcmtzXG4gIC8vIE11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG4gIGlmIChhY3R1YWxLZXlzLmxlbmd0aCAhPT0gZXhwZWN0ZWRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEFyZSB0aGV5IHRoZSBzYW1lIGtleXM/IElmIG9uZSBpcyBtaXNzaW5nLCB0aGVuIG5vLCBmYWlsIHJpZ2h0IGF3YXlcbiAgaWYgKCFhY3R1YWxLZXlzLmV2ZXJ5KGtleSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwZWN0ZWQsIGtleSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRG9uJ3QgY2hlY2sgb3duIHN5bWJvbHMgd2hlbiBkb2luZyBcImxvb3NlXCJcbiAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgY29uc3QgYWN0dWFsU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV4cGVjdGVkKTtcblxuICAgIC8vIE11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBzeW1ib2xzXG4gICAgaWYgKGFjdHVhbFN5bWJvbHMubGVuZ3RoICE9PSBleHBlY3RlZFN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhY3R1YWxTeW1ib2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEhhdmUgdG8gZmlsdGVyIHRoZW0gZG93biB0byBlbnVtZXJhYmxlIHN5bWJvbHMhXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY3R1YWxTeW1ib2xzKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhY3R1YWwsIGtleSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGV4cGVjdGVkLCBrZXkpO1xuICAgICAgICBpZiAoYWN0dWFsSXNFbnVtZXJhYmxlICE9PSBleHBlY3RlZElzRW51bWVyYWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdGhleSBkaWZmZXIgb24gd2hldGVociBzeW1ib2wgaXMgZW51bWVyYWJsZSwgZmFpbCFcbiAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxJc0VudW1lcmFibGUpIHtcbiAgICAgICAgICAvLyBpdCdzIGVudW1lcmFibGUsIGFkZCB0byBrZXlzIHRvIGNoZWNrXG4gICAgICAgICAgYWN0dWFsS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgZXhwZWN0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMhXG4gIC8vIFJlY29yZCBtYXAgZnJvbSBvYmplY3RzIHRvIGRlcHRoIGluIHRoZSBoaWVyYXJjaHlcbiAgaWYgKHJlZmVyZW5jZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZmVyZW5jZXMgPSB7XG4gICAgICBhY3R1YWw6IG5ldyBNYXAoKSxcbiAgICAgIGV4cGVjdGVkOiBuZXcgTWFwKCksXG4gICAgICBkZXB0aDogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgdGhlc2Ugb2JqZWN0cy5cbiAgICAvLyBpZiBzbywgbWFrZSBzdXJlIHRoZXkgcmVmZXIgdG8gc2FtZSBkZXB0aCBpbiBvYmplY3QgaGllcmFyY2h5XG4gICAgY29uc3QgbWVtb2l6ZWRBY3R1YWwgPSByZWZlcmVuY2VzLmFjdHVhbC5nZXQoYWN0dWFsKTtcbiAgICBpZiAobWVtb2l6ZWRBY3R1YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWVtb2l6ZWRFeHBlY3RlZCA9IHJlZmVyZW5jZXMuZXhwZWN0ZWQuZ2V0KGV4cGVjdGVkKTtcbiAgICAgIGlmIChtZW1vaXplZEV4cGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkQWN0dWFsID09PSBtZW1vaXplZEV4cGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZWZlcmVuY2VzLmRlcHRoKys7XG4gIH1cbiAgLy8gc3RvcmUgdGhlIG9iamVjdCAtPiBkZXB0aCBtYXBwaW5nXG4gIHJlZmVyZW5jZXMuYWN0dWFsLnNldChhY3R1YWwsIHJlZmVyZW5jZXMuZGVwdGgpO1xuICByZWZlcmVuY2VzLmV4cGVjdGVkLnNldChleHBlY3RlZCwgcmVmZXJlbmNlcy5kZXB0aCk7XG5cbiAgLy8gV2hlbiBjb21wYXJpbmcgTWFwcy9TZXRzLCBjb21wYXJlIGVsZW1lbnRzIGJlZm9yZSBjdXN0b20gcHJvcGVydGllc1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgaWYgKGNvbXBhcmlzb24gPT09IENPTVBBUkVfVFlQRS5TZXQpIHtcbiAgICByZXN1bHQgPSBjb21wYXJlU2V0cyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKTtcbiAgfSBlbHNlIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuTWFwKSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZU1hcHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIC8vIE5vdyBsb29wIG92ZXIga2V5cyBhbmQgY29tcGFyZSB0aGVtIHRvIGVhY2ggb3RoZXIhXG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWN0dWFsS2V5cykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0sIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gd2lwZSB0aGUgb2JqZWN0IHRvIGRlcHRoIG1hcHBpbmcgZm9yIHRoZXNlIG9iamVjdHMgbm93XG4gIHJlZmVyZW5jZXMuYWN0dWFsLmRlbGV0ZShhY3R1YWwpO1xuICByZWZlcmVuY2VzLmV4cGVjdGVkLmRlbGV0ZShleHBlY3RlZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5hc3NlcnQuZGVlcEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5Mb29zZSkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5Mb29zZSkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnRmFpbGVkJztcbiAgcmV0dXJuIHRocm93RXJyb3Ioe1xuICAgIG1lc3NhZ2VcbiAgfSk7XG59O1xuY29uc3QgTk9fRVhDRVBUSU9OID0ge307XG5mdW5jdGlvbiBleGVjdXRlKGZuKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ0Z1bmN0aW9uJyk7XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKGZuKSB7XG4gIHJldHVybiB1dGlsLnR5cGVzLmlzUHJvbWlzZShmbikgfHwgZm4gJiYgdHlwZW9mIGZuID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZm4udGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlKGZuKSB7XG4gIGxldCBwcm9taXNlO1xuICBjb25zdCBmblR5cGUgPSB0eXBlb2YgZm47XG4gIGlmIChmblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9taXNlID0gZm4oKTtcbiAgICBpZiAoIWlzUHJvbWlzZUxpa2UocHJvbWlzZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGluc3RhbmNlb2YgUHJvbWlzZSB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcImZuXCIgZnVuY3Rpb24gYnV0IGdvdCAke3R5cGVvZiBwcm9taXNlfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzUHJvbWlzZUxpa2UoZm4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmblwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbiBvciBQcm9taXNlLiBSZWNlaXZlZCB0eXBlICR7Zm5UeXBlfWApO1xuICAgIH1cbiAgICBwcm9taXNlID0gZm47XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIE5PX0VYQ0VQVElPTjtcbn1cbmFzc2VydC50aHJvd3MgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGV4ZWN1dGUoZm4pO1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgbWVzc2FnZTogJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uLicsXG4gICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByb2xsIHdpdGggaXRcbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkpIHtcbiAgICB0aHJvdyBhY3R1YWw7IC8vIHRocm93IHRoZSBFcnJvciBpdCBkaWQgZ2VuZXJhdGVcbiAgfVxufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBhc3luYyBmdW5jdGlvbiAoYXN5bmNGbiwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgY29uc3QgYWN0dWFsID0gYXdhaXQgZXhlY3V0ZVByb21pc2UoYXN5bmNGbik7XG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIC8vIEZJWE1FOiBhcHBlbmQgbWVzc2FnZSBpZiBub3QgbnVsbFxuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24uJyxcbiAgICAgIG9wZXJhdG9yOiAncmVqZWN0cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByb2xsIHdpdGggaXRcbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkpIHtcbiAgICB0aHJvdyBhY3R1YWw7IC8vIHRocm93IHRoZSBFcnJvciBpdCBkaWQgZ2VuZXJhdGVcbiAgfVxufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IChmbiwgZXJyb3IsIG1lc3NhZ2UpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gZXhlY3V0ZShmbik7XG4gIC8vIG5vIEVycm9yLCBqdXN0IHJldHVyblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByZS10aHJvd1xuICBpZiAoIWVycm9yKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG5cbiAgLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcbiAgaWYgKGNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvcikpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiAnZG9lc05vdFRocm93JyxcbiAgICAgIG1lc3NhZ2U6IGBHb3QgdW53YW50ZWQgZXhjZXB0aW9uJHttZXNzYWdlID8gJzogJyArIG1lc3NhZ2UgOiAnLid9YFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBkb2Vzbid0IG1hdGNoLCByZS10aHJvd1xuICB0aHJvdyBhY3R1YWw7XG59O1xuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBhc3luYyBmdW5jdGlvbiAoZm4sIGVycm9yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGFjdHVhbCA9IGF3YWl0IGV4ZWN1dGVQcm9taXNlKGZuKTtcbiAgLy8gbm8gRXJyb3IsIGp1c3QgcmV0dXJuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJlLXRocm93XG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cblxuICAvLyBJZiBlcnJvciBtYXRjaGVzIGV4cGVjdGVkLCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuICBpZiAoY2hlY2tFcnJvcihhY3R1YWwsIGVycm9yKSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6ICdkb2VzTm90VGhyb3cnLFxuICAgICAgbWVzc2FnZTogYEdvdCB1bndhbnRlZCBleGNlcHRpb24ke21lc3NhZ2UgPyAnOiAnICsgbWVzc2FnZSA6ICcuJ31gXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGRvZXNuJ3QgbWF0Y2gsIHJlLXRocm93XG4gIHRocm93IGFjdHVhbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gYWN0dWFsIHRoZSBhY3R1YWwgRXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uL2Jsb2NrXG4gKiBAcGFyYW0ge29iamVjdHxSZWdFeHB8RnVuY3Rpb258RXJyb3J8Q2xhc3N9IGV4cGVjdGVkIFRoZSB2YWx1ZSB0byB0ZXN0IGFnYWluc3QgdGhlIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGN1c3RvbSBtZXNzYWdlIHRvIGFwcGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIEVycm9yIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHZhbHVlL29iamVjdFxuICovXG5mdW5jdGlvbiBjaGVja0Vycm9yKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgLy8gV2hhdCB3ZSBkbyBoZXJlIGRlcGVuZHMgb24gd2hhdCBgZXhwZWN0ZWRgIGlzOlxuICAvLyBmdW5jdGlvbiAtIGNhbGwgaXQgdG8gdmFsaWRhdGVcbiAgLy8gb2JqZWN0IC0gdGVzdCBwcm9wZXJ0aWVzIGFnYWluc3QgYWN0dWFsXG4gIC8vIFJlZ2V4cCAtIHRlc3QgYWdhaW5zdCBhY3R1YWwudG9TdHJpbmcoKVxuICAvLyBFcnJvciB0eXBlIC0gY2hlY2sgdHlwZSBtYXRjaGVzXG4gIC8vIEVycm9yIGluc3RhbmNlIC0gY29tcGFyZSBwcm9wZXJ0aWVzXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHV0aWwudHlwZXMuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBkb2VzIHRoZSBlcnJvciBtYXRjaCB0aGUgUmVnRXhwIGV4cHJlc3Npb24/IGlmIHNvLCBwYXNzXG4gICAgfVxuXG4gICAgLy8gVGVzdCBwcm9wZXJ0aWVzIChgZXhwZWN0ZWRgIGlzIGVpdGhlciBhIGdlbmVyaWMgT2JqZWN0IG9yIGFuIEVycm9yIGluc3RhbmNlKVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7XG4gICAgLy8gSWYgd2UncmUgdGVzdGluZyBhZ2FpbnN0IGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLCB3ZSBuZWVkIHRvIGhhY2sgaW4gbmFtZS9tZXNzYWdlIHByb3BlcnRpZXMuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMudW5zaGlmdCgnbmFtZScsICdtZXNzYWdlJyk7IC8vIHdlIHdhbnQgdG8gY29tcGFyZSBuYW1lIGFuZCBtZXNzYWdlLCBidXQgdGhleSdyZSBub3Qgc2V0IGFzIGVudW1lcmFibGUgb24gRXJyb3JcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWVhbmluZ2Z1bCBtZXNzYWdlISBDaGVhdCBieSB0cmVhdGluZyBsaWtlIGVxdWFsaXR5IGNoZWNrIG9mIHZhbHVlc1xuICAgICAgICAgIC8vIHRoZW4gc3RlYWwgdGhlIG1lc3NhZ2UgaXQgZ2VuZXJhdGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFtrZXldLFxuICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFcnJvcih7XG4gICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgb3BlcmF0b3I6ICd0aHJvd3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvLyBUaGV5IGFsbCBtYXRjaGVkLCBwYXNzIVxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGlmIGBleHBlY3RlZGAgaXMgYSBcInR5cGVcIiBhbmQgYWN0dWFsIGlzIGFuIGluc3RhbmNlIG9mIHRoYXQgdHlwZSwgdGhlbiBwYXNzXG4gICAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPSBudWxsICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgZXhwZWN0ZWRgIGlzIGEgc3ViY2xhc3Mgb2YgRXJyb3IgYnV0IGBhY3R1YWxgIHdhc24ndCBhbiBpbnN0YW5jZSBvZiBpdCAoYWJvdmUpLCBmYWlsXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKEVycm9yLCBleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvaywgbGV0J3MgYXNzdW1lIHdoYXQncyBsZWZ0IGlzIHRoYXQgYGV4cGVjdGVkYCB3YXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLFxuICAgIC8vIHNvIGNhbGwgaXQgd2l0aCBlbXB0eSBgdGhpc2AgYW5kIHNpbmdsZSBhcmd1bWVudCBvZiB0aGUgYWN0dWFsIGVycm9yIHdlIHJlY2VpdmVkXG4gICAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuYXNzZXJ0LmlmRXJyb3IgPSB2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbDogdmFsdWUsXG4gICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgbWVzc2FnZTogYGlmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJHt2YWx1ZX1gLFxuICAgIG9wZXJhdG9yOiAnaWZFcnJvcidcbiAgfSk7XG59O1xuXG4vLyBDcmVhdGUgXCJzdHJpY3RcIiBjb3B5IHdoaWNoIG92ZXJyaWRlcyBcImxvb3NlXCIgbWV0aG9kcyB0byBjYWxsIHN0cmljdCBlcXVpdmFsZW50c1xuYXNzZXJ0LnN0cmljdCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcbi8vIFwiQ29weVwiIG1ldGhvZHMgZnJvbSBhc3NlcnQgdG8gYXNzZXJ0LnN0cmljdCFcbk9iamVjdC5hc3NpZ24oYXNzZXJ0LnN0cmljdCwgYXNzZXJ0KTtcbi8vIE92ZXJyaWRlIHRoZSBcImxvb3NlXCIgbWV0aG9kcyB0byBwb2ludCB0byB0aGUgc3RyaWN0IG9uZXNcbmFzc2VydC5zdHJpY3QuZGVlcEVxdWFsID0gYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbDtcbmFzc2VydC5zdHJpY3Qubm90RGVlcEVxdWFsID0gYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbDtcbmFzc2VydC5zdHJpY3QuZXF1YWwgPSBhc3NlcnQuc3RyaWN0RXF1YWw7XG5hc3NlcnQuc3RyaWN0Lm5vdEVxdWFsID0gYXNzZXJ0Lm5vdFN0cmljdEVxdWFsO1xuLy8gaGFuZyBzdHJpY3Qgb2ZmIGl0c2VsZlxuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHRoZSBgU3RyaW5nRGVjb2RlcmAgd2lsbCB1c2UuXG4gKi9cbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoKSB7XG4gIGxldCBlbmNvZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3V0ZjgnO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBVdGY4U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2LWxlJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgVXRmMTZTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBCYXNlNjRTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBTdHJpbmdEZWNvZGVySW1wbCh0aGlzLmVuY29kaW5nKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbnkgcmVtYWluaW5nIGlucHV0IHN0b3JlZCBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICogQnl0ZXMgcmVwcmVzZW50aW5nIGluY29tcGxldGUgVVRGLTggYW5kIFVURi0xNiBjaGFyYWN0ZXJzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzdWJzdGl0dXRpb25cbiAqIGNoYXJhY3RlcnMgYXBwcm9wcmlhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcuXG4gKlxuICogSWYgdGhlIGJ1ZmZlciBhcmd1bWVudCBpcyBwcm92aWRlZCwgb25lIGZpbmFsIGNhbGwgdG8gc3RyaW5nRGVjb2Rlci53cml0ZSgpIGlzIHBlcmZvcm1lZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZW1haW5pbmcgaW5wdXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gW2J1ZmZlcl0gY29udGFpbmluZyB0aGUgYnl0ZXMgdG8gZGVjb2RlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5faW1wbC5lbmQoYnVmZmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGRlY29kZWQgc3RyaW5nLCBlbnN1cmluZyB0aGF0IGFueSBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJzIGF0IHRoZSBlbmQgb2YgdGhlIEJ1ZmZlciwgb3JcbiAqIFR5cGVkQXJyYXksIG9yIERhdGFWaWV3IGFyZSBvbWl0dGVkIGZyb20gdGhlIHJldHVybmVkIHN0cmluZyBhbmQgc3RvcmVkIGluIGFuIGludGVybmFsIGJ1ZmZlciBmb3IgdGhlXG4gKiBuZXh0IGNhbGwgdG8gc3RyaW5nRGVjb2Rlci53cml0ZSgpIG9yIHN0cmluZ0RlY29kZXIuZW5kKCkuXG4gKiBAcGFyYW0ge0J1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBidWZmZXIgY29udGFpbmluZyB0aGUgYnl0ZXMgdG8gZGVjb2RlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuICAvLyBlbXB0eSBzdHJpbmcgZm9yIGVtcHR5IGJ1ZmZlclxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gdGhpcy5faW1wbC53cml0ZShidWZmZXIpO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzLiBXZSBvdmVycmlkZSBwYXJ0cyBvZiBpdCBmb3IgY2VydGFpbiBlbmNvZGluZ3MuIEZvciBhc2NpaS9oZXgvYmluYXJ5L2xhdGluMSB0aGUgaW1wbCBpcyBzdXBlci1lYXN5XG4gKi9cbmNsYXNzIFN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndXRmOCc7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAxO1xuICB9XG5cbiAgLy8gdGhlIGFjdHVhbCB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uIVxuICBlbmQoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgd3JpdGUoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBzaW5nbGUgYnl0ZSBjaGFyYWN0ZXIgZW5jb2RpbmdzIGFyZSBhIGNpbmNoXG4gICAgfVxuXG4gICAgcmV0dXJuICcnOyAvLyBubyBidWZmZXIsIG9yIGVtcHR5XG4gIH1cbn1cblxuLy8gRm9yIG11bHRpLWJ5dGUgZW5jb2RpbmdzLCBsZXQncyBpbXBsZW1lbnQgc29tZSBiYXNlIGxvZ2ljLi4uXG5jbGFzcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCBleHRlbmRzIFN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoZW5jb2RpbmcsIGJ5dGVzUGVyQ2hhcikge1xuICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICB0aGlzLmluY29tcGxldGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXNQZXJDaGFyKTsgLy8gdGVtcG9yYXJ5IGluY29tcGxldGUgY2hhcmFjdGVyIGJ1ZmZlclxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEluY29tcGxldGVDaGFyT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gYnl0ZXNOZWVkZWQgYnl0ZXMgbWlzc2luZyB0byBjb21wbGV0ZSB0aGUgY2hhcmFjdGVyXG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gY2hhckxlbmd0aCBieXRlcyBleHBlY3RlZCB0byBjb21wbGV0ZSB0aGUgY2hhcmFjdGVyXG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXggbG9jYXRpb24gaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgY2hhcmFjdGVyIHN0YXJ0c1xuICAgKi9cblxuICAvKipcbiAgICogR2l2ZW4gYSBCdWZmZXIsIHNlZXMgaWYgd2UgaGF2ZSBhbiBpbmNvbXBsZXRlIFwiY2hhcmFjdGVyXCIgYXQgdGhlIGVuZCBvZiBpdC5cbiAgICogUmV0dXJucyBpbmZvIG9uIHRoYXQ6XG4gICAqIC0gYnl0ZXNOZWVkZWQ6IDAtMywgbnVtYmVyIG9mIGJ5dGVzIHN0aWxsIHJlbWFpbmluZ1xuICAgKiAtIGNoYXJMZW5ndGg6IGV4cGVjdGVkIG51bWJlciBvZiBieXRlcyBmb3IgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAqIC0gaW5kZXg6IGluZGV4IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJlZ2luc1xuICAgKiBAcGFyYW0ge0J1ZmZlcn0gX2J1ZmZlciBCdWZmZXIgd2UgYXJlIGNoZWNraW5nIHRvIHNlZSBpZiBpdCBoYXMgYW4gaW5jb21wZWx0ZSBcImNoYXJhY3RlclwiIGF0IHRoZSBlbmRcbiAgICovXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhfYnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cbiAgX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCkge1xuICAgIC8vIHR5cGljYWxseSB3ZSByZXNldCBieXRlIGNvdW50IGJhY2sgdG8gMCBhbmQgY2hhcmFjdGVyIGxlbmd0aCB0byAxXG4gICAgdGhpcy5ieXRlQ291bnQgPSAwO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDE7XG4gIH1cbiAgZW5kKGJ1ZmZlcikge1xuICAgIGxldCByZXN1bHQgPSBzdXBlci5lbmQoYnVmZmVyKTtcbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIGhhdmUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJzIVxuICAgICAgcmVzdWx0ICs9IHRoaXMuX2luY29tcGxldGVFbmQoKTtcbiAgICB9XG4gICAgdGhpcy5faW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQoKTsgLy8gcmVzZXQgb3VyIGludGVybmFscyB0byBcIndpcGVcIiB0aGUgaW5jb21wbGV0ZSBidWZmZXJcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHdyaXRlKGJ1ZmZlcikge1xuICAgIC8vIGZpcnN0IGxldCdzIHNlZSBpZiB3ZSBoYWQgc29tZSBtdWx0aS1ieXRlIGNoYXJhY3RlciB3ZSBkaWRuJ3QgZmluaXNoLi4uXG4gICAgbGV0IGNoYXIgPSAnJztcbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIHN0aWxsIG5lZWRlZCBzb21lIGJ5dGVzIHRvIGZpbmlzaCB0aGUgY2hhcmFjdGVyXG4gICAgICAvLyBIb3cgbWFueSBieXRlcyBkbyB3ZSBzdGlsbCBuZWVkPyBjaGFyTGVuZ3RoIC0gYnl0ZXMgd2UgcmVjZWl2ZWRcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmJ5dGVDb3VudDsgLy8gbmVlZCA0LCBoYXZlIDE/IHRoZW4gd2UgaGF2ZSAzIFwibGVmdFwiXG5cbiAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gTWF0aC5taW4obGVmdCwgYnVmZmVyLmxlbmd0aCk7IC8vIGNvcHkgdXAgdG8gdGhhdCBtYW55IGJ5dGVzXG4gICAgICAvLyBjb3B5IGJ5dGVzIGZyb20gYGJ1ZmZlcmAgdG8gb3VyIGluY29tcGxldGUgYnVmZmVyXG4gICAgICBidWZmZXIuY29weSh0aGlzLmluY29tcGxldGUsIHRoaXMuYnl0ZUNvdW50LCAwLCBieXRlc0NvcGllZCk7XG4gICAgICB0aGlzLmJ5dGVDb3VudCArPSBieXRlc0NvcGllZDsgLy8gcmVjb3JkIGhvdyBtYW55IG1vcmUgYnl0ZXMgd2UgY29waWVkLi4uXG5cbiAgICAgIGlmIChieXRlc0NvcGllZCA8IGxlZnQpIHtcbiAgICAgICAgLy8gc3RpbGwgbmVlZCBtb3JlIGJ5dGVzIHRvIGNvbXBsZXRlIVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIHdlcmUgYWJsZSB0byBjb21wbGV0ZSwgeWF5IVxuICAgICAgLy8gZ3JhYiB0aGUgY2hhcmFjdGVyIHdlIGNvbXBsZXRlZFxuICAgICAgY2hhciA9IHRoaXMuaW5jb21wbGV0ZS5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgLy8gcmVzZXQgb3VyIGNvdW50ZXJzXG4gICAgICB0aGlzLl9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpO1xuICAgICAgLy8gZG8gd2UgaGF2ZSBhbnkgYnl0ZXMgbGVmdCBpbiB0aGlzIGJ1ZmZlcj9cbiAgICAgIGlmIChieXRlc0NvcGllZCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2hhcjsgLy8gaWYgbm90LCByZXR1cm4gdGhlIGNoYXJhY3RlciB3ZSBmaW5pc2hlZCFcbiAgICAgIH1cbiAgICAgIC8vIHdlIHN0aWxsIGhhdmUgbW9yZSBieXRlcywgc28gc2xpY2UgdGhlIGJ1ZmZlciB1cFxuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGJ5dGVzQ29waWVkLCBidWZmZXIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aGlzIGJ1ZmZlciB0byBzZWUgaWYgaXQgaW5kaWNhdGVzIHdlIG5lZWQgbW9yZSBieXRlcz9cbiAgICBjb25zdCBpbmNvbXBsZXRlQ2hhckRhdGEgPSB0aGlzLl9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpO1xuICAgIGlmIChpbmNvbXBsZXRlQ2hhckRhdGEuYnl0ZXNOZWVkZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyICsgYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBubyBpbmNvbXBsZXRlIGJ5dGVzLCByZXR1cm4gYW55IGNoYXJhY3RlciB3ZSBjb21wbGV0ZWQgcGx1cyB0aGUgYnVmZmVyXG4gICAgfVxuXG4gICAgLy8gb2sgc28gdGhlIGJ1ZmZlciBob2xkcyBhbiBpbmNvbXBsZXRlIGNoYXJhY3RlciBhdCBpdCdzIGVuZFxuICAgIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGVDaGFyRGF0YS5jaGFyTGVuZ3RoOyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgbmVlZCBmb3IgdGhlICdjaGFyYWN0ZXInXG4gICAgY29uc3QgaW5jb21wbGV0ZUNoYXJJbmRleCA9IGluY29tcGxldGVDaGFyRGF0YS5pbmRleDsgLy8gdGhpcyBpcyB0aGUgaW5kZXggb2YgdGhlIG11bHRpYnl0ZSBjaGFyYWN0ZXIgdGhhdCBpcyBpbmNvbXBsZXRlXG5cbiAgICAvLyBjb3B5IGZyb20gaW5kZXggb2YgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgdG8gZW5kIG9mIGJ1ZmZlclxuICAgIGNvbnN0IGJ5dGVzVG9Db3B5ID0gYnVmZmVyLmxlbmd0aCAtIGluY29tcGxldGVDaGFySW5kZXg7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5pbmNvbXBsZXRlLCAwLCBpbmNvbXBsZXRlQ2hhckluZGV4LCBidWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLmJ5dGVDb3VudCA9IGJ5dGVzVG9Db3B5OyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgYWN0dWFsbHkgY29waWVkXG5cbiAgICBpZiAoYnl0ZXNUb0NvcHkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAvLyBidWZmZXIgaGFkIGJ5dGVzIGJlZm9yZSB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICAgIC8vIHNvIHNtdXNoIGFueSBjaGFyYWN0ZXIgd2UgbWF5IGhhdmUgY29tcGxldGVkIHdpdGggYW55IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gdGhlIGJ1ZmZlclxuICAgICAgcmV0dXJuIGNoYXIgKyBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgaW5jb21wbGV0ZUNoYXJJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyOyAvLyBhbnkgbm93LWNvbXBsZXRlZCBjaGFyYWN0ZXIgdGhhdCB3YXMgcHJldmlvdXNseSBpbmNvbXBsZXRlLCBwb3NzaWJseSBlbXB0eVxuICB9XG59XG5cbmNsYXNzIFV0ZjhTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmOCcsIDQpO1xuICB9XG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIC8vIEZJWE1FOiBJbiBOb2RlLCB0aGV5IGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBmaXJzdCFcbiAgICAvLyBBbmQgdGhleSByZWx5IG9uIEJ1ZmZlciN0b1N0cmluZygpIHRvIGhhbmRsZSBpbmplY3RpbmcgdGhlICdcXHVmZmZkJyBjaGFyYWN0ZXIgZm9yIGJ1c3RlZCBtdWx0aS1ieXRlIHNlcXVlbmNlcyFcbiAgICAvLyBpT1MgYXBwYXJlbnRseSBqdXN0IHJldHVybnMgdW5kZWZpbmVkIGluIHRoYXQgc3BlY2lhbCBjYXNlIGFuZFxuICAgIC8vIEFuZHJvaWQgZGlmZmVycyBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd29yayBiYWNrd2FyZHMgZnJvbSB0aGUgbGFzdCBjaGFyXG4gICAgLy8gQ2FuIHdlIGNoZWF0IGhlcmUgYW5kLi4uXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvc3RyaW5nX2RlY29kZXIvYmxvYi9tYXN0ZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzI0wxNzMtTDE5OFxuICAgIC8vIC0gaWYgd2Ugc2VlIGEgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgc3RhcnQsIHZhbGlkYXRlIHRoZSBuZXh0IGNoYXJhY3RlcnMgYXJlIGNvbnRpbnVhdGlvbiBjaGFyc1xuICAgIC8vIC0gaWYgdGhleSdyZSBub3QgcmVwbGFjZSB0aGUgc2VxdWVuY2Ugd2l0aCAnXFx1ZmZmZCcsIHRyZWF0IGxpa2UgdGhhdCBtdWx0aS1ieXRlIGNoYXJhY3RlciB3YXMgXCJjb21wbGV0ZWRcIlxuXG4gICAgLy8gTm90ZSB0aGF0IGV2ZW4gaWYgd2UgZG8gaGFjayB0aGlzLCBpZiB0aGVyZSdzIHNvbWUgaW52YWxpZCBtdWx0aS1ieXRlIFVURi04IGluIHRoZSBidWZmZXIgdGhhdCBpc24ndCBhdCB0aGUgbGFzdCAzIGJ5dGVzXG4gICAgLy8gdGhlbiB3ZSdyZSBhdCB0aGUgbWVyY3kgb2YgdGhlIEpTIGVuZ2luZS9wbGF0Zm9ybSBjb2RlIGZvciBoYW5kbGluZyB0aGF0XG4gICAgLy8gSGVyZSdzIHNvbWVvbmUncyBoYWNrIHRoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9vbGVnYW56YS85OTcxNTVcblxuICAgIC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMywgY2hlY2sgM3JkIHRvIGxhc3QgYnl0ZVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgbGV0IGNoYXJMZW5ndGggPSBjaGVja0NoYXJMZW5ndGhGb3JVVEY4KGJ1ZmZlcltsZW5ndGggLSAzXSk7XG4gICAgICBpZiAoY2hhckxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMyBsYXN0IGJ5dGVzLCBuZWVkIDR0aFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAzLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IDRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAyLCBjaGVjayAybmQgdG8gbGFzdCBieXRlXG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDJdKTtcbiAgICAgIGlmIChjaGFyTGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogY2hhckxlbmd0aCAtIDIsXG4gICAgICAgICAgLy8gd2UgaGF2ZSAyIGJ5dGVzIG9mIHdoYXRldmVyIHdlIG5lZWRcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMixcbiAgICAgICAgICBjaGFyTGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMSwgY2hlY2sgbGFzdCBieXRlXG4gICAgaWYgKGxlbmd0aCA+PSAxKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDFdKTtcbiAgICAgIGlmIChjaGFyTGVuZ3RoID49IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogY2hhckxlbmd0aCAtIDEsXG4gICAgICAgICAgLy8gd2UgaGF2ZSAxIGJ5dGUgb2Ygd2hhdGV2ZXIgd2UgbmVlZFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgICAgIGNoYXJMZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSBjYXNlLCBubyBieXRlcyBuZWVkZWQgLSBlbmRzIG9uIGNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMCxcbiAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgY2hhckxlbmd0aDogMVxuICAgIH07XG4gIH1cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgcmV0dXJuICdcXHVmZmZkJzsgLy8gd2UgcmVwbGFjZSB0aGUgbWlzc2luZyBjaGFyYWN0ZXIgd2l0aCBhIHNwZWNpYWwgdXRmOCBjaGFyXG4gIH1cbn1cblxuY2xhc3MgVXRmMTZTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmMTZsZScsIDQpO1xuICB9XG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGNvbnN0IG1vZHVsbyA9IGxlbmd0aCAlIDI7XG4gICAgLy8gb2ssIHdlIGhhdmUgYSBtdWx0aXBsZSBvZiAyIGJ5dGVzXG4gICAgaWYgKG1vZHVsbyA9PT0gMCkge1xuICAgICAgLy8gaXMgdGhlIGxhc3QgYnl0ZSBhIGxlYWRpbmcvaGlnaCBzdXJyb2dhdGU/XG4gICAgICBjb25zdCBieXRlID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChieXRlID49IDB4RDggJiYgYnl0ZSA8PSAweERCKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IDIsXG4gICAgICAgICAgY2hhckxlbmd0aDogNCxcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSdyZSBnb29kLCBub3QgYSBzdXJyb2dhdGUsIHNvIHdlIGhhdmUgb3VyIG5lZWRlZCAyIGJ5dGVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieXRlc05lZWRlZDogMCxcbiAgICAgICAgY2hhckxlbmd0aDogMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvayB3ZSBoYXZlIDEgYnl0ZSBsZWZ0IG92ZXIsIGFzc3VtZSB3ZSBuZWVkIDIgdG8gZm9ybSB0aGUgY2hhcmFjdGVyXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgaW5kZXg6IGxlbmd0aCAtIDEsXG4gICAgICBjaGFyTGVuZ3RoOiAyXG4gICAgfTtcbiAgfVxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICAvLyBKdXN0IHdyaXRlIG91dCB0aGUgbGFzdCBOIGJ5dGVzLCBob3BlZnVsbHkgdGhlIGVuZ2luZSBjYW4gaGFuZGxlIGl0IGZvciB1cz9cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgdGhpcy5ieXRlQ291bnQpO1xuICB9XG59XG5jbGFzcyBCYXNlNjRTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignYmFzZTY0JywgMyk7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMzsgLy8gYWx3YXlzIDMhXG4gIH1cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBtb2R1bG8gPSBsZW5ndGggJSAzO1xuICAgIC8vIGJhc2U2NCBuZWVkcyAzIGJ5dGVzIGFsd2F5cywgc28gaWYgd2UgaGF2ZSB0aGF0IG1hbnkgKG9yIGEgbXVsdGlwbGUpLCB3ZSBoYXZlIGEgY29tcGxldGUgYnVmZmVyXG4gICAgaWYgKG1vZHVsbyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICAgIGNoYXJMZW5ndGg6IDNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gb2sgd2UgaGF2ZSAxIG9yIDIgYnl0ZXMgbGVmdCBvdmVyXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzTmVlZGVkOiAzIC0gbW9kdWxvLFxuICAgICAgLy8gYWx3YXlzIG5lZWQgMywgc28gaWYgd2UgaGF2ZSAxIGxlZnQgb3ZlciAtPiBuZWVkIDJcbiAgICAgIGluZGV4OiBsZW5ndGggLSBtb2R1bG8sXG4gICAgICBjaGFyTGVuZ3RoOiAzIC8vIGFsd2F5cyBuZWVkIDNcbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCkge1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAzOyAvLyBhbHdheXMgMyFcbiAgfVxuXG4gIF9pbmNvbXBsZXRlRW5kKCkge1xuICAgIC8vIEp1c3Qgd3JpdGUgb3V0IHRoZSBsYXN0IE4gYnl0ZXMsIGl0IHNob3VsZCBpbnNlcnQgdGhlICc9JyBwbGFjZWhvbGRlcnNcbiAgICAvLyBpdCdzIG5vdCByZWFsbHkgJ21pc3NpbmcnLydpbmNvbXBsZXRlJywganVzdCBuZWVkcyBwbGFjZWhvbGRlciBpbnNlcnRpb25cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCB0aGlzLmJ5dGVDb3VudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnl0ZSkge1xuICAvLyAxMTExMFhYWCA9PiAxMTEwID0+IDB4MUVcbiAgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkge1xuICAgIHJldHVybiA0O1xuICB9XG5cbiAgLy8gMTExMFhYWFggPT4gMTExMCA9PiAweDFFXG4gIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIC8vIDExMFhYWFhYID0+IDExMCA9PiAweDA2XG4gIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gMTtcbn1cbnZhciBTdHJpbmdEZWNvZGVyJDEgPSB7XG4gIFN0cmluZ0RlY29kZXJcbn07XG5cbmNvbnN0IGlzQW5kcm9pZCA9IFRpLlBsYXRmb3JtLm5hbWUgPT09ICdhbmRyb2lkJztcblxuLy8gS2VlcCB0cmFjayBvZiBwcmludGluZyBvdXQgb25lLXRpbWUgd2FybmluZyBtZXNzYWdlcyBmb3IgdW5zdXBwb3J0ZWQgb3BlcmF0aW9ucy9vcHRpb25zL2FyZ3VtZW50c1xuY29uc3QgcHJpbnRlZFdhcm5pbmdzID0ge307XG5mdW5jdGlvbiBvbmVUaW1lV2FybmluZyhrZXksIG1zZykge1xuICBpZiAoIXByaW50ZWRXYXJuaW5nc1trZXldKSB7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgcHJpbnRlZFdhcm5pbmdzW2tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFByaW50cyBhIG9uZS10aW1lIHdhcm5pbmcgbWVzc2FnZSB0aGF0IHdlIGRvIG5vdCBzdXBwb3J0IHRoZSBnaXZlbiBBUEkgYW5kIHBlcmZvcm1zIGFuIGVmZmVjdGl2ZSBuby1vcFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgbmFtZSBvZiB0aGUgbW9kdWxlL29iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZnVuY3Rpb24ucHJvcGVydHkgd2UgZG9uJ3Qgc3VwcG9ydFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBuby1vcCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB1bnN1cHBvcnRlZE5vb3AobW9kdWxlTmFtZSwgbmFtZSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGZxbiA9IGAke21vZHVsZU5hbWV9LiR7bmFtZX1gO1xuICAgIG9uZVRpbWVXYXJuaW5nKGZxbiwgYFwiJHtmcW59XCIgaXMgbm90IHN1cHBvcnRlZCB5ZXQgb24gVGl0YW5pdW0gYW5kIHVzZXMgYSBuby1vcCBmYWxsYmFjay5gKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIG5hbWUgb2YgdGhlIG1vZHVsZS9vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLnByb3BlcnR5IHdlIGRvbid0IHN1cHBvcnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrIHdlIGNhbGwgaW4gYSBxdWljayBzZXRUaW1lb3V0XG4gKi9cbmZ1bmN0aW9uIGFzeW5jVW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7IC8vIGVuZm9yY2Ugd2UgaGF2ZSBhIHZhbGlkIGNhbGxiYWNrXG4gIHVuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lKSgpO1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbn1cblxuLy8gVXNlZCB0byBjaG9vc2UgdGhlIGJ1ZmZlci9jaHVuayBzaXplIHdoZW4gcHVtcGluZyBieXRlcyBkdXJpbmcgY29waWVzXG5jb25zdCBDT1BZX0ZJTEVfQ0hVTktfU0laRSA9IDgwOTI7IC8vIHdoYXQgc2hvdWxkIHdlIHVzZSBoZXJlP1xuXG4vLyBLZWVwIHRyYWNrIG9mIGludGVnZXIgLT4gRmlsZVN0cmVhbSBtYXBwaW5nc1xuY29uc3QgZmlsZURlc2NyaXB0b3JzID0gbmV3IE1hcCgpO1xubGV0IGZpbGVEZXNjcmlwdG9yQ291bnQgPSA0OyAvLyBnbG9iYWwgY291bnRlciB1c2VkIHRvIHJlcG9ydCBmaWxlIGRlc2NyaXB0b3IgaW50ZWdlcnNcblxuLy8gTWFwIGZpbGUgc3lzdGVtIGFjY2VzcyBmbGFncyB0byBUaS5GaWxlc3lzdGVtLk1PREVfKiBjb25zdGFudHNcbmNvbnN0IEZMQUdTX1RPX1RJX01PREUgPSBuZXcgTWFwKCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYScsIFRpLkZpbGVzeXN0ZW0uTU9ERV9BUFBFTkQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2F4JywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYSsnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdheCsnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdhcysnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdyJywgVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3IrJywgVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3JzKycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3JywgVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3eCcsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5GTEFHU19UT19USV9NT0RFLnNldCgndysnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3d4KycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5cbi8vIENvbW1vbiBlcnJvcnNcbmNvbnN0IHBlcm1pc3Npb25EZW5pZWQgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFQUNDRVMnLCAncGVybWlzc2lvbiBkZW5pZWQnLCAtMTMsIHN5c2NhbGwsIHBhdGgpO1xuY29uc3Qgbm9TdWNoRmlsZSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VOT0VOVCcsICdubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JywgLTIsIHN5c2NhbGwsIHBhdGgpO1xuY29uc3QgZmlsZUFscmVhZHlFeGlzdHMgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFRVhJU1QnLCAnZmlsZSBhbHJlYWR5IGV4aXN0cycsIC0xNywgc3lzY2FsbCwgcGF0aCk7XG5jb25zdCBub3RBRGlyZWN0b3J5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PVERJUicsICdub3QgYSBkaXJlY3RvcnknLCAtMjAsIHN5c2NhbGwsIHBhdGgpO1xuY29uc3QgZGlyZWN0b3J5Tm90RW1wdHkgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9URU1QVFknLCAnZGlyZWN0b3J5IG5vdCBlbXB0eScsIC02Niwgc3lzY2FsbCwgcGF0aCk7XG5jb25zdCBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUlTRElSJywgJ2lsbGVnYWwgb3BlcmF0aW9uIG9uIGEgZGlyZWN0b3J5JywgLTIxLCBzeXNjYWxsLCBwYXRoKTtcbmNvbnN0IGZzID0ge1xuICBjb25zdGFudHM6IHtcbiAgICBPX1JET05MWTogMCxcbiAgICBPX1dST05MWTogMSxcbiAgICBPX1JEV1I6IDIsXG4gICAgU19JRk1UOiA2MTQ0MCxcbiAgICBTX0lGUkVHOiAzMjc2OCxcbiAgICBTX0lGRElSOiAxNjM4NCxcbiAgICBTX0lGQ0hSOiA4MTkyLFxuICAgIFNfSUZCTEs6IDI0NTc2LFxuICAgIFNfSUZJRk86IDQwOTYsXG4gICAgU19JRkxOSzogNDA5NjAsXG4gICAgU19JRlNPQ0s6IDQ5MTUyLFxuICAgIE9fQ1JFQVQ6IDUxMixcbiAgICBPX0VYQ0w6IDIwNDgsXG4gICAgT19OT0NUVFk6IDEzMTA3MixcbiAgICBPX1RSVU5DOiAxMDI0LFxuICAgIE9fQVBQRU5EOiA4LFxuICAgIE9fRElSRUNUT1JZOiAxMDQ4NTc2LFxuICAgIE9fTk9GT0xMT1c6IDI1NixcbiAgICBPX1NZTkM6IDEyOCxcbiAgICBPX0RTWU5DOiA0MTk0MzA0LFxuICAgIE9fU1lNTElOSzogMjA5NzE1MixcbiAgICBPX05PTkJMT0NLOiA0LFxuICAgIFNfSVJXWFU6IDQ0OCxcbiAgICBTX0lSVVNSOiAyNTYsXG4gICAgU19JV1VTUjogMTI4LFxuICAgIFNfSVhVU1I6IDY0LFxuICAgIFNfSVJXWEc6IDU2LFxuICAgIFNfSVJHUlA6IDMyLFxuICAgIFNfSVdHUlA6IDE2LFxuICAgIFNfSVhHUlA6IDgsXG4gICAgU19JUldYTzogNyxcbiAgICBTX0lST1RIOiA0LFxuICAgIFNfSVdPVEg6IDIsXG4gICAgU19JWE9USDogMSxcbiAgICBGX09LOiAwLFxuICAgIFJfT0s6IDQsXG4gICAgV19PSzogMixcbiAgICBYX09LOiAxLFxuICAgIFVWX0ZTX0NPUFlGSUxFX0VYQ0w6IDEsXG4gICAgQ09QWUZJTEVfRVhDTDogMVxuICB9XG59O1xuY2xhc3MgU3RhdHMge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5fZmlsZSA9IG51bGw7XG4gICAgdGhpcy5kZXYgPSAwO1xuICAgIHRoaXMuaW5vID0gMDtcbiAgICB0aGlzLm1vZGUgPSAwO1xuICAgIHRoaXMubmxpbmsgPSAwO1xuICAgIHRoaXMudWlkID0gMDtcbiAgICB0aGlzLmdpZCA9IDA7XG4gICAgdGhpcy5yZGV2ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuYmxrc2l6ZSA9IDQwOTY7IC8vIEZJWE1FOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzE1MzExL3doYXQtaXMtdGhlLWJsb2NrLXNpemUtb2YtdGhlLWlwaG9uZS1maWxlc3lzdGVtXG4gICAgdGhpcy5ibG9ja3MgPSAwO1xuICAgIHRoaXMuYXRpbWVNcyA9IHRoaXMubXRpbWVNcyA9IHRoaXMuY3RpbWVNcyA9IHRoaXMuYmlydGh0aW1lTXMgPSAwO1xuICAgIHRoaXMuYXRpbWUgPSB0aGlzLm10aW1lID0gdGhpcy5jdGltZSA9IHRoaXMuYmlydGh0aW1lID0gbmV3IERhdGUoMCk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRoaXMuX2ZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcblxuICAgICAgLy8gVE9ETzogdXNlIGxhenkgZ2V0dGVycyBoZXJlP1xuICAgICAgdGhpcy5jdGltZSA9IHRoaXMuYmlydGh0aW1lID0gdGhpcy5fZmlsZS5jcmVhdGVkQXQoKTtcbiAgICAgIHRoaXMuYXRpbWUgPSB0aGlzLm10aW1lID0gdGhpcy5fZmlsZS5tb2RpZmllZEF0KCk7XG4gICAgICB0aGlzLmF0aW1lTXMgPSB0aGlzLmF0aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuYmlydGh0aW1lTXMgPSB0aGlzLmJpcnRodGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmN0aW1lTXMgPSB0aGlzLmN0aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMubXRpbWVNcyA9IHRoaXMubXRpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5fZmlsZS5zaXplO1xuICAgICAgdGhpcy5ibG9ja3MgPSBNYXRoLmNlaWwodGhpcy5zaXplIC8gdGhpcy5ibGtzaXplKTtcbiAgICAgIC8vIFRPRE86IENhbiB3ZSBmYWtlIG91dCB0aGUgbW9kZSBiYXNlZCBvbiB0aGUgcmVhZG9ubHkvd3JpdGFibGUvZXhlY3V0YWJsZSBwcm9wZXJ0aWVzP1xuICAgIH1cbiAgfVxuXG4gIGlzRmlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5pc0ZpbGUoKTtcbiAgfVxuICBpc0RpcmVjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5pc0RpcmVjdG9yeSgpO1xuICB9XG4gIGlzQmxvY2tEZXZpY2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1N5bWJvbGljTGluaygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5zeW1ib2xpY0xpbms7XG4gIH1cbiAgaXNGSUZPKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NvY2tldCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZzLlN0YXRzID0gU3RhdHM7XG5jbGFzcyBSZWFkU3RyZWFtIHt9XG5mcy5SZWFkU3RyZWFtID0gUmVhZFN0cmVhbTtcbmNsYXNzIFdyaXRlU3RyZWFtIHt9XG5mcy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtO1xuXG4vKipcbiAqIEBjYWxsYmFjayBzdGF0c0NhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7ZnMuU3RhdHN9IHN0YXRzIC0gZmlsZSBzdGF0c1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfEJ1ZmZlcn0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9ZnMuY29uc3RhbnRzLkZfT0tdIGFjY2Vzc2liaWxpdHkgbW9kZS9jaGVja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMuYWNjZXNzID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbW9kZTtcbiAgICBtb2RlID0gZnMuY29uc3RhbnRzLkZfT0s7XG4gIH1cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLmFjY2Vzc1N5bmMocGF0aCwgbW9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx8QnVmZmVyfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbW9kZT1mcy5jb25zdGFudHMuRl9PS10gYWNjZXNzaWJpbGl0eSBtb2RlL2NoZWNrXG4gKi9cbmZzLmFjY2Vzc1N5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xuICBsZXQgbW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnMuY29uc3RhbnRzLkZfT0s7XG4gIC8vIEZfT0sgaXMganVzdCB3aGV0aGVyIGZpbGUgZXhpc3RzIG9yIG5vdCwgbm8gcGVybWlzc2lvbnMgY2hlY2tcbiAgLy8gUl9PSyBpcyByZWFkIGNoZWNrXG4gIC8vIFdfT0sgaXMgd3JpdGUgY2hlY2tcbiAgLy8gWF9PSyBpcyBleGVjdXRlIGNoZWNrIChhY3RzIGxpa2UgRl9PSyBvbiBXaW5kb3dzKVxuICBjb25zdCBmaWxlSGFuZGxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG4gIGlmICghZmlsZUhhbmRsZS5leGlzdHMoKSkge1xuICAgIHRocm93IG5vU3VjaEZpbGUoJ2FjY2VzcycsIHBhdGgpO1xuICB9XG5cbiAgLy8gVE9ETzogV2UgaGF2ZSBubyBtZWFucyBvZiB0ZXN0aW5nIGlmIGEgZmlsZSBpcyByZWFkYWJsZS4gSXQncyBhc3N1bWVkIGFsbCBmaWxlcyB0aGF0IGV4aXN0IHVuZGVyIHRoZSBhcHAgYXJlP1xuICBpZiAobW9kZSAmIGZzLmNvbnN0YW50cy5XX09LICYmICFmaWxlSGFuZGxlLndyaXRhYmxlKSB7XG4gICAgdGhyb3cgcGVybWlzc2lvbkRlbmllZCgnYWNjZXNzJywgcGF0aCk7XG4gIH1cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuWF9PSyAmJiAhZmlsZUhhbmRsZS5leGVjdXRhYmxlICYmIGZpbGVIYW5kbGUuaXNGaWxlKCkpIHtcbiAgICB0aHJvdyBwZXJtaXNzaW9uRGVuaWVkKCdhY2Nlc3MnLCBwYXRoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC4gZGF0YSBjYW4gYmUgYSBzdHJpbmcgb3IgYSBCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfEZpbGVTdHJlYW19IGZpbGUgZmlsZXBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGEgdG8gYXBwZW5kIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBtb2RlIHRvIGNyZWF0ZSBmaWxlLCBpZiBub3QgY3JlYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J2EnXSBmaWxlIHN5c3RlbSBmbGFnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGJhY2sgd2l0aCBlcnJvciBpZiBmYWlsZWRcbiAqL1xuZnMuYXBwZW5kRmlsZSA9IChmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICdhJ1xuICB9KTtcbiAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC4gZGF0YSBjYW4gYmUgYSBzdHJpbmcgb3IgYSBCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfEZpbGVTdHJlYW19IGZpbGUgZmlsZXBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGEgdG8gYXBwZW5kIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBtb2RlIHRvIGNyZWF0ZSBmaWxlLCBpZiBub3QgY3JlYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J2EnXSBmaWxlIHN5c3RlbSBmbGFnXG4gKi9cbmZzLmFwcGVuZEZpbGVTeW5jID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ2EnXG4gIH0pO1xuICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIGRhdGEsIG9wdGlvbnMpO1xuICAvLyBUT0RPOiBVc2UgVGkuRmlsZXN5c3RlbS5GaWxlLmFwcGVuZCgpIGluc3RlYWQ/XG59O1xuXG5mcy5jaG1vZCA9IChwYXRoLCBtb2RlLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2NobW9kJywgY2FsbGJhY2spO1xuZnMuY2htb2RTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZFN5bmMnKTtcbmZzLmNob3duID0gKHBhdGgsIHVpZCwgZ2lkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2Nob3duJywgY2FsbGJhY2spO1xuZnMuY2hvd25TeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG93blN5bmMnKTtcblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZnVuY3Rpb25zIHRoYXQgY2FuIG9ubHkgdGhyb3cgZXJyb3JzXG4gKlxuICogQGNhbGxiYWNrIGVycm9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdIC0gRXJyb3IgdGhyb3duXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mcy5jbG9zZSA9IChmZCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICovXG5mcy5jbG9zZVN5bmMgPSBmZCA9PiB7XG4gIGNvbnN0IHN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBzdHJlYW0uY2xvc2UoKTtcbn07XG5cbi8vIFJhdGhlciB0aGFuIHVzZSBhIGhhY2sgdG8gd3JhcCBzeW5jIHZlcnNpb24gaW4gc2V0VGltZW91dCwgdXNlIGFjdHVhbCBhc3luYyBBUElzIVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBzcmMgc291cmNlIGZpbGVuYW1lIHRvIGNvcHlcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGRlc3QgZGVzdGluYXRpb24gZmlsZW5hbWUgb2YgdGhlIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZsYWdzPTBdIG1vZGlmaWVycyBmb3IgY29weSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGVkIGF0IGVuZCBvZiBvcGVyYXRpb25cbiAqL1xuZnMuY29weUZpbGUgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBmbGFncywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgZmxhZ3MgPSAwO1xuICB9XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG5cbiAgLy8gRklYTUU6IEkgZG9uJ3Qga25vdyB3aHksIGJ1dCBjaGFuZ2luZyB0aGlzIHRvIHVzZSBUaS5GaWxlc3lzdGVtLm9wZW5TdHJlYW0obW9kZSwgcGF0aCkgZmFpbHMgKGF0IGxlYXN0IG9uIGlPUylcbiAgY29uc3Qgc3JjRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShzcmMpO1xuICBjb25zdCBzcmNTdHJlYW0gPSBzcmNGaWxlLm9wZW4oVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuICBjb25zdCBkZXN0RmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShkZXN0KTtcbiAgY29uc3QgZGVzdFN0cmVhbSA9IGRlc3RGaWxlLm9wZW4oVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbiAgcGlwZShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKi9cbmZzLmNvcHlGaWxlU3luYyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QpIHtcbiAgbGV0IGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBjb25zdCBzcmNGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHNyYyk7XG4gIGlmIChmbGFncyA9PT0gZnMuY29uc3RhbnRzLkNPUFlGSUxFX0VYQ0wgJiYgZnMuZXhpc3RzU3luYyhkZXN0KSkge1xuICAgIHRocm93IGZpbGVBbHJlYWR5RXhpc3RzKCdjb3B5RmlsZScsIGRlc3QpO1xuICB9XG4gIGlmICghc3JjRmlsZS5jb3B5KGRlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29weSAke3NyY30gdG8gJHtkZXN0fWApOyAvLyBGSVhNRTogV2hhdCBlcnJvciBzaG91bGQgd2UgZ2l2ZT9cbiAgfVxufTtcblxuLy8gVE9ETzogZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuLy8gLyoqXG4vLyAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIHBhdGggbGlrZVxuLy8gICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucywgaWYgYSBzdHJpbmcsIGl0J3MgdGhlIGVuY29kaW5nXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZ3M9J3InXSBTZWUgc3VwcG9ydCBvZiBmaWxlIHN5c3RlbSBmbGFncy5cbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSBlbmNvZGluZ1xuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5mZD1udWxsXSBmaWxlIGRlc2NyaXB0b3IsIGlmIHNwZWNpZmllZCwgYHBhdGhgIGlzIGlnbm9yZWRcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gcGVybWlzc2lvbnMgdG8gc2V0IGlmIGZpbGUgaXMgY3JlYXRlZFxuLy8gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvQ2xvc2U9dHJ1ZV0gaWYgZmFsc2UsIGZpbGUgZGVzY3JpcHRvciB3aWxsIG5vdCBiZSBjbG9zZWQ7IGlmIHRydWUgZXZlbiBvbiBlcnJvciBpdCB3aWxsIGJlIGNsb3NlZFxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5zdGFydF0gc3RhcnQgaW5kZXggb2YgcmFuZ2Ugb2YgYnl0ZXMgdG8gcmVhZCBmcm9tIGZpbGVcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuZW5kPUluZmluaXR5XSBlbmQgaW5kZXggb2YgcmFuZ2Ugb2YgYnl0ZXMgdG8gcmVhZCBmcm9tIGZpbGVcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaGlnaFdhdGVyTWFyaz02NCAqIDEwMjRdXG4vLyAgKiBAcmV0dXJucyB7ZnMuUmVhZFN0cmVhbX1cbi8vICAqL1xuLy8gZnMuY3JlYXRlUmVhZFN0cmVhbSA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4vLyBcdG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHsgZmxhZ3M6ICdyJywgZW5jb2Rpbmc6IG51bGwsIGZkOiBudWxsLCBtb2RlOiAwbzY2NiwgYXV0b0Nsb3NlOiB0cnVlLCBlbmQ6IEluZmluaXR5LCBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQgfSk7XG5cbi8vIFx0Ly8gRklYTUU6IElmIG9wdGlvbnMuZmQsIHVzZSB0aGF0IGluIHBsYWNlIG9mIHBhdGghXG4vLyBcdGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuLy8gfTtcbi8vIFRPRE86IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG5cbi8qKlxuICogQGNhbGxiYWNrIGV4aXN0c0NhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4aXN0cyAtIHdoZXRoZXIgcGF0aCBleGlzdHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gY2hlY2tcbiAqIEBwYXJhbSB7ZXhpc3RzQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnMuZXhpc3RzID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNhbGxiYWNrKGZzLmV4aXN0c1N5bmMocGF0aCkpO1xuICB9LCAxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgYSBmaWxlIG9yIGRpcmVjdG9yeSBleGlzdHMgYXQgdGhhdCBwYXRoXG4gKi9cbmZzLmV4aXN0c1N5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xuICB0cnkge1xuICAgIGZzLmFjY2Vzc1N5bmMocGF0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5mcy5mY2htb2QgPSAoZmQsIG1vZGUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNobW9kJywgY2FsbGJhY2spO1xuZnMuZmNobW9kU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNobW9kU3luYycpO1xuZnMuZmNob3duID0gKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdmY2hvd24nLCBjYWxsYmFjayk7XG5mcy5mY2hvd25TeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdmY2hvd25TeW5jJyk7XG5mcy5mZGF0YXN5bmMgPSAoZmQsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmRhdGFzeW5jJywgY2FsbGJhY2spO1xuZnMuZmRhdGFzeW5jU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmRhdGFzeW5jU3luYycpO1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZzLmZzdGF0ID0gKGZkLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCBzdGF0cztcbiAgICB0cnkge1xuICAgICAgc3RhdHMgPSBmcy5mc3RhdFN5bmMoZmQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0cyk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbX29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW19vcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcmV0dXJucyB7ZnMuU3RhdHN9IHN0YXRzIGZvciBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuZnMuZnN0YXRTeW5jID0gKGZkLCBfb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXRoID0gcGF0aEZvckZpbGVEZXNjcmlwdG9yKGZkKTtcbiAgcmV0dXJuIGZzLnN0YXRTeW5jKHBhdGgpO1xufTtcblxuLy8gVE9ETzogQWRkIHZlcnNpb25zIG9mIHRoZXNlIEFQSXM6XG4vLyBmcy5mc3luYyhmZCwgY2FsbGJhY2spXG4vLyBmcy5mc3luY1N5bmMoZmQpXG4vLyBmcy5mdHJ1bmNhdGUoZmRbLCBsZW5dLCBjYWxsYmFjaylcbi8vIGZzLmZ0cnVuY2F0ZVN5bmMoZmRbLCBsZW5dKVxuLy8gZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbi8vIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4vLyBmcy5sY2htb2QocGF0aCwgbW9kZSwgY2FsbGJhY2spXG4vLyBmcy5sY2htb2RTeW5jKHBhdGgsIG1vZGUpXG4vLyBmcy5sY2hvd24ocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKVxuLy8gZnMubGNob3duU3luYyhwYXRoLCB1aWQsIGdpZClcbi8vIGZzLmxpbmsoZXhpc3RpbmdQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaylcbi8vIGZzLmxpbmtTeW5jKGV4aXN0aW5nUGF0aCwgbmV3UGF0aClcblxuLy8gRklYTUU6IElmIHN5bWJvbGljIGxpbmsgd2UgbmVlZCB0byBmb2xsb3cgbGluayB0byB0YXJnZXQgdG8gZ2V0IHN0YXRzISBPdXIgQVBJIGRvZXNuJ3Qgc3VwcG9ydCB0aGF0IVxuZnMubHN0YXQgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IGZzLnN0YXQocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spO1xuZnMubHN0YXRTeW5jID0gKHBhdGgsIG9wdGlvbnMpID0+IGZzLnN0YXRTeW5jKHBhdGgsIG9wdGlvbnMpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2l2ZT1mYWxzZV0gcmVjdXJzaXZsZXkgY3JlYXRlIGRpcnM/XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG83NzddIHBlcm1pc3Npb25zXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLm1rZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IDBvNzc3XG4gICAgfTtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMubWtkaXJTeW5jKHBhdGgsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsKTtcbiAgfSwgMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2l2ZT1mYWxzZV0gcmVjdXJzaXZsZXkgY3JlYXRlIGRpcnM/XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG83NzddIHBlcm1pc3Npb25zXG4gKi9cbmZzLm1rZGlyU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiBvcHRpb25zXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgbW9kZTogMG83NzdcbiAgICB9KTtcbiAgfVxuICBpZiAoIXRpRmlsZS5jcmVhdGVEaXJlY3Rvcnkob3B0aW9ucy5yZWN1cnNpdmUpICYmICFvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgIGlmICh0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIC8vIGFscmVhZHkgZXhpc3RlZCFcbiAgICAgIHRocm93IGZpbGVBbHJlYWR5RXhpc3RzKCdta2RpcicsIHBhdGgpO1xuICAgIH1cbiAgICAvLyBXZSBmYWlsZWQsIHByb2JhYmx5IGJlY2F1c2Ugd2UgZGlkbid0IGFzayBmb3IgcmVjdXJzaXZlIGFuZCBwYXJlbnQgZG9lc24ndCBleGlzdCwgc28gcmVwcm9kdWNlIG5vZGUncyBlcnJvclxuICAgIHRocm93IG5vU3VjaEZpbGUoJ21rZGlyJywgcGF0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIHRlbXBEaXJDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVyIC0gZ2VuZXJhdGVkIGZvbGRlciBuYW1lXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IGRpcmVjdG9yeSBuYW1lIHByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIHByZWZpeCBlbmNvZGluZ1xuICogQHBhcmFtIHt0ZW1wRGlyQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLm1rZHRlbXAgPSAocHJlZml4LCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBhc3NlcnRBcmd1bWVudFR5cGUocHJlZml4LCAncHJlZml4JywgJ3N0cmluZycpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04J1xuICB9KTtcblxuICAvLyB0cnkgdG8gYmUgYWxsIGFzeW5jXG4gIGNvbnN0IHRyeU1rZHRlbXAgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gcmFuZG9tQ2hhcmFjdGVycyg2LCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZ2VuZXJhdGUgc2l4IHJhbmRvbSBjaGFyYWN0ZXJzXG4gICAgY29uc3QgcGF0aCA9IGAke3ByZWZpeH0ke2dlbmVyYXRlZH1gO1xuICAgIGZzLm1rZGlyKHBhdGgsIDBvNzAwLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFRVhJU1QnKSB7XG4gICAgICAgICAgLy8gcmV0cnkhXG4gICAgICAgICAgc2V0VGltZW91dCh0cnlNa2R0ZW1wLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnViYmxlIHVwIGVycm9yXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHN1Y2NlZWRlZCEgSHVycmF5IVxuICAgICAgY2FsbGJhY2sobnVsbCwgcGF0aCk7XG4gICAgfSk7XG4gIH07XG4gIHNldFRpbWVvdXQodHJ5TWtkdGVtcCwgMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmlxdWUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggZGlyZWN0b3J5IG5hbWUgcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gcHJlZml4IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwYXRoIHRvIGNyZWF0ZWQgZGlyZWN0b3J5XG4gKi9cbmZzLm1rZHRlbXBTeW5jID0gKHByZWZpeCwgb3B0aW9ucykgPT4ge1xuICBhc3NlcnRBcmd1bWVudFR5cGUocHJlZml4LCAncHJlZml4JywgJ3N0cmluZycpO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCdcbiAgfSk7XG4gIGxldCByZXRyeUNvdW50ID0gMDtcbiAgY29uc3QgTUFYX1JFVFJJRVMgPSAxMDA7XG4gIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICBjb25zdCBnZW5lcmF0ZWQgPSByYW5kb21DaGFyYWN0ZXJzKDYsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBnZW5lcmF0ZSBzaXggcmFuZG9tIGNoYXJhY3RlcnNcbiAgICBjb25zdCBwYXRoID0gYCR7cHJlZml4fSR7Z2VuZXJhdGVkfWA7XG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLCAwbzcwMCk7IC8vIGRvbid0IHRyeSByZWN1cnNpdmVcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdFRVhJU1QnKSB7XG4gICAgICAgIHRocm93IGU7IC8vIGJ1YmJsZSB1cCBlcnJvclxuICAgICAgfVxuICAgICAgLy8gbmFtZSB3YXMgbm90IHVuaXF1ZSwgc28gcmV0cnlcbiAgICAgIHJldHJ5Q291bnQrKztcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGEgdW5pcXVlIGRpcmVjdG9yeSBuYW1lIHdpdGggcHJlZml4ICR7cHJlZml4fWApO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZURlc2NyaXB0b3JDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIC0gZ2VuZXJhdGVkIGZpbGUgZGVzY3JpcHRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9MG82NjZdIGZpbGUgbW9kZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmaWxlXG4gKiBAcGFyYW0ge2ZpbGVEZXNjcmlwdG9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLm9wZW4gPSAocGF0aCwgZmxhZ3MsIG1vZGUsIGNhbGxiYWNrKSA9PiB7XG4gIC8vIGZsYWdzIGFuZCBtb2RlIGFyZSBvcHRpb25hbCwgd2UgbmVlZCB0byBoYW5kbGUgaWYgbm90IHN1cHBsaWVkIVxuICBpZiAodHlwZW9mIGZsYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBmbGFncztcbiAgICBmbGFncyA9ICdyJztcbiAgICBtb2RlID0gMG82NjY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG1vZGU7XG4gICAgbW9kZSA9IDBvNjY2O1xuICB9XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCBmaWxlRGVzY3JpcHRvcjtcbiAgICB0cnkge1xuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmcy5vcGVuU3luYyhwYXRoLCBmbGFncywgbW9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGZpbGVEZXNjcmlwdG9yKTtcbiAgfSwgMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzPSdyJ10gZmlsZSBzeXN0ZW0gYWNjZXNzIGZsYWdzXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtfbW9kZT0wbzY2Nl0gZmlsZSBtb2RlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZpbGVcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5mcy5vcGVuU3luYyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGxldCBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3InO1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcbiAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAvLyBUT0RPOiBTdXBwb3J0IGNyZWF0aW5nIGZpbGUgd2l0aCBzcGVjaWZpYyBtb2RlXG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLm9wZW5TeW5jLm1vZGUnLCAnZnMub3BlblN5bmNcXCdzIG1vZGUgcGFyYW1ldGVyIGlzIHVuc3VwcG9ydGVkIGluIFRpdGFuaXVtIGFuZCB3aWxsIGJlIGlnbm9yZWQnKTtcbiAgICBpZiAoIXRpRmlsZS5jcmVhdGVGaWxlKCkpIHtcbiAgICAgIC8vIE9oIGNyYXAsIHdlIGZhaWxlZCB0byBjcmVhdGUgdGhlIGZpbGUuIHdoeT9cbiAgICAgIGlmICghdGlGaWxlLnBhcmVudC5leGlzdHMoKSkge1xuICAgICAgICAvLyBwYXJlbnQgZG9lcyBub3QgZXhpc3QhXG4gICAgICAgIHRocm93IG5vU3VjaEZpbGUoJ29wZW4nLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNyZWF0ZSBmaWxlIGF0IHBhdGggJHtwYXRofWApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmbGFncykge1xuICAgIC8vIGZpbGUvZGlyIGV4aXN0cy4uLlxuICAgIGlmICgoZmxhZ3MuY2hhckF0KDApID09PSAndycgfHwgZmxhZ3MuY2hhckF0KDApID09PSAnYScpICYmIHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIHRyeWluZyB0byB3cml0ZSBvciBhcHBlbmQgYW5kIGl0J3MgYSBkaXJlY3RvcnksIGZhaWxcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ29wZW4nLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmxlbmd0aCA+IDEgJiYgZmxhZ3MuY2hhckF0KDEpID09PSAneCcpIHtcbiAgICAgIC8vIElmIHVzZXIgaGFzIFwiZXhjbHVzaXZlXCIgZmxhZyBvbiwgZmFpbCBpZiBmaWxlIGFscmVhZHkgZXhpc3RzXG4gICAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnb3BlbicsIHBhdGgpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aU1vZGUgPSBGTEFHU19UT19USV9NT0RFLmdldChmbGFncyk7XG4gIGlmICh0aU1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IE1ha2UgdXNlIG9mIGNvbW1vbiBlcnJvciB0eXBlL2NvZGUgZm9yIHRoaXMgb25jZSB3ZSBoYXZlIGludGVybmFsL2Vycm9ycy5qc1xuICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoYFRoZSB2YWx1ZSBcIiR7U3RyaW5nKGZsYWdzKX1cIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJmbGFnc1wiYCk7XG4gICAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJztcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUZpbGVEZXNjcmlwdG9yKHBhdGgsIHRpRmlsZS5vcGVuKHRpTW9kZSkpO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZXNSZWFkIC0gbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBwb3NpdGlvbiB3aGVyZSB0byBiZWdpbiByZWFkaW5nIGZyb20gaW4gdGhlIGZpbGVcbiAqIEBwYXJhbSB7cmVhZENhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5yZWFkID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB9XG4gIC8vIEZJWE1FOiBBbGxvdyB1c2luZyBwb3NpdGlvbiBhcmd1bWVudCFcbiAgaWYgKHBvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLnJlYWRTeW5jLnBvc2l0aW9uJywgJ2ZzLnJlYWRTeW5jXFwncyBwb3NpdGlvbiBhcmd1bWVudCBpcyB1bnN1cHBvcnRlZCBieSBUaXRhbml1bSBhbmQgd2lsbCBiZSB0cmVhdGVkIGFzIG51bGwnKTtcbiAgfVxuICB0aUZpbGVTdHJlYW0ucmVhZChidWZmZXIudG9UaUJ1ZmZlcigpLCBvZmZzZXQsIGxlbmd0aCwgcmVhZE9iaiA9PiB7XG4gICAgaWYgKCFyZWFkT2JqLnN1Y2Nlc3MpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihyZWFkT2JqLmVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHJlYWRPYmouYnl0ZXNQcm9jZXNzZWQsIGJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBfcG9zaXRpb24gd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tIGluIHRoZSBmaWxlXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gYnl0ZXMgcmVhZFxuICovXG5mcy5yZWFkU3luYyA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgX3Bvc2l0aW9uKSA9PiB7XG4gIGNvbnN0IGZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gIH1cblxuICAvLyBGSVhNRTogQWxsb3cgdXNpbmcgcG9zaXRpb24gYXJndW1lbnQhXG4gIGlmIChfcG9zaXRpb24gIT09IG51bGwpIHtcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZFN5bmMucG9zaXRpb24nLCAnZnMucmVhZFN5bmNcXCdzIHBvc2l0aW9uIGFyZ3VtZW50IGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXMgbnVsbCcpO1xuICB9XG4gIHJldHVybiBmaWxlU3RyZWFtLnJlYWQoYnVmZmVyLnRvVGlCdWZmZXIoKSwgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZXNDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ1tdfEJ1ZmZlcltdfGZzLkRpcmVudFtdfSBmaWxlcyAtIGZpbGUgbGlzdGluZ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZGlyZWN0b3J5IHRvIGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZSBmb3IgZmlsZW5hbWVzLCBpZiBgJ2J1ZmZlcidgLCByZXR1cm5zIGBCdWZmZXJgIG9iamVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2l0aEZpbGVUeXBlcz1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBgZnMuRGlyZW50YCBvYmplY3RzXG4gKiBAcGFyYW0ge2ZpbGVzQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLnJlYWRkaXIgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmcy5yZWFkZGlyU3luYyhwYXRoLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSwgMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBkaXJlY3RvcnkgdG8gbGlzdFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdG8gdXNlIGZvciBmaWxlbmFtZXMsIGlmIGAnYnVmZmVyJ2AsIHJldHVybnMgYEJ1ZmZlcmAgb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53aXRoRmlsZVR5cGVzPWZhbHNlXSBpZiB0cnVlLCByZXR1cm5zIGBmcy5EaXJlbnRgIG9iamVjdHNcbiAqIEByZXR1cm5zIHtzdHJpbmdbXXxCdWZmZXJbXXxmcy5EaXJlbnRbXX1cbiAqL1xuZnMucmVhZGRpclN5bmMgPSAoZmlsZXBhdGgsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKGZpbGVwYXRoKTtcbiAgaWYgKCFmaWxlLmV4aXN0cygpKSB7XG4gICAgdGhyb3cgbm9TdWNoRmlsZSgnc2NhbmRpcicsIGZpbGVwYXRoKTtcbiAgfVxuICBpZiAoIWZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5vdEFEaXJlY3RvcnkoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBsaXN0aW5nID0gZmlsZS5nZXREaXJlY3RvcnlMaXN0aW5nKCk7XG4gIGlmIChvcHRpb25zLndpdGhGaWxlVHlwZXMgPT09IHRydWUpIHtcbiAgICAvLyBUT0RPOiBpZiBvcHRpb25zLndpdGhGaWxlVHlwZXMgPT09IHRydWUsIHJldHVybiBmcy5EaXJlbnQgb2JqZWN0c1xuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5yZWFkZGlyXFwncyBvcHRpb25zLndpdGhGaWxlVHlwZXMgaXMgdW5zdXBwb3J0ZWQgYnkgVGl0YW5pdW0gYW5kIHN0cmluZ3Mgd2lsbCBiZSByZXR1cm5lZCcpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgcmV0dXJuIGxpc3RpbmcubWFwKG5hbWUgPT4gQnVmZmVyLmZyb20obmFtZSkpO1xuICB9XG4gIHJldHVybiBsaXN0aW5nO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZEZpbGVQb3N0T3BlbkNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBidWZmZXJcbiAqL1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtyZWFkRmlsZVBvc3RPcGVuQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlYWRGaWxlUG9zdE9wZW4oZmlsZURlc2NyaXB0b3IsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIGZzLmZzdGF0KGZpbGVEZXNjcmlwdG9yLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpbGVTaXplID0gc3RhdHMuc2l6ZTtcblxuICAgIC8vIENyZWF0ZSBhIFRpLkJ1ZmZlciB0byByZWFkIGludG9cbiAgICBjb25zdCBidWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgbGVuZ3RoOiBmaWxlU2l6ZVxuICAgIH0pO1xuXG4gICAgLy8gVXNlIFRpLlN0cmVhbS5yZWFkQWxsKHNvdXJjZVN0cmVhbSwgYnVmZmVyLCBjYWxsYmFjaykgd2hpY2ggc3BpbnMgb2ZmIGEgc2VwYXJhdGUgdGhyZWFkIHRvIHJlYWQgaW4gd2hpbGUgbG9vcCFcbiAgICBjb25zdCBzb3VyY2VTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTtcbiAgICBUaS5TdHJlYW0ucmVhZEFsbChzb3VyY2VTdHJlYW0sIGJ1ZmZlciwgcmVhZEFsbE9iaiA9PiB7XG4gICAgICBpZiAoIXJlYWRBbGxPYmouc3VjY2Vzcykge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IocmVhZEFsbE9iai5lcnJvcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBidWZmZXIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZEZpbGVDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAqL1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZWFkIGVudGlyZSBjb250ZW50cyBvZiBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggZmlsZW5hbWUgb3IgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gZW5jb2RpbmcgdG8gdXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZz0nciddIGZpbGUgc3lzdGVtIGZsYWdcbiAqIEBwYXJhbSB7cmVhZEZpbGVDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMucmVhZEZpbGUgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGZsYWc6ICdyJ1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBmbGFnOiAncidcbiAgICB9KTtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBjb25zdCB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJztcbiAgbGV0IGZpbGVEZXNjcmlwdG9yID0gcGF0aDsgLy8gbWF5IGJlIG92ZXJyaWRlbiBsYXRlclxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIHBvc3NpYmxlIEVycm9yXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSBidWZmZXIgVGkuQnVmZmVyIGluc3RhbmNlXG4gICAqL1xuICBjb25zdCBoYW5kbGVCdWZmZXIgPSAoZXJyLCBidWZmZXIpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZzLmNsb3NlU3luYyBpZiBpdCB3YXMgbm90IG9yaWdpbmFsbHkgYSBmaWxlIGRlc2NyaXB0b3JcbiAgICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgICBmcy5jbG9zZVN5bmMoZmlsZURlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRyaW0gYnVmZmVyIGlmIHdlIGRpZG4ndCByZWFkIGZ1bGwgc2l6ZT9cblxuICAgIGNhbGxiYWNrKG51bGwsIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpKTtcbiAgfTtcbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLm9wZW4ocGF0aCwgb3B0aW9ucy5mbGFnLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWxlRGVzY3JpcHRvciA9IGZkO1xuICAgICAgcmVhZEZpbGVQb3N0T3BlbihmZCwgaGFuZGxlQnVmZmVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZWFkRmlsZVBvc3RPcGVuKHBhdGgsIGhhbmRsZUJ1ZmZlcik7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gZW5jb2RpbmcgdG8gdXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZz0nciddIGZpbGUgc3lzdGVtIGZsYWdcbiAqIEByZXR1cm5zIHtzdHJpbmd8QnVmZmVyfSBzdHJpbmcgaWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkLCBvdGhlcndpc2UgQnVmZmVyXG4gKi9cbmZzLnJlYWRGaWxlU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogbnVsbCxcbiAgICBmbGFnOiAncidcbiAgfSk7XG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIHBhdGggPT09ICdudW1iZXInO1xuICBjb25zdCBmaWxlRGVzY3JpcHRvciA9IHdhc0ZpbGVEZXNjcmlwdG9yID8gcGF0aCA6IGZzLm9wZW5TeW5jKHBhdGgsIG9wdGlvbnMuZmxhZyk7IC8vIHVzZSBkZWZhdWx0IG1vZGVcblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTtcbiAgLy8gSnVzdCB1c2Ugb3VyIG93biBBUEkgdGhhdCByZWFkcyBmdWxsIHN0cmVhbSBpblxuICBjb25zdCBidWZmZXIgPSBUaS5TdHJlYW0ucmVhZEFsbCh0aUZpbGVTdHJlYW0pO1xuXG4gIC8vIGZzLmNsb3NlU3luYyBpZiBpdCB3YXMgbm90IG9yaWdpbmFsbHkgYSBmaWxlIGRlc2NyaXB0b3JcbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gIH1cblxuICAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cbiAgcmV0dXJuIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpO1xufTtcblxuLy8gVE9ETzogZnMucmVhZGxpbmsocGF0aFssIG9wdGlvbnNdLCBjYWxsYmFjaylcbi8vIFRPRE86IGZzLnJlYWRsaW5rU3luYyhwYXRoWywgb3B0aW9uc10pXG5cbi8qKlxuICogQGNhbGxiYWNrIHJlYWxwYXRoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSByZXNvbHZlZFBhdGggdGhlIHJlc29sdmVkIHBhdGhcbiAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBmaWxlcGF0aCBvcmlnaW5hbCBmaWxlcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb3NuIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdXNlZCBmb3IgcmV0dXJuZWQgb2JqZWN0LiBJZiAnYnVmZmVyXCIsIHdlJ2xsIHJldHVybiBhIEJ1ZmZlciBpbiBwYWxjZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtyZWFscGF0aENhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5yZWFscGF0aCA9IChmaWxlcGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IG9wdGlvbnMpO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4J1xuICB9KTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBubyBzeW1saW5rcywgd2hpY2ggd2UgcmVhbGx5IGRvbid0IGhhdmUgZnVsbCBzdXBwb3J0IGZvciBpbiBvdXIgU0RLIGFueXdheXMuXG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5ub3JtYWxpemUoZmlsZXBhdGgpO1xuICAgIGZzLmV4aXN0cyhyZXN1bHQsIHJlc3VsdEV4aXN0cyA9PiB7XG4gICAgICBpZiAocmVzdWx0RXhpc3RzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBCdWZmZXIuZnJvbShyZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyBwYXRoIGRvZXNuJ3QgZXhpc3QsIHRyeSBlYWNoIHNlZ21lbnQgdW50aWwgd2UgZmluZCBmaXJzdCB0aGF0IGRvZXNuJ3RcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gcmVzdWx0LnNwbGl0KHBhdGguc2VwKTsgLy8gRklYTUU6IERyb3AgbGFzdCBzZWdtZW50IGFzIHdlIGFscmVhZHkga25vdyB0aGUgZnVsbCBwYXRoIGRvZXNuJ3QgZXhpc3Q/XG4gICAgICBsZXQgcGFydGlhbEZpbGVQYXRoID0gJyc7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgLy8gaGFuZGxlIHR5cGljYWwgY2FzZSBvZiBlbXB0eSBmaXJzdCBzZWdtZW50IHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW4gYXN5bmMgc2V0VGltZW91dCB0byBnZXQgdG8gZmlyc3QgcmVhbCBjYXNlXG4gICAgICBpZiAoc2VnbWVudHNbaW5kZXhdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCh0cnlQYXRoLCAxKTtcbiAgICAgIGZ1bmN0aW9uIHRyeVBhdGgoKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBkb24ndCBydW4gcGFzdCBlbmQgb2Ygc2VnbWVudHMsIHRocm93IGVycm9yIGZvciByZXNvbHZlZCBwYXRoXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5vU3VjaEZpbGUocmVzdWx0KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBncmFiIG5leHQgc2VnbWVudFxuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXgrK107XG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIGlmIGl0J3MgYW4gZW1wdHkgc2VnbWVudC4uLlxuICAgICAgICAgIC8vIHRyeSBhZ2FpbiBhdCBuZXh0IGluZGV4XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWwgY2FzZVxuICAgICAgICBwYXJ0aWFsRmlsZVBhdGggKz0gcGF0aC5zZXAgKyBzZWdtZW50O1xuICAgICAgICAvLyBjaGVjayBpZiBwYXRoIHVwIHRvIHRoaXMgcG9pbnQgZXhpc3RzLi4uXG4gICAgICAgIGZzLmV4aXN0cyhwYXJ0aWFsRmlsZVBhdGgsIHBhcnRpYWxFeGlzdHMgPT4ge1xuICAgICAgICAgIGlmICghcGFydGlhbEV4aXN0cykge1xuICAgICAgICAgICAgLy8gbm9wZSwgdGhyb3cgdGhlIEVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobm9TdWNoRmlsZSgnbHN0YXQnLCBwYXJ0aWFsRmlsZVBhdGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdHJ5IGFnYWluIGF0IG5leHQgZGVwdGggb2YgZGlyIHRyZWVcbiAgICAgICAgICBzZXRUaW1lb3V0KHRyeVBhdGgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgMSk7XG59O1xuZnMucmVhbHBhdGgubmF0aXZlID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGZzLnJlYWxwYXRoKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gZmlsZXBhdGggb3JpZ2luYWwgZmlsZXBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHVzZWQgZm9yIHJldHVybmVkIG9iamVjdC4gSWYgJ2J1ZmZlclwiLCB3ZSdsbCByZXR1cm4gYSBCdWZmZXIgaW4gcGFsY2Ugb2YgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd8QnVmZmVyfVxuICovXG5mcy5yZWFscGF0aFN5bmMgPSAoZmlsZXBhdGgsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCdcbiAgfSk7XG4gIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgbm8gc3ltbGlua3MsIHdoaWNoIHdlIHJlYWxseSBkb24ndCBoYXZlIGZ1bGwgc3VwcG9ydCBmb3IgaW4gb3VyIFNESyBhbnl3YXlzLlxuICBjb25zdCByZXN1bHQgPSBwYXRoLm5vcm1hbGl6ZShmaWxlcGF0aCk7XG4gIGlmICghZnMuZXhpc3RzU3luYyhyZXN1bHQpKSB7XG4gICAgLy8gdGhpcyBwYXRoIGRvZXNuJ3QgZXhpc3QsIHRyeSBlYWNoIHNlZ21lbnQgdW50aWwgd2UgZmluZCBmaXJzdCB0aGF0IGRvZXNuJ3RcbiAgICBjb25zdCBzZWdtZW50cyA9IHJlc3VsdC5zcGxpdChwYXRoLnNlcCk7XG4gICAgbGV0IHBhcnRpYWxGaWxlUGF0aCA9ICcnO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcGFydGlhbEZpbGVQYXRoICs9IHBhdGguc2VwICsgc2VnbWVudDtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwYXJ0aWFsRmlsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5vU3VjaEZpbGUoJ2xzdGF0JywgcGFydGlhbEZpbGVQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5mcy5yZWFscGF0aFN5bmMubmF0aXZlID0gKHBhdGgsIG9wdGlvbnMpID0+IHtcbiAgZnMucmVhbHBhdGhTeW5jKHBhdGgsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBvbGRQYXRoIHNvdXJjZSBmaWxlcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gbmV3UGF0aCBkZXN0aW5hdGlvbiBmaWxlcGF0aFxuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5yZW5hbWUgPSAob2xkUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBvbGRQYXRoIHNvdXJjZSBmaWxlcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gbmV3UGF0aCBkZXN0aW5hdGlvbiBmaWxlcGF0aFxuICovXG5mcy5yZW5hbWVTeW5jID0gKG9sZFBhdGgsIG5ld1BhdGgpID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUob2xkUGF0aCk7XG4gIC8vIHNyYyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0P1xuICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgIGNvbnN0IGVyciA9IG5vU3VjaEZpbGUoJ3JlbmFtZScsIG9sZFBhdGgpO1xuICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9IC0+ICcke25ld1BhdGh9J2A7XG4gICAgZXJyLmRlc3QgPSBuZXdQYXRoO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjb25zdCBkZXN0RmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKG5ld1BhdGgpO1xuICBpZiAoZGVzdEZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIC8vIGRlc3QgaXMgYSBkaXJlY3RvcnkgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IGVyciA9IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3JlbmFtZScsIG9sZFBhdGgpO1xuICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9IC0+ICcke25ld1BhdGh9J2A7XG4gICAgZXJyLmRlc3QgPSBuZXdQYXRoO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBsZXQgdGVtcFBhdGg7XG4gIGlmIChkZXN0RmlsZS5pc0ZpbGUoKSkge1xuICAgIC8vIGRlc3RpbmF0aW9uIGZpbGUgZXhpc3RzLCB3ZSBzaG91bGQgb3ZlcndyaXRlXG4gICAgLy8gT3VyIEFQSXMgd2lsbCBmYWlsIGlmIHdlIHRyeSwgc28gZmlyc3QgbGV0J3MgbWFrZSBhIGJhY2t1cCBjb3B5IGFuZCBkZWxldGUgdGhlIHRoZSBvcmlnaW5hbFxuICAgIHRlbXBQYXRoID0gcGF0aC5qb2luKGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihUaS5GaWxlc3lzdGVtLnRlbXBEaXJlY3RvcnksICdyZW5hbWUtJykpLCBwYXRoLmJhc2VuYW1lKG5ld1BhdGgpKTtcbiAgICBkZXN0RmlsZS5tb3ZlKHRlbXBQYXRoKTtcbiAgfVxuICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuICB0cnkge1xuICAgIHN1Y2Nlc3MgPSB0aUZpbGUubW92ZShuZXdQYXRoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAodGVtcFBhdGgpIHtcbiAgICAgIC8vIHdlIHRlbXBvcmFyaWx5IGNvcGllZCB0aGUgZXhpc3RpbmcgZGVzdGluYXRpb24gdG8gYmFjayBpdCB1cC4uLlxuICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gbW92ZSB3b3JrZWQsIHNvIHdlIGNhbiB3aXBlIGl0IGF3YXkgd2hlbmV2ZXIuLi5cbiAgICAgICAgZnMudW5saW5rKHRlbXBQYXRoLCBfZXJyID0+IHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgaXQgYmFjaywgYmVjYXVzZSB3ZSBmYWlsZWQhXG4gICAgICAgIGNvbnN0IHRtcEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZSh0ZW1wUGF0aCk7XG4gICAgICAgIHRtcEZpbGUubW92ZShuZXdQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMucm1kaXIgPSAocGF0aCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnJtZGlyU3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICovXG5mcy5ybWRpclN5bmMgPSBwYXRoID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG4gIGlmICghdGlGaWxlLmRlbGV0ZURpcmVjdG9yeShmYWxzZSkpIHtcbiAgICAvLyBkbyBub3QgZGVsZXRlIGNvbnRlbnRzIVxuICAgIC8vIHdlIGZhaWxlZCB0byBkZWxldGUsIGJ1dCB3aHk/XG4gICAgLy8gZG9lcyBpdCBleGlzdD9cbiAgICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbm9TdWNoRmlsZSgncm1kaXInLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gaXMgaXQgYSBmaWxlP1xuICAgIGlmICh0aUZpbGUuaXNGaWxlKCkpIHtcbiAgICAgIHRocm93IG5vdEFEaXJlY3RvcnkoJ3JtZGlyJywgcGF0aCk7XG4gICAgfVxuICAgIC8vIGlzIGl0IG5vdCBlbXB0eT9cbiAgICBjb25zdCBzdWJGaWxlcyA9IHRpRmlsZS5nZXREaXJlY3RvcnlMaXN0aW5nKCk7XG4gICAgaWYgKHN1YkZpbGVzICYmIHN1YkZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IGRpcmVjdG9yeU5vdEVtcHR5KCdybWRpcicsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcGFyYW0ge3N0YXRzQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLnN0YXQgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYWxsYmFjayhudWxsLCBuZXcgZnMuU3RhdHMocGF0aCkpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gcGF0aCBmaWxlcGF0aCBvciBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbX29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW19vcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcmV0dXJucyB7ZnMuU3RhdHN9XG4gKi9cbmZzLnN0YXRTeW5jID0gKHBhdGgsIF9vcHRpb25zKSA9PiBuZXcgZnMuU3RhdHMocGF0aCk7XG5mcy5zeW1saW5rID0gKHRhcmdldCwgcGF0aCwgdHlwZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdzeW1saW5rJywgY2FsbGJhY2spO1xuZnMuc3ltbGlua1N5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3N5bWxpbmtTeW5jJyk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW49MF0gYnl0ZXMgdG8gdHJpbSB0b1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy50cnVuY2F0ZSA9IChwYXRoLCBsZW4sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBsZW4pO1xuICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpIHtcbiAgICBsZW4gPSAwO1xuICB9XG4gIGlmIChsZW4gPD0gMCkge1xuICAgIGZzLndyaXRlRmlsZShwYXRoLCAnJywgY2FsbGJhY2spOyAvLyBlbXB0eSB0aGUgZmlsZVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIGhhdmUgdG8gcmV0YWluIHNvbWUgb2YgdGhlIGZpbGUhXG4gIC8vIHl1Y2ssIHNvIGxldCdzIHJlYWQgd2hhdCB3ZSBuZWVkIHRvIHJldGFpbiwgdGhlbiBvdmVyd3JpdGUgZmlsZSB3aXRoIGl0XG4gIGZzLm9wZW4ocGF0aCwgKGVyciwgZmQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGxlbik7XG4gICAgZnMucmVhZChmZCwgYnVmZmVyLCAwLCBsZW4sIG51bGwsIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgZnMuY2xvc2UoZmQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBmcy53cml0ZUZpbGUocGF0aCwgYnVmZmVyLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqL1xuZnMudHJ1bmNhdGVTeW5jID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgbGV0IGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgLy8gZW1wdHkgdGhlIGZpbGVcbiAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGgsICcnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHBhdGgpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgZnMucmVhZFN5bmMoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsKTtcbiAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCBidWZmZXIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy51bmxpbmsgPSAocGF0aCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mcy51bmxpbmtTeW5jID0gcGF0aCA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuICBpZiAoIXRpRmlsZS5kZWxldGVGaWxlKCkpIHtcbiAgICAvLyB3ZSBmYWlsZWQsIGJ1dCB3aHk/XG4gICAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5vU3VjaEZpbGUoJ3VubGluaycsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodGlGaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3VubGluaycsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcbmZzLnVud2F0Y2hGaWxlID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICd1bndhdGNoRmlsZScpO1xuZnMudXRpbWVzID0gKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICd1dGltZXMnLCBjYWxsYmFjayk7XG5mcy51dGltZXNTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICd1dGltZXNTeW5jJyk7XG5mcy53YXRjaCA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnd2F0Y2gnKTtcbmZzLndhdGNoRmlsZSA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnd2F0Y2hGaWxlJyk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBmaWxlIGZpbGUgcGF0aCBvciBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld30gZGF0YSBkYXRhIHRvIHdyaXRlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zLCBlbmNvZGluZyBpZiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZmxhZz0ndyddIG9wdGlvbnNcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMud3JpdGVGaWxlID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ3cnXG4gIH0pO1xuXG4gIC8vIFR1cm4gaW50byBmaWxlIGRlc2NyaXB0b3JcbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgZmlsZSA9PT0gJ251bWJlcic7XG4gIGxldCBmaWxlRGVzY3JpcHRvciA9IGZpbGU7IC8vIG1heSBiZSBvdmVycmlkZW4gbGF0ZXJcbiAgY29uc3QgZmluaXNoID0gZXJyID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZnMuY2xvc2UgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG4gICAgZnMuY2xvc2UoZmlsZURlc2NyaXB0b3IsIGNhbGxiYWNrKTtcbiAgfTtcbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLm9wZW4oZmlsZSwgb3B0aW9ucy5mbGFnLCBvcHRpb25zLm1vZGUsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZpbGVEZXNjcmlwdG9yID0gZmQ7XG4gICAgICBmcy53cml0ZShmaWxlRGVzY3JpcHRvciwgZGF0YSwgZmluaXNoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmcy53cml0ZShmaWxlRGVzY3JpcHRvciwgZGF0YSwgZmluaXNoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IGZpbGUgZmlsZSBwYXRoIG9yIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBkYXRhIGRhdGEgdG8gd3JpdGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnMsIGVuY29kaW5nIGlmIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZmxhZz0ndyddIG9wdGlvbnNcbiAqL1xuZnMud3JpdGVGaWxlU3luYyA9IChmaWxlLCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICd3J1xuICB9KTtcblxuICAvLyBUdXJuIGludG8gZmlsZSBkZXNjcmlwdG9yXG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIGZpbGUgPT09ICdudW1iZXInO1xuICBjb25zdCBmaWxlRGVzY3JpcHRvciA9IHdhc0ZpbGVEZXNjcmlwdG9yID8gZmlsZSA6IGZzLm9wZW5TeW5jKGZpbGUsIG9wdGlvbnMuZmxhZywgb3B0aW9ucy5tb2RlKTtcblxuICAvLyBpZiBkYXRhIGlzIGEgc3RyaW5nLCBtYWtlIGl0IGEgYnVmZmVyIGZpcnN0XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKCcnICsgZGF0YSwgb3B0aW9ucy5lbmNvZGluZyk7IC8vIGZvcmNlIGRhdGEgdG8gYmUgYSBzdHJpbmcsIGhhbmRsZXMgY2FzZSB3aGVyZSBpdCdzIHVuZGVmaW5lZCBhbmQgd3JpdGVzICd1bmRlZmluZWQnIHRvIGZpbGUhXG4gIH1cblxuICBmcy53cml0ZVN5bmMoZmlsZURlc2NyaXB0b3IsIGRhdGEpO1xuXG4gIC8vIGNsb3NlIGlmIHVzZXIgZGlkbid0IGdpdmUgdXMgZmlsZSBkZXNjcmlwdG9yXG4gIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICBmcy5jbG9zZVN5bmMoZmlsZURlc2NyaXB0b3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayB3cml0ZVRpRmlsZVN0cmVhbUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd3JpdHRlbiAtIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VGkuRmlsZXN5c3RlbS5GaWxlU3RyZWFtfSB0aUZpbGVTdHJlYW0gZmlsZSBzdHJlYW1cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyIHdlJ3JlIHdyaXRpbmdcbiAqIEBwYXJhbSB7d3JpdGVUaUZpbGVTdHJlYW1DYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIFRpLlN0cmVhbS53cml0ZSh0aUZpbGVTdHJlYW0sIGJ1ZmZlci50b1RpQnVmZmVyKCksIHdyaXRlT2JqID0+IHtcbiAgICBpZiAoIXdyaXRlT2JqLnN1Y2Nlc3MpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih3cml0ZU9iai5lcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB3cml0ZU9iai5ieXRlc1Byb2Nlc3NlZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZTogQnVmZmVyIG9yIHN0cmluZ1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZTsgT1Igb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gKGlmIHN0cmluZylcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiBieXRlcyB0byB3cml0ZSBpZiBCdWZmZXI7IE9SIGV4cGVjdGVkIHN0cmluZyBlbmNvZGluZ1xuICogQHBhcmFtIHt3cml0ZUNhbGxiYWNrfGludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gKGlmIEJ1ZmZlcik7IE9SIGFzeW5jIGNhbGxiYWNrIGlmIHN0cmluZ1xuICogQHBhcmFtIHt3cml0ZUNhbGxiYWNrfSBbY2FsbGJhY2tdIGFzeW5jIGNhbGxiYWNrIChpZiBCdWZmZXIpXG4gKi9cbmZzLndyaXRlID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKTtcbiAgaWYgKGlzQnVmZmVyKSB7XG4gICAgd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVTdHJpbmcoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBidWZmZXIgY29udGVudHMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldF0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtsZW5ndGhdICBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3Bvc2l0aW9uXSBwb3NpdGlvblxuICogQHJldHVybnMge2ludGVnZXJ9IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKi9cbmZzLndyaXRlU3luYyA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgY29uc3QgaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKTtcbiAgaWYgKGlzQnVmZmVyKSB7XG4gICAgcmV0dXJuIHdyaXRlQnVmZmVyU3luYyhmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHdyaXRlU3RyaW5nU3luYyhmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG4vLyBUT0RPOiBBZGQgRmlsZUhhbmRsZSBjbGFzcyB0byBtYXRjaCBOb2RlJ3Mgd3JhcHBlciBmb3IgZmlsZSBkZXNjcmlwdG9ycy4gUmUtcHVycG9zZSBvdXIgb3duIHdyYXBwZXI/XG4vLyBUT0RPOiBBZGQgdGhlIGZzLnByb21pc2VzIEFQSSFcblxuLy8gVE9ETzogRGVmaW5lIGZzLkRpcmVudCBjbGFzcywgd2hpY2ggY2FuIHNpbXBseSB3cmFwIGEgVGkuRmlsZXN5c3RlbS5GaWxlIChhbmQgaXMgdmVyeSBzaW1pbGFyIHRvIGZzLlN0YXRzISlcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUcmFja3MgdGhlIHBhaXJpbmcgb2YgdGhlIG51bWJlciB3ZSB1c2UgdG8gcmVwcmVzZW50IHRoZSBmaWxlIGV4dGVybmFsbHksIHRoZSBmaWxlcGF0aCBpdCdzIHBvaW50aW5nIGF0LCBhbmQgdGhlIHN0cmVhbSBwb2ludGluZyBhdCBpdC5cbiAqL1xuY2xhc3MgRmlsZURlc2NyaXB0b3Ige1xuICBjb25zdHJ1Y3RvcihudW1iZXIsIHBhdGgsIHN0cmVhbSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcGlwZShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKSB7XG4gIGlmIChpc0FuZHJvaWQpIHtcbiAgICAvLyBBbmRyb2lkIGlzIHByb2JhYmx5IGJldHRlciBvZmYgd2l0aCBUaS5TdHJlYW0ud3JpdGVTdHJlYW0sIGxlc3Mgb3ZlcmhlYWQgYmFjayBhbmQgZm9ydGggdGhlIGJyaWRnZVxuICAgIC8vIFRob3VnaCBBbmRyb2lkIGRvZXMgc3VwcG9ydCB0aGUgVGkuU3RyZWFtLnB1bXAvVGkuU3RyZWFtLndyaXRlIHBhdHRlcm4gdXNpbmcgYm90aCBBUElzIGFzeW5jXG4gICAgcGlwZVZpYVdyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBpT1MgaGFzIHNvbWUuLi4gaXNzdWVzIHdpdGggd3JpdGVTdHJlYW0gY2FsbGluZyB0aGUgY2FsbGJhY2sgZXZlcnkgaXRlcmF0aW9uIG9mIHRoZSBsb29wICphbmQqIGF0IHRoZSBlbmRcbiAgLy8gaXQgYWxzbyBkb2Vzbid0IHBsYXkgYXMgZXhwZWN0ZWQgd2hlbiBkb2luZyBUaS5TdHJlYW0ucHVtcCBhbmQgVGkuU3RyZWFtLndyaXRlIGFzeW5jIGVhY2hcbiAgLy8gaXQgZW5kcyB1cCBkb2luZyBhbGwgcmVhZHMgZmlyc3QgYW5kIHRoZW4gYWxsIHdyaXRlc1xuICAvLyBzbyB3ZSBoYXZlIHRvIGhhY2sgaGVyZSBhbmQgZG8gVGkuU3RyZWFtLnB1bXAgYXN5bmMsIGJ1dCBlYWNoIHRpbWUgdGhlIHJlYWQgY2FsbGJhY2sgaGFwcGVucyB3ZSBkbyBhICpzeW5jKiB3cml0ZSBpbnNpZGUgaXRcbiAgLy8gU2VlIGh0dHBzOi8vamlyYS1hcmNoaXZlLnRpdGFuaXVtc2RrLmNvbS9USU1PQi0yNzMyMVxuICBwaXBlVmlhUHVtcChzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcGlwZVZpYVdyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgVGkuU3RyZWFtLndyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgQ09QWV9GSUxFX0NIVU5LX1NJWkUsIHJlc3VsdCA9PiB7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpKTtcbiAgICB9XG5cbiAgICAvLyBBbmRyb2lkIHdpbGwgb25seSBjYWxsIHRoaXMgYXQgdGhlIGVuZCBvciBlcnJvciwgc28gd2UgY2FuIHNhZmVseSBhc3N1bWUgd2UncmUgZG9uZSBoZXJlLlxuICAgIC8vIGlPUyB3aWxsIGNhbGwgcGVyIGxvb3AgaXRlcmF0aW9uLCBzZWUgaHR0cHM6Ly9qaXJhLWFyY2hpdmUudGl0YW5pdW1zZGsuY29tL1RJTU9CLTI3MzIwXG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gc3JjU3RyZWFtIGlucHV0IHN0cmVhbSB3ZSdyZSByZWFkaW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuSU9TdHJlYW19IGRlc3RTdHJlYW0gb3V0cHV0IHN0cmVhbSB3ZSdyZSB3cml0aW5nIHRvXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHBpcGVWaWFQdW1wKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgVGkuU3RyZWFtLnB1bXAoc3JjU3RyZWFtLCBvYmogPT4ge1xuICAgIGlmICghb2JqLnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3Iob2JqLmVycm9yKSk7IC8vIFRPRE86IHNldCBjb2RlIHZpYSB3cml0ZU9iai5jb2RlP1xuICAgIH1cblxuICAgIGlmIChvYmouYnl0ZXNQcm9jZXNzZWQgPT09IC0xKSB7XG4gICAgICAvLyByZWFjaGVkIEVPRlxuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gd2UgcmVhZCBzb21lIHNlZ21lbnQgb2YgdGhlIGlucHV0IHN0cmVhbSBhbmQgaGF2ZSBub3QgcmVhY2hlZCBFT0YgeWV0XG4gICAgbGV0IGJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IG9iai5ieXRlc1Byb2Nlc3NlZDtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gdHJ5IHRvIHdyaXRlIGFsbCBvZiB0aGUgY3VycmVudCBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXNXcml0dGVuVGhpc0NodW5rID0gZGVzdFN0cmVhbS53cml0ZShvYmouYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSBieXRlc1dyaXR0ZW5UaGlzQ2h1bms7XG4gICAgICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IG9iai5ieXRlc1Byb2Nlc3NlZCkge1xuICAgICAgICAgIC8vIHdyb3RlIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIHdlIHJlYWQsIG1vdmUgb25cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBUaGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiBiZWNhdXNlIG91ciBBUElzIHNob3VsZCB3cml0ZSB0aGUgZW50aXJlIGJ5dGUgYXJyYXkgb3IgZmFpbCwgYnV0IGp1c3QgaW4gY2FzZS4uLlxuICAgICAgICAvLyB3ZSBkaWRuJ3Qgd3JpdGUgaXQgYWxsLCBzbyBtb3ZlIG9uIHRvIHRyeSBhbmQgd3JpdGUgdGhlIHJlc3Qgb2YgYnVmZmVyLi4uXG4gICAgICAgIG9mZnNldCA9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgbGVuZ3RoID0gb2JqLmJ5dGVzUHJvY2Vzc2VkIC0gYnl0ZXNXcml0dGVuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG4gIH0sIENPUFlfRklMRV9DSFVOS19TSVpFLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IGZpbGVTdHJlYW0gZmlsZSBzdHJlYW1cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsZURlc2NyaXB0b3IocGF0aCwgZmlsZVN0cmVhbSkge1xuICBjb25zdCBwb2ludGVyID0gZmlsZURlc2NyaXB0b3JDb3VudCsrOyAvLyBpbmNyZW1lbnQgZ2xvYmFsIGNvdW50ZXJcbiAgY29uc3QgZmQgPSBuZXcgRmlsZURlc2NyaXB0b3IocG9pbnRlciwgcGF0aCwgZmlsZVN0cmVhbSk7XG4gIGZpbGVEZXNjcmlwdG9ycy5zZXQocG9pbnRlciwgZmQpOyAvLyB1c2UgaXQgdG8gcmVmZXIgdG8gdGhpcyBmaWxlIHN0cmVhbSBhcyB0aGUgXCJkZXNjcmlwdG9yXCJcbiAgcmV0dXJuIHBvaW50ZXI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IG1hdGNoaW5nIHN0cmVhbVxuICovXG5mdW5jdGlvbiBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKSB7XG4gIGNvbnN0IHdyYXBwZXIgPSBmaWxlRGVzY3JpcHRvcnMuZ2V0KGZkKTtcbiAgcmV0dXJuIHdyYXBwZXIuc3RyZWFtO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBtYXRjaGluZyBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gcGF0aEZvckZpbGVEZXNjcmlwdG9yKGZkKSB7XG4gIGNvbnN0IHdyYXBwZXIgPSBmaWxlRGVzY3JpcHRvcnMuZ2V0KGZkKTtcbiAgcmV0dXJuIHdyYXBwZXIucGF0aDtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIG1lcmdlIHRoZSB1c2VyLXN1cHBsaWVkIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdHMgZm9yIGEgZnVuY3Rpb24uIFNwZWNpYWwgY2FzZXMgYSBzdHJpbmcgdG8gYmUgZW5jb2RpbmcuXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgdXNlci1zdXBwbGllZCBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdHMgZGVmYXVsdHMgdG8gdXNlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cbiAgY29uc3Qgb3B0aW9uc1R5cGUgPSB0eXBlb2Ygb3B0aW9ucztcbiAgc3dpdGNoIChvcHRpb25zVHlwZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAvLyBVc2UgY29weSBvZiBkZWZhdWx0cyBidXQgd2l0aCBlbmNvZGluZyBzZXQgdG8gdGhlICdvcHRpb25zJyB2YWx1ZSFcbiAgICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTtcbiAgICAgIG1lcmdlZC5lbmNvZGluZyA9IG9wdGlvbnM7XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICBkZWZhdWx0OlxuICAgICAgYXNzZXJ0QXJndW1lbnRUeXBlKG9wdGlvbnMsICdvcHRpb25zJywgJ29iamVjdCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gc2hvdWxkIG5ldmVyIGdldCByZWFjaGVkXG4gIH1cbn1cblxuLyoqXG4gKiBFbmZvcmNlcyB0aGF0IHdlIGhhdmUgYSB2YWxpZCBjYWxsYmFjayBmdW5jdGlvbi4gVGhyb3dzIFR5cGVFcnJvciBpZiBub3QuXG4gKiBAcGFyYW0geyp9IGNiIHBvc3NpYmxlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYjtcbiAgfVxuICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKGBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uIFJlY2VpdmVkICR7Y2J9YCk7XG4gIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX0NBTExCQUNLJztcbiAgdGhyb3cgZXJyO1xufVxuXG4vKipcbiAqIHJldHVybnMgcmFuZG9tbHkgZ2VuZXJhdGVkIGNoYXJhY3RlcnMgb2YgZ2l2ZW4gbGVuZ3RoIDEtMTZcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIDEgLSAxNlxuICogQHBhcmFtIHtzdHJpbmd9IFtfZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyBvZiB0aGUgc3RyaW5nIGdlbmVyYXRlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQ2hhcmFjdGVycyhsZW5ndGgpIHtcbiAgLy8gRklYTUU6IHVzZSB0aGUgZW5jb2Rpbmcgc3BlY2lmaWVkIVxuICByZXR1cm4gKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpICsgJzAwMDAwMDAwMDAwMDAwMDAwJykuc2xpY2UoMiwgbGVuZ3RoICsgMik7XG59XG5mdW5jdGlvbiBtYWtlRXJyb3IoY29kZSwgbWVzc2FnZSwgZXJybm8sIHN5c2NhbGwsIHBhdGgpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7Y29kZX06ICR7bWVzc2FnZX0sICR7c3lzY2FsbH0gJyR7cGF0aH0nYCk7XG4gIGVycm9yLmVycm5vID0gZXJybm87XG4gIGVycm9yLnN5c2NhbGwgPSBzeXNjYWxsO1xuICBlcnJvci5jb2RlID0gY29kZTtcbiAgZXJyb3IucGF0aCA9IHBhdGg7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2Rpbmcgd2hhdCB3ZSdyZSBlbmNvZGluZyB0b1xuICogQHBhcmFtIHtUaS5CdWZmZXJ9IHRpQnVmZmVyIFRpLkJ1ZmZlciBpbnN0YW5jZVxuICogQHJldHVybnMge0J1ZmZlcn0gbm9kZS1jb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBlbmNvZGVCdWZmZXIoZW5jb2RpbmcsIHRpQnVmZmVyKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgbnVsbDpcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSdyZSBhbHdheXMgcmVhZGluZyBhIGZpbGUgaW50byBhIFRpLkJ1ZmZlclxuICAgICAgLy8gV3JhcHBpbmcgVGkuQnVmZmVyIGlzIHN1cGVyLXNsb3cgYW5kIHNob3VsZCByZWFsbHkgb25seSBiZSBpZiB3ZSdyZSBnb2luZyB0byB3cml0ZSB0byBpdFxuICAgICAgLy8gR28gdGhlIGZhc3RlciBwYXRoIGJ5IGNvbnZlcnRpbmcgdG8gQXJyYXlCdWZmZXIgYW5kIHdyYXBwaW5nIHRoYXRcbiAgICAgIC8vIFRPRE86IEV4cGxpY2l0bHkgcmVsZWFzZSB0aGUgYmxvYiBhZnRlciBjb252ZXJzaW9uP1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRpQnVmZmVyLnRvQmxvYigpLnRvQXJyYXlCdWZmZXIoKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGhlcmUnIHdlcmUgY29udmVydGluZyB0byBhIHN0cmluZyBiYXNlZCBvbiBlbmNvZGluZy4gSW50ZXJuYWxseSBvdXIgZmFzdGVyIEJ1ZmZlciBpbXBsIHN0aWxsIGRlbGVnYXRlcyB0byBUaS5CdWZmZXIgaW4gbW9zdCBjYXNlc1xuICAgICAgLy8gc28gSSBkb24ndCB0aGluayB0aGVyZSdzIG11Y2ggYmVuZWZpdCBmcm9tIGNvbnZlcnRpbmcgdG8gQXJyYXlCdWZmZXIgZmlyc3RcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aUJ1ZmZlcikudG9TdHJpbmcoZW5jb2RpbmcpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge1RpLkZpbGVzeXN0ZW0uRmlsZX1cbiAqL1xuZnVuY3Rpb24gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCkge1xuICAvLyBUaGlzIGlzIGEgaGFjayB0aGF0IGlzIGxpa2VseSB0byB3b3JrIGluIG1vc3QgY2FzZXM/XG4gIC8vIEJhc2ljYWxseSBhc3N1bWVzIEJ1ZmZlciBpcyBob2xkaW5nIGEgdXRmLTggc3RyaW5nIGZpbGVuYW1lL3BhdGhcbiAgLy8gTm9kZSBqdXN0IGNvcGllcyB0aGUgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyIGFzLWlzIG9uIHRoZSBuYXRpdmUgc2lkZSBhbmQgYWRkcyBhIG51bGwgdGVybWluYXRvclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgcGF0aCA9IHBhdGgudG9TdHJpbmcoKTsgLy8gYXNzdW1lcyB1dGYtOCBzdHJpbmdcbiAgfVxuICAvLyBGSVhNRTogSGFuZGxlIFVSTHMhIFdlIGRvbid0IGhhdmUgYW4gVVJMIHNoaW0geWV0LCBzbyBubyB3YXkgdG8gaGFuZGxlIHRob3NlIHlldFxuICBhc3NlcnRBcmd1bWVudFR5cGUocGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIHJldHVybiBUaS5GaWxlc3lzdGVtLmdldEZpbGUocGF0aCk7XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlQnVmZmVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIG9yaWdpbmFsIEJ1ZmZlciBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7d3JpdGVCdWZmZXJDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgcG9zaXRpb24gfHwgbGVuZ3RoIHx8IG9mZnNldCk7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJykge1xuICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICAvLyBvayBub3cgd2hhdD9cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIC8vIE1ha2UgdXNlIG9mIHRoZSBidWZmZXIgc2xpY2UgdGhhdCdzIHNwZWNpZmllZCBieSBvZmZzZXQvbGVuZ3RoXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG4gIHdyaXRlVGlGaWxlU3RyZWFtKHRpRmlsZVN0cmVhbSwgYnVmZmVyLCAoZXJyLCBieXRlc1Byb2Nlc3NlZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzUHJvY2Vzc2VkLCBidWZmZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZUJ1ZmZlclN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuICAvLyBvayBub3cgd2hhdD9cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIC8vIE1ha2UgdXNlIG9mIHRoZSBidWZmZXIgc2xpY2UgdGhhdCdzIHNwZWNpZmllZCBieSBvZmZzZXQvbGVuZ3RoXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG4gIHJldHVybiB0aUZpbGVTdHJlYW0ud3JpdGUoYnVmZmVyLnRvVGlCdWZmZXIoKSk7XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlU3RyaW5nQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIG9yaWdpbmFsIHN0cmluZyBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge3dyaXRlU3RyaW5nQ2FsbGJhY2t9IFtjYWxsYmFja10gYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gd3JpdGVTdHJpbmcoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgZW5jb2RpbmcgfHwgcG9zaXRpb24pO1xuICAvLyBwb3NpdGlvbiBjb3VsZCBiZTogbnVtYmVyLCBmdW5jdGlvbiAoY2FsbGJhY2spXG4gIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInKSB7XG4gICAgcG9zaXRpb24gPSBudWxsO1xuICB9XG4gIC8vIGVuY29kaW5nIGNvdWxkIGJlOiBmdW5jdGlvbiAoY2FsbGJhY2spIG9yIHN0cmluZ1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBzdHJpbmcgKz0gJyc7IC8vIGNvZXJjZSB0byBzdHJpbmdcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZyk7XG4gIC8vIFRPRE86IFN1cHBvcnQgdXNlIG9mIHBvc2l0aW9uIGFyZ3VtZW50LiBJIGFzc3VtZSB3ZSdkIG5lZWQgYSB3YXkgdG8gYWRkIGEgbWV0aG9kIHRvIG1vdmUgdG8gc3RyZWFtIHBvc2l0aW9uIHNvbWVob3dcbiAgd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIChlcnIsIGJ5dGVzUHJvY2Vzc2VkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgYnl0ZXNQcm9jZXNzZWQsIHN0cmluZyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1N5bmMoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmluZyArPSAnJzsgLy8gY29lcmNlIHRvIHN0cmluZ1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKTtcbiAgLy8gVE9ETzogU3VwcG9ydCB1c2Ugb2YgcG9zaXRpb24gYXJndW1lbnQuIEkgYXNzdW1lIHdlJ2QgbmVlZCBhIHdheSB0byBhZGQgYSBtZXRob2QgdG8gbW92ZSB0byBzdHJlYW0gcG9zaXRpb24gc29tZWhvd1xuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuXG5mdW5jdGlvbiBTdHJlYW0oX29wdHMpIHtcbiAgLy8gRklYTUU6IENhbid0IGNhbGwgRXZlbnRFbWl0dGVyIGFzIGEgZnVuY3Rpb24hXG4gIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgLy8gRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0cyk7XG4gIC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzP1xufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLCBFdmVudEVtaXR0ZXIpO1xuLy8gVXNlIHV0aWwuaW5oZXJpdHM/XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkge1xuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG4gIH1cblxuICAvLyBUT0RPOiByZWFkYWJsZVN0YXRlP1xuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICB9XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoX24pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2Qgbm90IGltcGxlbWVudGVkOiBfcmVhZCgpJyk7XG59O1xuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBjb25zdCBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgICB9XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgfVxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAvLyBUT0RPOiBQcm92aWRlIG1vcmUgdGhhbiBhbiBlbXB0eSBjbGFzcyFcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIC8vIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuLy8gQ29weSBXcml0YWJsZSBtZXRob2RzIHRvIER1cGxleCAoYmFzaWNhbGx5IHRoZSBvZGQgZG91YmxlLWluaGVyaXRhbmNlKVxuY29uc3Qgd3JpdGFibGVNZXRob2RzID0gT2JqZWN0LmtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGFibGVNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHdyaXRhYmxlTWV0aG9kcztcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIHtcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgfVxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgLy8gVE9ETzogUHJvdmlkZSBtb3JlIHRoYW4gYW4gZW1wdHkgY2xhc3MhXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICAgIH1cbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cbiAgLy8gdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtOyAvLyBsZWdhY3kgY29tcGF0XG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7XG5cbi8vIExvYWQgYWxsIHRoZSBub2RlIGNvbXBhdGlibGUgY29yZSBtb2R1bGVzXG5yZWdpc3RlcigncGF0aCcsIHBhdGgpO1xucmVnaXN0ZXIoJ29zJywgT1MpO1xucmVnaXN0ZXIoJ3R0eScsIHR0eSk7XG5yZWdpc3RlcigndXRpbCcsIHV0aWwpO1xucmVnaXN0ZXIoJ2Fzc2VydCcsIGFzc2VydCk7XG5yZWdpc3RlcignZXZlbnRzJywgRXZlbnRFbWl0dGVyKTtcbnJlZ2lzdGVyKCdidWZmZXInLCBCdWZmZXJNb2R1bGUpO1xucmVnaXN0ZXIoJ3N0cmluZ19kZWNvZGVyJywgU3RyaW5nRGVjb2RlciQxKTtcbnJlZ2lzdGVyKCdmcycsIGZzKTtcbnJlZ2lzdGVyKCdzdHJlYW0nLCBTdHJlYW0pO1xuXG4vLyBSZWdpc3RlciByZXF1aXJlKCdidWZmZXInKS5CdWZmZXIgYXMgZ2xvYmFsXG5nbG9iYWwuQnVmZmVyID0gQnVmZmVyTW9kdWxlLkJ1ZmZlcjtcblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIERlc2NyaXB0aW9uOlxuICogVGhpcyBzY3JpcHQgbG9hZHMgYWxsIEphdmFTY3JpcHQgZmlsZXMgZW5kaW5nIHdpdGggdGhlIG5hbWUgXCIqLmJvb3RzdHJhcC5qc1wiIGFuZCB0aGVuIGV4ZWN1dGVzIHRoZW0uXG4gKiBUaGUgbWFpbiBpbnRlbnRpb24gb2YgdGhpcyBmZWF0dXJlIGlzIHRvIGFsbG93IEphdmFTY3JpcHQgZmlsZXMgdG8ga2ljay1vZmYgZnVuY3Rpb25hbGl0eSBvclxuICogZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIgYmVmb3JlIHRoZSBcImFwcC5qc1wiIGdldHMgbG9hZGVkLiBUaGlzIGZlYXR1cmUgaXMgdGhlIENvbW1vbkpTXG4gKiBlcXVpdmFsZW50IHRvIFRpdGFuaXVtJ3MgQW5kcm9pZCBtb2R1bGUgb25BcHBDcmVhdGUoKSBvciBpT1MgbW9kdWxlIGxvYWQoKSBmZWF0dXJlcy5cbiAqXG4gKiBVc2UtQ2FzZXM6XG4gKiAtIEF1dG9tYXRpY2FsbHkga2ljay1vZmYgYW5hbHl0aWNzIGZ1bmN0aW9uYWxpdHkgb24gYXBwIHN0YXJ0dXAuXG4gKiAtIEVuc3VyZSBcIkdvb2dsZSBQbGF5IFNlcnZpY2VzXCIgaXMgaW5zdGFsbGVkL3VwZGF0ZWQgb24gYXBwIHN0YXJ0dXAgb24gQW5kcm9pZC5cbiAqL1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGJvb3RzdHJhcHMgZnJvbSBhIFwiYm9vdHN0cmFwLmpzb25cIiBmaWxlIGNyZWF0ZWQgYnkgdGhlIGFwcCBidWlsZCBzeXN0ZW0uXG4gKiBUaGlzIGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIGlzIHRoZSBmYXN0ZXN0IG1ldGhvZCBvZiBhY3F1aXJpbmcgYm9vc3RyYXBzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBUaGlzIEpTT04gZmlsZSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoaXMgc2NyaXB0LlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGlmIGJvb3RzdHJhcHMgd2VyZSBzdWNjZXNzZnVsbHkgbG9hZGVkIGZyb20gSlNPTi5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgSlNPTiBmaWxlIHdhcyBmb3VuZCwgYnV0IG5vIGJvb3RzdHJhcHMgd2VyZSBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogUmV0dXJucyBudWxsIGlmIEpTT04gZmlsZSB3YXMgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBmZXRjaFNjcmlwdHNGcm9tSnNvbigpIHtcbiAgY29uc3QgSlNPTl9GSUxFX05BTUUgPSAnYm9vdHN0cmFwLmpzb24nO1xuICB0cnkge1xuICAgIGNvbnN0IGpzb25GaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCBgdGkuaW50ZXJuYWwvJHtKU09OX0ZJTEVfTkFNRX1gKTtcbiAgICBpZiAoanNvbkZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gSlNPTi5wYXJzZShqc29uRmlsZS5yZWFkKCkudGV4dCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5zY3JpcHRzKSkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2NyaXB0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgVGkuQVBJLmVycm9yKGBGYWlsZWQgdG8gcmVhZCBcIiR7SlNPTl9GSUxFX05BTUV9XCIuIFJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIHRoZSBcIlJlc291cmNlc1wiIGRpcmVjdG9yeSBmb3IgYWxsIFwiKi5ib290c3RyYXAuanNcIiBmaWxlcy5cbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZSgpIGNvbXBhdGlibGUgc3RyaW5ncyBmb3IgZWFjaCBib290c3RyYXAgZm91bmQgaW4gdGhlIHNlYXJjaC5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gYm9vdHN0cmFwIGZpbGVzIHdlcmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKSB7XG4gIGNvbnN0IHJlc291cmNlRGlyZWN0b3J5ID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5KTtcbiAgY29uc3QgcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoID0gcmVzb3VyY2VEaXJlY3RvcnkubmF0aXZlUGF0aC5sZW5ndGg7XG4gIGNvbnN0IGJvb3RzdHJhcFNjcmlwdHMgPSBbXTtcbiAgZnVuY3Rpb24gbG9hZEZyb20oZmlsZSkge1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3RvcnkuIFJlY3Vyc2l2ZWx5IGxvb2sgZm9yIGJvb3RzdHJhcCBmaWxlcyB1bmRlciBpdC5cbiAgICAgICAgY29uc3QgZmlsZU5hbWVBcnJheSA9IGZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuICAgICAgICBpZiAoZmlsZU5hbWVBcnJheSkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBmaWxlTmFtZUFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgbG9hZEZyb20oVGkuRmlsZXN5c3RlbS5nZXRGaWxlKGZpbGUubmF0aXZlUGF0aCwgZmlsZU5hbWVBcnJheVtpbmRleF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5uYW1lLnNlYXJjaCgvLmJvb3RzdHJhcC5qcyQvKSA+PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBib290c3RyYXAgZmlsZS5cbiAgICAgICAgLy8gQ29udmVydCBpdHMgcGF0aCB0byBzb21ldGhpbmcgbG9hZGFibGUgdmlhIHJlcXVpcmUoKSBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheS5cbiAgICAgICAgbGV0IGJvb3RzdHJhcFBhdGggPSBmaWxlLm5hdGl2ZVBhdGg7XG4gICAgICAgIGJvb3RzdHJhcFBhdGggPSBib290c3RyYXBQYXRoLnN1YnN0cihyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgsIGJvb3RzdHJhcFBhdGgubGVuZ3RoIC0gcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoIC0gJy5qcycubGVuZ3RoKTtcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0cy5wdXNoKGJvb3RzdHJhcFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkRnJvbShyZXNvdXJjZURpcmVjdG9yeSk7XG4gIHJldHVybiBib290c3RyYXBTY3JpcHRzO1xufVxuXG4vKipcbiAqIE5vbi1ibG9ja2luZyBmdW5jdGlvbiB3aGljaCBsb2FkcyBhbmQgZXhlY3V0ZXMgYWxsIGJvb3RzdHJhcCBzY3JpcHRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmaW5pc2hlZCBDYWxsYmFjayB0byBiZSBpbnZva2VkIG9uY2UgYWxsIGJvb3RzdHJhcHMgaGF2ZSBmaW5pc2hlZCBleGVjdXRpbmcuIENhbm5vdCBiZSBudWxsLlxuICovXG5mdW5jdGlvbiBsb2FkQXN5bmMoZmluaXNoZWQpIHtcbiAgLy8gQWNxdWlyZSBhbiBhcnJheSBvZiBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgaW5jbHVkZWQgd2l0aCB0aGUgYXBwLlxuICAvLyAtIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBhdHRlbXB0IHRvIGZldGNoIHNjcmlwdHMgdmlhIGFuIG9wdGlvbmFsIEpTT04gZmlsZSBjcmVhdGVkIGJ5IHRoZSBidWlsZCBzeXN0ZW0uXG4gIC8vIC0gSWYgSlNPTiBmaWxlIG5vdCBmb3VuZCAod2lsbCByZXR1cm4gbnVsbCksIHRoZW4gc2VhcmNoIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBib290c3RyYXAgZmlsZXMuXG4gIGxldCBib290c3RyYXBTY3JpcHRzID0gZmV0Y2hTY3JpcHRzRnJvbUpzb24oKTtcbiAgaWYgKCFib290c3RyYXBTY3JpcHRzKSB7XG4gICAgYm9vdHN0cmFwU2NyaXB0cyA9IGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKTtcbiAgfVxuXG4gIC8vIERvIG5vdCBjb250aW51ZSBpZiBubyBib290c3RyYXBzIHdlcmUgZm91bmQuXG4gIGlmICghYm9vdHN0cmFwU2NyaXB0cyB8fCBib290c3RyYXBTY3JpcHRzLmxlbmd0aCA8PSAwKSB7XG4gICAgZmluaXNoZWQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTb3J0IHRoZSBib290c3RyYXBzIHNvIHRoYXQgdGhleSdsbCBiZSBsb2FkZWQgaW4gYSBjb25zaXN0ZW50IG9yZGVyIGJldHdlZW4gcGxhdGZvcm1zLlxuICBib290c3RyYXBTY3JpcHRzLnNvcnQoKTtcblxuICAvLyBMb2FkcyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgZm91bmQuXG4gIGZ1bmN0aW9uIGxvYWRCb290c3RyYXBTY3JpcHRzKGZpbmlzaGVkKSB7XG4gICAgbGV0IGJvb3RzdHJhcEluZGV4ID0gMDtcbiAgICBmdW5jdGlvbiBkb0xvYWQoKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGxvYWQgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAgICAgd2hpbGUgKGJvb3RzdHJhcEluZGV4IDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTG9hZCB0aGUgbmV4dCBib290c3RyYXAuXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYm9vdHN0cmFwU2NyaXB0c1tib290c3RyYXBJbmRleF07XG4gICAgICAgIGNvbnN0IGJvb3RzdHJhcCA9IHJlcXVpcmUoZmlsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG5cbiAgICAgICAgLy8gSW52b2tlIHRoZSBib290c3RyYXAncyBleGVjdXRlKCkgbWV0aG9kIGlmIGl0IGhhcyBvbmUuIChUaGlzIGlzIG9wdGlvbmFsLilcbiAgICAgICAgLy8gV2UgbXVzdCB3YWl0IGZvciB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBiZWZvcmUgbG9hZGluZyB0aGUgbmV4dCBzY3JpcHQuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgdXNlZCB0byBkaXNwbGF5IFVJIHRvIHRoZSBlbmQtdXNlci5cbiAgICAgICAgaWYgKGJvb3RzdHJhcC5leGVjdXRlKSB7XG4gICAgICAgICAgYm9vdHN0cmFwLmV4ZWN1dGUob25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoZSBjdXJyZW50IGJvb3RzdHJhcC4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cbiAgICAgICAgYm9vdHN0cmFwSW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgLy8gSW52b2tlIGdpdmVuIGNhbGxiYWNrIHRvIGluZm9ybSBjYWxsZXIgdGhhdCBhbGwgbG9hZGluZyBpcyBkb25lLlxuICAgICAgZmluaXNoZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCgpIHtcbiAgICAgIC8vIExhc3QgYm9vdHN0cmFwIGhhcyBmaW5pc2hlZCBleGVjdXRpb24uIFRpbWUgdG8gbG9hZCB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBOb3RlOiBBZGQgYSB0aW55IGRlbGF5IHNvIHdoYXRldmVyIFVJIHRoZSBsYXN0IGJvb3RzdHJhcCBsb2FkZWQgaGFzIHRpbWUgdG8gY2xvc2UuXG4gICAgICBib290c3RyYXBJbmRleCsrO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBkb0xvYWQoKSwgMSk7XG4gICAgfVxuICAgIGRvTG9hZCgpO1xuICB9XG5cbiAgLy8gV2UndmUgZmluaXNoZWQgbG9hZGluZy9leGVjdXRpbmcgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAvLyBJbmZvcm0gY2FsbGVyIGJ5IGludm9raW5nIHRoZSBjYWxsYmFjayBnaXZlbiB0byBsb2FkQXN5bmMoKS5cbiAgbG9hZEJvb3RzdHJhcFNjcmlwdHMoZmluaXNoZWQpO1xufVxuXG4vKipcbiAqIFRpdGFuaXVtIFNES1xuICogQ29weXJpZ2h0IFRpRGV2LCBJbmMuIDA0LzA3LzIwMjItUHJlc2VudC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKlxuICogVGhpcyBzY3JpcHQgaXMgbG9hZGVkIG9uIGFwcCBzdGFydHVwIG9uIGFsbCBwbGF0Zm9ybXMuIEl0IGlzIHVzZWQgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqIC0gUHJvdmlkZSBjb25zaXN0ZW50IHN0YXJ0dXAgYmVoYXZpb3IgYmV0d2VlbiBwbGF0Zm9ybXMsIHN1Y2ggYXMgbG9nZ2luZyBUaXRhbml1bSB2ZXJzaW9uLlxuICogLSBMb2FkIFRpdGFuaXVtJ3MgY29yZSBKYXZhU2NyaXB0IGV4dGVuc2lvbnMgc2hhcmVkIGJ5IGFsbCBwbGF0Zm9ybXMuXG4gKiAtIFByb3ZpZGUgXCIqLmJvb3RzdHJhcC5qc1wiIHNjcmlwdCBzdXBwb3J0LiAoU2ltaWxhciB0byBuYXRpdmUgbW9kdWxlIG9uQXBwQ3JlYXRlKCkvbG9hZCgpIHN1cHBvcnQuKVxuICogLSBMb2FkIHRoZSBhcHAgZGV2ZWxvcGVyJ3MgbWFpbiBcImFwcC5qc1wiIHNjcmlwdCBhZnRlciBkb2luZyBhbGwgb2YgdGhlIGFib3ZlLlxuICovXG5cbi8vIExvZyB0aGUgYXBwIG5hbWUsIGFwcCB2ZXJzaW9uLCBhbmQgVGl0YW5pdW0gdmVyc2lvbiBvbiBzdGFydHVwLlxuVGkuQVBJLmluZm8oYCR7VGkuQXBwLm5hbWV9ICR7VGkuQXBwLnZlcnNpb259IChQb3dlcmVkIGJ5IFRpdGFuaXVtICR7XCIxMi43LjFcIn0uJHtcImVhODU3ZGRkMmJcIn0pYCk7XG5sb2FkQXN5bmMoZnVuY3Rpb24gKCkge1xuICAvLyBXZSd2ZSBmaW5pc2hlZCBsb2FkaW5nL2V4ZWN1dGluZyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMuXG4gIC8vIFdlIGNhbiBub3cgcHJvY2VlZCB0byBydW4gdGhlIG1haW4gXCJhcHAuanNcIiBzY3JpcHQuXG4gIHJlcXVpcmUoJy4vYXBwJyk7XG5cbiAgLy8gVGhpcyBldmVudCBpcyB0byBiZSBmaXJlZCBhZnRlciBcImFwcC5qc1wiIGV4ZWN1dGlvbi4gUmVhc29uczpcbiAgLy8gLSBBbGxvdyBzeXN0ZW0gdG8gcXVldWUgc3RhcnR1cCByZWxhdGVkIGV2ZW50cyB1bnRpbCBcImFwcC5qc1wiIGhhcyBoYWQgYSBjaGFuY2UgdG8gYWRkIGxpc3RlbmVycy5cbiAgLy8gLSBGb3IgQWxsb3kgYXBwcywgd2Ugbm93IGtub3cgdGhhdCBBbGxveSBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaXRzIGdsb2JhbHMgd2VyZSBhZGRlZC5cbiAgVGkuQXBwLmZpcmVFdmVudCgnc3RhcnRlZCcpO1xufSk7XG4iXSwidmVyc2lvbiI6M30=
